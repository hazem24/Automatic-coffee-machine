
ACM.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         000034b4  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         000000e8  00800060  000034b4  00003548  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          000006d2  00800148  00800148  00003630  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  00003630  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 0000003c  00000000  00000000  00003660  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000588  00000000  00000000  0000369c  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000081b2  00000000  00000000  00003c24  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00001c6d  00000000  00000000  0000bdd6  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   000043cc  00000000  00000000  0000da43  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00000fc4  00000000  00000000  00011e10  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00002371  00000000  00000000  00012dd4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00007100  00000000  00000000  00015145  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000608  00000000  00000000  0001c245  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	3e c0       	rjmp	.+124    	; 0x7e <__ctors_end>
       2:	00 00       	nop
       4:	59 c0       	rjmp	.+178    	; 0xb8 <__bad_interrupt>
       6:	00 00       	nop
       8:	57 c0       	rjmp	.+174    	; 0xb8 <__bad_interrupt>
       a:	00 00       	nop
       c:	49 c5       	rjmp	.+2706   	; 0xaa0 <__vector_3>
       e:	00 00       	nop
      10:	53 c0       	rjmp	.+166    	; 0xb8 <__bad_interrupt>
      12:	00 00       	nop
      14:	51 c0       	rjmp	.+162    	; 0xb8 <__bad_interrupt>
      16:	00 00       	nop
      18:	4f c0       	rjmp	.+158    	; 0xb8 <__bad_interrupt>
      1a:	00 00       	nop
      1c:	0c 94 1a 0e 	jmp	0x1c34	; 0x1c34 <__vector_7>
      20:	4b c0       	rjmp	.+150    	; 0xb8 <__bad_interrupt>
      22:	00 00       	nop
      24:	49 c0       	rjmp	.+146    	; 0xb8 <__bad_interrupt>
      26:	00 00       	nop
      28:	47 c0       	rjmp	.+142    	; 0xb8 <__bad_interrupt>
      2a:	00 00       	nop
      2c:	45 c0       	rjmp	.+138    	; 0xb8 <__bad_interrupt>
      2e:	00 00       	nop
      30:	43 c0       	rjmp	.+134    	; 0xb8 <__bad_interrupt>
      32:	00 00       	nop
      34:	41 c0       	rjmp	.+130    	; 0xb8 <__bad_interrupt>
      36:	00 00       	nop
      38:	3f c0       	rjmp	.+126    	; 0xb8 <__bad_interrupt>
      3a:	00 00       	nop
      3c:	3d c0       	rjmp	.+122    	; 0xb8 <__bad_interrupt>
      3e:	00 00       	nop
      40:	3b c0       	rjmp	.+118    	; 0xb8 <__bad_interrupt>
      42:	00 00       	nop
      44:	39 c0       	rjmp	.+114    	; 0xb8 <__bad_interrupt>
      46:	00 00       	nop
      48:	37 c0       	rjmp	.+110    	; 0xb8 <__bad_interrupt>
      4a:	00 00       	nop
      4c:	35 c0       	rjmp	.+106    	; 0xb8 <__bad_interrupt>
      4e:	00 00       	nop
      50:	33 c0       	rjmp	.+102    	; 0xb8 <__bad_interrupt>
      52:	00 00       	nop
      54:	4d 07       	cpc	r20, r29
      56:	6a 07       	cpc	r22, r26
      58:	72 07       	cpc	r23, r18
      5a:	7a 07       	cpc	r23, r26
      5c:	82 07       	cpc	r24, r18
      5e:	8a 07       	cpc	r24, r26
      60:	92 07       	cpc	r25, r18
      62:	9a 07       	cpc	r25, r26
      64:	a2 07       	cpc	r26, r18
      66:	aa 07       	cpc	r26, r26
      68:	b2 07       	cpc	r27, r18
      6a:	ce 19       	sub	r28, r14
      6c:	ce 19       	sub	r28, r14
      6e:	ce 19       	sub	r28, r14
      70:	fc 19       	sub	r31, r12
      72:	04 1a       	sub	r0, r20
      74:	13 1a       	sub	r1, r19
      76:	ce 19       	sub	r28, r14
      78:	ce 19       	sub	r28, r14
      7a:	fc 19       	sub	r31, r12
      7c:	04 1a       	sub	r0, r20

0000007e <__ctors_end>:
      7e:	11 24       	eor	r1, r1
      80:	1f be       	out	0x3f, r1	; 63
      82:	cf e5       	ldi	r28, 0x5F	; 95
      84:	d8 e0       	ldi	r29, 0x08	; 8
      86:	de bf       	out	0x3e, r29	; 62
      88:	cd bf       	out	0x3d, r28	; 61

0000008a <__do_copy_data>:
      8a:	11 e0       	ldi	r17, 0x01	; 1
      8c:	a0 e6       	ldi	r26, 0x60	; 96
      8e:	b0 e0       	ldi	r27, 0x00	; 0
      90:	e4 eb       	ldi	r30, 0xB4	; 180
      92:	f4 e3       	ldi	r31, 0x34	; 52
      94:	02 c0       	rjmp	.+4      	; 0x9a <__do_copy_data+0x10>
      96:	05 90       	lpm	r0, Z+
      98:	0d 92       	st	X+, r0
      9a:	a8 34       	cpi	r26, 0x48	; 72
      9c:	b1 07       	cpc	r27, r17
      9e:	d9 f7       	brne	.-10     	; 0x96 <__do_copy_data+0xc>

000000a0 <__do_clear_bss>:
      a0:	28 e0       	ldi	r18, 0x08	; 8
      a2:	a8 e4       	ldi	r26, 0x48	; 72
      a4:	b1 e0       	ldi	r27, 0x01	; 1
      a6:	01 c0       	rjmp	.+2      	; 0xaa <.do_clear_bss_start>

000000a8 <.do_clear_bss_loop>:
      a8:	1d 92       	st	X+, r1

000000aa <.do_clear_bss_start>:
      aa:	aa 31       	cpi	r26, 0x1A	; 26
      ac:	b2 07       	cpc	r27, r18
      ae:	e1 f7       	brne	.-8      	; 0xa8 <.do_clear_bss_loop>
      b0:	0e 94 68 08 	call	0x10d0	; 0x10d0 <main>
      b4:	0c 94 58 1a 	jmp	0x34b0	; 0x34b0 <_exit>

000000b8 <__bad_interrupt>:
      b8:	a3 cf       	rjmp	.-186    	; 0x0 <__vectors>

000000ba <display_Char_CallBack>:
 * @param xTimer 
 */
static void display_Char_CallBack( TimerHandle_t xTimer )
{
    /* Give Semaphore of Display Chars. */
    xSemaphoreGive( sema_display_char );
      ba:	20 e0       	ldi	r18, 0x00	; 0
      bc:	40 e0       	ldi	r20, 0x00	; 0
      be:	50 e0       	ldi	r21, 0x00	; 0
      c0:	60 e0       	ldi	r22, 0x00	; 0
      c2:	70 e0       	ldi	r23, 0x00	; 0
      c4:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <sema_display_char>
      c8:	90 91 9d 01 	lds	r25, 0x019D	; 0x80019d <sema_display_char+0x1>
      cc:	0c 94 55 0f 	jmp	0x1eaa	; 0x1eaa <xQueueGenericSend>
      d0:	08 95       	ret

000000d2 <COFFEE_MACHINE_MSG_sent>:
 * @brief CallBack Function POST a semaphore which means LCD is Free.
 */
static uint8_t COFFEE_MACHINE_MSG_sent()
{
    /* Send Notification to Display TASK. */
    xSemaphoreGive(sema_display_string);
      d2:	20 e0       	ldi	r18, 0x00	; 0
      d4:	40 e0       	ldi	r20, 0x00	; 0
      d6:	50 e0       	ldi	r21, 0x00	; 0
      d8:	60 e0       	ldi	r22, 0x00	; 0
      da:	70 e0       	ldi	r23, 0x00	; 0
      dc:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <sema_display_string>
      e0:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <sema_display_string+0x1>
      e4:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
    return TRUE;
}
      e8:	81 e0       	ldi	r24, 0x01	; 1
      ea:	08 95       	ret

000000ec <take_coins_timer_CallBack>:
/**
 * @brief This is a callback function called when take coins time finished.
 * @param xTimer 
 */
static void take_coins_timer_CallBack( TimerHandle_t xTimer )
{
      ec:	0f 93       	push	r16
      ee:	1f 93       	push	r17
      f0:	cf 93       	push	r28
    /* Give A semaphore to Collect_Coins Task.  */
    static sint8_t au8_counter = COUNT_DOWN_IN_SEC, i = 0;

    au8_counter--;
      f2:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
      f6:	81 50       	subi	r24, 0x01	; 1
      f8:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
    
    if ( (sint8_t)au8_counter < (sint8_t)FALSE )
      fc:	88 23       	and	r24, r24
      fe:	e4 f4       	brge	.+56     	; 0x138 <take_coins_timer_CallBack+0x4c>
    {
        au8_counter = COUNT_DOWN_IN_SEC;
     100:	85 e0       	ldi	r24, 0x05	; 5
     102:	80 93 60 00 	sts	0x0060, r24	; 0x800060 <__data_start>
        xTimerStop( g_count_down_timer, (TickType_t)portMAX_DELAY );
     106:	0f ef       	ldi	r16, 0xFF	; 255
     108:	1f ef       	ldi	r17, 0xFF	; 255
     10a:	20 e0       	ldi	r18, 0x00	; 0
     10c:	30 e0       	ldi	r19, 0x00	; 0
     10e:	40 e0       	ldi	r20, 0x00	; 0
     110:	50 e0       	ldi	r21, 0x00	; 0
     112:	63 e0       	ldi	r22, 0x03	; 3
     114:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <g_count_down_timer>
     118:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <g_count_down_timer+0x1>
     11c:	0e 94 8e 18 	call	0x311c	; 0x311c <xTimerGenericCommand>
        /* Send Semaphore to Collect Coins Task to start it's logic. */
        xSemaphoreGive(sema_allowable_time_for_insert_coins);
     120:	20 e0       	ldi	r18, 0x00	; 0
     122:	40 e0       	ldi	r20, 0x00	; 0
     124:	50 e0       	ldi	r21, 0x00	; 0
     126:	60 e0       	ldi	r22, 0x00	; 0
     128:	70 e0       	ldi	r23, 0x00	; 0
     12a:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <sema_allowable_time_for_insert_coins>
     12e:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <sema_allowable_time_for_insert_coins+0x1>
     132:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
     136:	22 c0       	rjmp	.+68     	; 0x17c <take_coins_timer_CallBack+0x90>
    }
    else
    {
        if ( (sint8_t)FALSE != (sint8_t)au8_counter )
     138:	88 23       	and	r24, r24
     13a:	01 f1       	breq	.+64     	; 0x17c <take_coins_timer_CallBack+0x90>
        {
            LCD_Goto(THIRD_ROW, 18);
     13c:	62 e1       	ldi	r22, 0x12	; 18
     13e:	83 e0       	ldi	r24, 0x03	; 3
     140:	a0 d7       	rcall	.+3904   	; 0x1082 <LCD_Goto>
            LCD_Display_Char((au8_counter / 10) + 0x30);
     142:	90 91 60 00 	lds	r25, 0x0060	; 0x800060 <__data_start>
     146:	c7 e6       	ldi	r28, 0x67	; 103
     148:	9c 02       	muls	r25, r28
     14a:	81 2d       	mov	r24, r1
     14c:	11 24       	eor	r1, r1
     14e:	85 95       	asr	r24
     150:	85 95       	asr	r24
     152:	97 fd       	sbrc	r25, 7
     154:	83 95       	inc	r24
     156:	80 5d       	subi	r24, 0xD0	; 208
     158:	42 d7       	rcall	.+3716   	; 0xfde <LCD_Display_Char>
            LCD_Display_Char((au8_counter % 10) + 0x30);
     15a:	80 91 60 00 	lds	r24, 0x0060	; 0x800060 <__data_start>
     15e:	8c 02       	muls	r24, r28
     160:	c1 2d       	mov	r28, r1
     162:	11 24       	eor	r1, r1
     164:	c5 95       	asr	r28
     166:	c5 95       	asr	r28
     168:	87 fd       	sbrc	r24, 7
     16a:	c3 95       	inc	r28
     16c:	cc 0f       	add	r28, r28
     16e:	9c 2f       	mov	r25, r28
     170:	99 0f       	add	r25, r25
     172:	99 0f       	add	r25, r25
     174:	c9 0f       	add	r28, r25
     176:	8c 1b       	sub	r24, r28
     178:	80 5d       	subi	r24, 0xD0	; 208
     17a:	31 d7       	rcall	.+3682   	; 0xfde <LCD_Display_Char>
        }
    }
}
     17c:	cf 91       	pop	r28
     17e:	1f 91       	pop	r17
     180:	0f 91       	pop	r16
     182:	08 95       	ret

00000184 <send_default_page>:
 */
static void send_default_page()
{
    /* Send To Display Task => Default Page (Coffee Prices). */
    /* Access Mailbox safely. */
    g_mail_box.message_id = WELCOME_MSG_ID;
     184:	81 e0       	ldi	r24, 0x01	; 1
     186:	80 93 63 00 	sts	0x0063, r24	; 0x800063 <g_mail_box>

    strcpy( g_mail_box.message, WELCOME_MSG );
     18a:	84 e1       	ldi	r24, 0x14	; 20
     18c:	ea ea       	ldi	r30, 0xAA	; 170
     18e:	f0 e0       	ldi	r31, 0x00	; 0
     190:	a4 e6       	ldi	r26, 0x64	; 100
     192:	b0 e0       	ldi	r27, 0x00	; 0
     194:	01 90       	ld	r0, Z+
     196:	0d 92       	st	X+, r0
     198:	8a 95       	dec	r24
     19a:	e1 f7       	brne	.-8      	; 0x194 <send_default_page+0x10>

    xQueueReset(display_msg_mail_box);
     19c:	60 e0       	ldi	r22, 0x00	; 0
     19e:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     1a2:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     1a6:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <xQueueGenericReset>

    /* Send A new mailbox for Display Task. */
    xQueueSend(display_msg_mail_box, &g_ptr_display_mailbox, (TickType_t)0);
     1aa:	20 e0       	ldi	r18, 0x00	; 0
     1ac:	40 e0       	ldi	r20, 0x00	; 0
     1ae:	50 e0       	ldi	r21, 0x00	; 0
     1b0:	61 e6       	ldi	r22, 0x61	; 97
     1b2:	70 e0       	ldi	r23, 0x00	; 0
     1b4:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     1b8:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     1bc:	0c 94 55 0f 	jmp	0x1eaa	; 0x1eaa <xQueueGenericSend>
     1c0:	08 95       	ret

000001c2 <COFFEE_MACHINE_Display_MainPage>:
/**
 * @brief Display Task Call This Function when Message ID = 1 which means Welcome MSG.
 * @param a_ptr_products 
 */
static void COFFEE_MACHINE_Display_MainPage(const sint8_t au8_category_number,const Str_Products* a_ptr_products, const uint8_t au8_MSG_Type)
{
     1c2:	cf 92       	push	r12
     1c4:	df 92       	push	r13
     1c6:	ef 92       	push	r14
     1c8:	0f 93       	push	r16
     1ca:	1f 93       	push	r17
     1cc:	cf 93       	push	r28
     1ce:	df 93       	push	r29
     1d0:	00 d0       	rcall	.+0      	; 0x1d2 <COFFEE_MACHINE_Display_MainPage+0x10>
     1d2:	00 d0       	rcall	.+0      	; 0x1d4 <COFFEE_MACHINE_Display_MainPage+0x12>
     1d4:	1f 92       	push	r1
     1d6:	cd b7       	in	r28, 0x3d	; 61
     1d8:	de b7       	in	r29, 0x3e	; 62
     1da:	e8 2e       	mov	r14, r24
     1dc:	6b 01       	movw	r12, r22
     1de:	14 2f       	mov	r17, r20
    static uint8_t u8_mainPage[LONGEST_MSG_LEN];
    sint8_t au8_row = au8_category_number + 1, 
    au8_col = FIRST_COL, au8_price[3] = {0}, au8_number[2] = {0};
     1e0:	19 82       	std	Y+1, r1	; 0x01
     1e2:	1a 82       	std	Y+2, r1	; 0x02
     1e4:	1b 82       	std	Y+3, r1	; 0x03
     1e6:	1d 82       	std	Y+5, r1	; 0x05
     1e8:	1c 82       	std	Y+4, r1	; 0x04
    

    /* Choose The Right ROW. */
    LCD_Goto(au8_row, au8_col);
     1ea:	61 e0       	ldi	r22, 0x01	; 1
     1ec:	81 e0       	ldi	r24, 0x01	; 1
     1ee:	8e 0d       	add	r24, r14
     1f0:	48 d7       	rcall	.+3728   	; 0x1082 <LCD_Goto>

    /* Display product id. */
    /* Display price. */
    /* Display Product Name. */ 
    u8_mainPage[0] = '\0';
     1f2:	10 92 48 01 	sts	0x0148, r1	; 0x800148 <__data_end>
    switch (au8_MSG_Type)
     1f6:	11 30       	cpi	r17, 0x01	; 1
     1f8:	19 f0       	breq	.+6      	; 0x200 <COFFEE_MACHINE_Display_MainPage+0x3e>
     1fa:	12 30       	cpi	r17, 0x02	; 2
     1fc:	79 f0       	breq	.+30     	; 0x21c <COFFEE_MACHINE_Display_MainPage+0x5a>
     1fe:	33 c0       	rjmp	.+102    	; 0x266 <COFFEE_MACHINE_Display_MainPage+0xa4>
    {
    case WELCOME_MSG_ID:
        strcat(u8_mainPage, WELCOME_MSG);
     200:	a8 e4       	ldi	r26, 0x48	; 72
     202:	b1 e0       	ldi	r27, 0x01	; 1
     204:	0d 90       	ld	r0, X+
     206:	00 20       	and	r0, r0
     208:	e9 f7       	brne	.-6      	; 0x204 <COFFEE_MACHINE_Display_MainPage+0x42>
     20a:	11 97       	sbiw	r26, 0x01	; 1
     20c:	84 e1       	ldi	r24, 0x14	; 20
     20e:	ea ea       	ldi	r30, 0xAA	; 170
     210:	f0 e0       	ldi	r31, 0x00	; 0
     212:	01 90       	ld	r0, Z+
     214:	0d 92       	st	X+, r0
     216:	8a 95       	dec	r24
     218:	e1 f7       	brne	.-8      	; 0x212 <COFFEE_MACHINE_Display_MainPage+0x50>
        break;
     21a:	25 c0       	rjmp	.+74     	; 0x266 <COFFEE_MACHINE_Display_MainPage+0xa4>
    case MENU_MSG_ID:
        /* Display Main Menu. */

        /* Add The Currency Type. */
        au8_price[1]   = CURRENCY_TYPE;
     21c:	84 e2       	ldi	r24, 0x24	; 36
     21e:	8a 83       	std	Y+2, r24	; 0x02
        /* Convert Number and Price form character to string. */
        au8_price[0]   = a_ptr_products[au8_category_number].coffee_price + 0x30;
     220:	86 01       	movw	r16, r12
     222:	8e 2d       	mov	r24, r14
     224:	94 e0       	ldi	r25, 0x04	; 4
     226:	89 02       	muls	r24, r25
     228:	00 0d       	add	r16, r0
     22a:	11 1d       	adc	r17, r1
     22c:	11 24       	eor	r1, r1
     22e:	f8 01       	movw	r30, r16
     230:	81 81       	ldd	r24, Z+1	; 0x01
     232:	80 5d       	subi	r24, 0xD0	; 208
     234:	89 83       	std	Y+1, r24	; 0x01
        au8_number[0]  = a_ptr_products[au8_category_number].coffee_id + 0x30;
     236:	80 81       	ld	r24, Z
     238:	80 5d       	subi	r24, 0xD0	; 208
     23a:	8c 83       	std	Y+4, r24	; 0x04

        /* Number of Product. */
        strcat(u8_mainPage, au8_number);
     23c:	be 01       	movw	r22, r28
     23e:	6c 5f       	subi	r22, 0xFC	; 252
     240:	7f 4f       	sbci	r23, 0xFF	; 255
     242:	88 e4       	ldi	r24, 0x48	; 72
     244:	91 e0       	ldi	r25, 0x01	; 1
     246:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcat>
        /* Name of product. */
        strcat(u8_mainPage, a_ptr_products[au8_category_number].coffee_type);
     24a:	f8 01       	movw	r30, r16
     24c:	62 81       	ldd	r22, Z+2	; 0x02
     24e:	73 81       	ldd	r23, Z+3	; 0x03
     250:	88 e4       	ldi	r24, 0x48	; 72
     252:	91 e0       	ldi	r25, 0x01	; 1
     254:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcat>
        /* Price of product. */
        strcat(u8_mainPage, au8_price);
     258:	be 01       	movw	r22, r28
     25a:	6f 5f       	subi	r22, 0xFF	; 255
     25c:	7f 4f       	sbci	r23, 0xFF	; 255
     25e:	88 e4       	ldi	r24, 0x48	; 72
     260:	91 e0       	ldi	r25, 0x01	; 1
     262:	0e 94 4d 1a 	call	0x349a	; 0x349a <strcat>
        break;
    default:
        break;
    } 

    uint8_t au8_len = strlen(u8_mainPage);
     266:	e8 e4       	ldi	r30, 0x48	; 72
     268:	f1 e0       	ldi	r31, 0x01	; 1
     26a:	01 90       	ld	r0, Z+
     26c:	00 20       	and	r0, r0
     26e:	e9 f7       	brne	.-6      	; 0x26a <COFFEE_MACHINE_Display_MainPage+0xa8>
     270:	31 97       	sbiw	r30, 0x01	; 1
     272:	e8 54       	subi	r30, 0x48	; 72
     274:	f1 40       	sbci	r31, 0x01	; 1
     276:	0e 2f       	mov	r16, r30
    /* send this string to strcpy. */
    
    for(uint8_t i = 0; i <= au8_len; ++i)
     278:	10 e0       	ldi	r17, 0x00	; 0
    {
        LCD_Display_String(u8_mainPage, au8_len, COFFEE_MACHINE_MSG_sent);
     27a:	49 e6       	ldi	r20, 0x69	; 105
     27c:	50 e0       	ldi	r21, 0x00	; 0
     27e:	60 2f       	mov	r22, r16
     280:	88 e4       	ldi	r24, 0x48	; 72
     282:	91 e0       	ldi	r25, 0x01	; 1
     284:	d3 d6       	rcall	.+3494   	; 0x102c <LCD_Display_String>
        /* Wait Display Character Semaphore to release so that this means LCD Ready can display Another Char. */
        xSemaphoreTake(sema_display_char, portMAX_DELAY);
     286:	6f ef       	ldi	r22, 0xFF	; 255
     288:	7f ef       	ldi	r23, 0xFF	; 255
     28a:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <sema_display_char>
     28e:	90 91 9d 01 	lds	r25, 0x019D	; 0x80019d <sema_display_char+0x1>
     292:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
    } 

    uint8_t au8_len = strlen(u8_mainPage);
    /* send this string to strcpy. */
    
    for(uint8_t i = 0; i <= au8_len; ++i)
     296:	1f 5f       	subi	r17, 0xFF	; 255
     298:	01 17       	cp	r16, r17
     29a:	78 f7       	brcc	.-34     	; 0x27a <COFFEE_MACHINE_Display_MainPage+0xb8>
    {
        LCD_Display_String(u8_mainPage, au8_len, COFFEE_MACHINE_MSG_sent);
        /* Wait Display Character Semaphore to release so that this means LCD Ready can display Another Char. */
        xSemaphoreTake(sema_display_char, portMAX_DELAY);
    }
}
     29c:	0f 90       	pop	r0
     29e:	0f 90       	pop	r0
     2a0:	0f 90       	pop	r0
     2a2:	0f 90       	pop	r0
     2a4:	0f 90       	pop	r0
     2a6:	df 91       	pop	r29
     2a8:	cf 91       	pop	r28
     2aa:	1f 91       	pop	r17
     2ac:	0f 91       	pop	r16
     2ae:	ef 90       	pop	r14
     2b0:	df 90       	pop	r13
     2b2:	cf 90       	pop	r12
     2b4:	08 95       	ret

000002b6 <display_msg>:
 * @brief Display Messages => LCD.
 * @note => All messages in the system displayed via this function except Main Page via "COFFEE_MACHINE_Display_MainPage".
 * @param au8_msg => msg to display. 
 */
static void display_msg(const char* au8_msg)
{
     2b6:	0f 93       	push	r16
     2b8:	1f 93       	push	r17
     2ba:	cf 93       	push	r28
     2bc:	df 93       	push	r29
    /* Check For NULL pointer. */
    if ( NULL != au8_msg )
     2be:	00 97       	sbiw	r24, 0x00	; 0
     2c0:	c9 f0       	breq	.+50     	; 0x2f4 <display_msg+0x3e>
     2c2:	8c 01       	movw	r16, r24
    {
        uint8_t au8_len = strlen(au8_msg);
     2c4:	fc 01       	movw	r30, r24
     2c6:	01 90       	ld	r0, Z+
     2c8:	00 20       	and	r0, r0
     2ca:	e9 f7       	brne	.-6      	; 0x2c6 <display_msg+0x10>
     2cc:	31 97       	sbiw	r30, 0x01	; 1
     2ce:	de 2f       	mov	r29, r30
     2d0:	d8 1b       	sub	r29, r24
        for(uint8_t i = 0; i <= au8_len; ++i)
     2d2:	c0 e0       	ldi	r28, 0x00	; 0
        {
            LCD_Display_String(au8_msg, au8_len, COFFEE_MACHINE_MSG_sent);
     2d4:	49 e6       	ldi	r20, 0x69	; 105
     2d6:	50 e0       	ldi	r21, 0x00	; 0
     2d8:	6d 2f       	mov	r22, r29
     2da:	c8 01       	movw	r24, r16
     2dc:	a7 d6       	rcall	.+3406   	; 0x102c <LCD_Display_String>
            /* Wait Display Character Semaphore to release so that this means LCD Ready can display Another Char. */
            xSemaphoreTake(sema_display_char, portMAX_DELAY);
     2de:	6f ef       	ldi	r22, 0xFF	; 255
     2e0:	7f ef       	ldi	r23, 0xFF	; 255
     2e2:	80 91 9c 01 	lds	r24, 0x019C	; 0x80019c <sema_display_char>
     2e6:	90 91 9d 01 	lds	r25, 0x019D	; 0x80019d <sema_display_char+0x1>
     2ea:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
{
    /* Check For NULL pointer. */
    if ( NULL != au8_msg )
    {
        uint8_t au8_len = strlen(au8_msg);
        for(uint8_t i = 0; i <= au8_len; ++i)
     2ee:	cf 5f       	subi	r28, 0xFF	; 255
     2f0:	dc 17       	cp	r29, r28
     2f2:	80 f7       	brcc	.-32     	; 0x2d4 <display_msg+0x1e>
    }
    else
    {
        /* NOP. */
    }
}
     2f4:	df 91       	pop	r29
     2f6:	cf 91       	pop	r28
     2f8:	1f 91       	pop	r17
     2fa:	0f 91       	pop	r16
     2fc:	08 95       	ret

000002fe <System_Init_Task>:
/**
 * @brief Task to => Init all Modules needed.
 * @param a_ptr 
 */
void System_Init_Task(void* a_ptr)
{
     2fe:	cf 93       	push	r28
     300:	df 93       	push	r29
     302:	00 d0       	rcall	.+0      	; 0x304 <System_Init_Task+0x6>
     304:	cd b7       	in	r28, 0x3d	; 61
     306:	de b7       	in	r29, 0x3e	; 62
    /* Create Semaphore to sync displaying chars. */
    /* Create Software Timer. */

	/* Init MailBox for Display_Msg_Task. */ 
	display_msg_mail_box = xQueueCreate( 
     308:	40 e0       	ldi	r20, 0x00	; 0
     30a:	62 e0       	ldi	r22, 0x02	; 2
     30c:	81 e0       	ldi	r24, 0x01	; 1
     30e:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <xQueueGenericCreate>
     312:	90 93 a1 01 	sts	0x01A1, r25	; 0x8001a1 <display_msg_mail_box+0x1>
     316:	80 93 a0 01 	sts	0x01A0, r24	; 0x8001a0 <display_msg_mail_box>
        DISPLAY_TASK_MAILBOX_SIZE , 
        sizeof(struct Task_Display*)
    );

    /* Init MailBox For coffee id. */
    g_mailbox_coffee_id = xQueueCreate
     31a:	40 e0       	ldi	r20, 0x00	; 0
     31c:	61 e0       	ldi	r22, 0x01	; 1
     31e:	81 e0       	ldi	r24, 0x01	; 1
     320:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <xQueueGenericCreate>
     324:	90 93 92 01 	sts	0x0192, r25	; 0x800192 <g_mailbox_coffee_id+0x1>
     328:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <g_mailbox_coffee_id>
    (
        COFFEE_ID_MAILBOX_SIZE, 
        sizeof(uint8_t)
    );
    /* Init System. */
	Keypad_Init();
     32c:	ca d3       	rcall	.+1940   	; 0xac2 <Keypad_Init>
	Seven_Segment_Init();
     32e:	cb d6       	rcall	.+3478   	; 0x10c6 <Seven_Segment_Init>
	uint8_t au8_system_init_steps = FALSE;
	while( TRUE )
	{
		LCD_Init();
     330:	a7 d5       	rcall	.+2894   	; 0xe80 <LCD_Init>
     332:	12 ba       	out	0x12, r1	; 18
		au8_system_init_steps++;
        PORTD  = 0x00;
     334:	ff 24       	eor	r15, r15
	Seven_Segment_Init();
	uint8_t au8_system_init_steps = FALSE;
	while( TRUE )
	{
		LCD_Init();
		au8_system_init_steps++;
     336:	f3 94       	inc	r15
     338:	cc 24       	eor	r12, r12
        PORTD  = 0x00;
		if ( au8_system_init_steps >= INIT_STEPS )
		{
            PORTD = 0xff;
     33a:	ca 94       	dec	r12
     33c:	ee 24       	eor	r14, r14
			/* System init successfully. */
			gu8_is_init = TRUE;
     33e:	e3 94       	inc	r14
     340:	68 94       	set
            );
            /* Send MailBox for Task Display to Display Welcome Msg. */
            xQueueSend(display_msg_mail_box, &g_ptr_display_mailbox ,(TickType_t) portMAX_DELAY);

            /* active interrupt related to the coins. */
            INT_CFG_S a_str_interrupt = {INT_2, INT2_RISING_EDGE};
     342:	dd 24       	eor	r13, r13
     344:	d1 f8       	bld	r13, 1
     346:	7c c0       	rjmp	.+248    	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
     348:	c2 ba       	out	0x12, r12	; 18
		LCD_Init();
		au8_system_init_steps++;
        PORTD  = 0x00;
		if ( au8_system_init_steps >= INIT_STEPS )
		{
            PORTD = 0xff;
     34a:	e0 92 84 01 	sts	0x0184, r14	; 0x800184 <gu8_is_init>
			/* System init successfully. */
			gu8_is_init = TRUE;
     34e:	43 e0       	ldi	r20, 0x03	; 3

            /* Create Binary SemaPhore For Synchorization with LCD. */
            sema_display_string = xSemaphoreCreateBinary();
     350:	60 e0       	ldi	r22, 0x00	; 0
     352:	8e 2d       	mov	r24, r14
     354:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <xQueueGenericCreate>
     358:	90 93 9f 01 	sts	0x019F, r25	; 0x80019f <sema_display_string+0x1>
     35c:	80 93 9e 01 	sts	0x019E, r24	; 0x80019e <sema_display_string>
     360:	20 e0       	ldi	r18, 0x00	; 0

            /* Give It By default. */
            xSemaphoreGive(sema_display_string);
     362:	40 e0       	ldi	r20, 0x00	; 0
     364:	50 e0       	ldi	r21, 0x00	; 0
     366:	60 e0       	ldi	r22, 0x00	; 0
     368:	70 e0       	ldi	r23, 0x00	; 0
     36a:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
     36e:	43 e0       	ldi	r20, 0x03	; 3

            /* Create Binary SemaPhore to sync. chars inside LCD. */
            sema_display_char   = xSemaphoreCreateBinary();
     370:	60 e0       	ldi	r22, 0x00	; 0
     372:	8e 2d       	mov	r24, r14
     374:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <xQueueGenericCreate>
     378:	90 93 9d 01 	sts	0x019D, r25	; 0x80019d <sema_display_char+0x1>
     37c:	80 93 9c 01 	sts	0x019C, r24	; 0x80019c <sema_display_char>
     380:	43 e0       	ldi	r20, 0x03	; 3

            /* Create Binary Semaphore to sync. Deliver task. */
            sema_deliver_coffee = xSemaphoreCreateBinary();
     382:	60 e0       	ldi	r22, 0x00	; 0
     384:	8e 2d       	mov	r24, r14
     386:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <xQueueGenericCreate>
     38a:	90 93 86 01 	sts	0x0186, r25	; 0x800186 <sema_deliver_coffee+0x1>
     38e:	80 93 85 01 	sts	0x0185, r24	; 0x800185 <sema_deliver_coffee>
     392:	43 e0       	ldi	r20, 0x03	; 3

            /* Create Binary SemaPhore to sync. refund task. */
            sema_refund_task    = xSemaphoreCreateBinary();
     394:	60 e0       	ldi	r22, 0x00	; 0
     396:	8e 2d       	mov	r24, r14
     398:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <xQueueGenericCreate>
     39c:	90 93 88 01 	sts	0x0188, r25	; 0x800188 <sema_refund_task+0x1>
     3a0:	80 93 87 01 	sts	0x0187, r24	; 0x800187 <sema_refund_task>
     3a4:	43 e0       	ldi	r20, 0x03	; 3
            /* Create Binary semaphore to sync. SW Timer with collect_coins_task. */
            sema_allowable_time_for_insert_coins = xSemaphoreCreateBinary();
     3a6:	60 e0       	ldi	r22, 0x00	; 0
     3a8:	8e 2d       	mov	r24, r14
     3aa:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <xQueueGenericCreate>
     3ae:	90 93 95 01 	sts	0x0195, r25	; 0x800195 <sema_allowable_time_for_insert_coins+0x1>
     3b2:	80 93 94 01 	sts	0x0194, r24	; 0x800194 <sema_allowable_time_for_insert_coins>
     3b6:	8e 2d       	mov	r24, r14
            /* Create Mutex for mailbox => "Display Task." */
            mutex_for_display_mailbox = xSemaphoreCreateMutex();
     3b8:	0e 94 e7 0f 	call	0x1fce	; 0x1fce <xQueueCreateMutex>
     3bc:	90 93 99 01 	sts	0x0199, r25	; 0x800199 <mutex_for_display_mailbox+0x1>
     3c0:	80 93 98 01 	sts	0x0198, r24	; 0x800198 <mutex_for_display_mailbox>
     3c4:	0d e5       	ldi	r16, 0x5D	; 93

            /* Create A software timer to track Chars Inside Specific String. */
            display_characters_timer = xTimerCreate
     3c6:	10 e0       	ldi	r17, 0x00	; 0
     3c8:	20 e0       	ldi	r18, 0x00	; 0
     3ca:	30 e0       	ldi	r19, 0x00	; 0
     3cc:	4e 2d       	mov	r20, r14
     3ce:	62 e0       	ldi	r22, 0x02	; 2
     3d0:	70 e0       	ldi	r23, 0x00	; 0
     3d2:	80 e0       	ldi	r24, 0x00	; 0
     3d4:	90 e0       	ldi	r25, 0x00	; 0
     3d6:	0e 94 58 18 	call	0x30b0	; 0x30b0 <xTimerCreate>
     3da:	90 93 9b 01 	sts	0x019B, r25	; 0x80019b <display_characters_timer+0x1>
     3de:	80 93 9a 01 	sts	0x019A, r24	; 0x80019a <display_characters_timer>
     3e2:	06 e7       	ldi	r16, 0x76	; 118
               pdTRUE, SW_TIMER_DISPLAY_ID, 
               display_Char_CallBack
            );
            
            /* Count Down Software Timer. */
            g_count_down_timer = xTimerCreate
     3e4:	10 e0       	ldi	r17, 0x00	; 0
     3e6:	21 e0       	ldi	r18, 0x01	; 1
     3e8:	30 e0       	ldi	r19, 0x00	; 0
     3ea:	4e 2d       	mov	r20, r14
     3ec:	68 ee       	ldi	r22, 0xE8	; 232
     3ee:	73 e0       	ldi	r23, 0x03	; 3
     3f0:	80 e0       	ldi	r24, 0x00	; 0
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	0e 94 58 18 	call	0x30b0	; 0x30b0 <xTimerCreate>
     3f8:	90 93 97 01 	sts	0x0197, r25	; 0x800197 <g_count_down_timer+0x1>
     3fc:	80 93 96 01 	sts	0x0196, r24	; 0x800196 <g_count_down_timer>
     400:	20 e0       	ldi	r18, 0x00	; 0
                COUNT_DOWN_PERIOD_MS,
                pdTRUE, SW_TIMER_COUNT_DOWN_TIMER_ID,
                take_coins_timer_CallBack
            );
            /* Send MailBox for Task Display to Display Welcome Msg. */
            xQueueSend(display_msg_mail_box, &g_ptr_display_mailbox ,(TickType_t) portMAX_DELAY);
     402:	4f ef       	ldi	r20, 0xFF	; 255
     404:	5f ef       	ldi	r21, 0xFF	; 255
     406:	61 e6       	ldi	r22, 0x61	; 97
     408:	70 e0       	ldi	r23, 0x00	; 0
     40a:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     40e:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     412:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
     416:	d9 82       	std	Y+1, r13	; 0x01

            /* active interrupt related to the coins. */
            INT_CFG_S a_str_interrupt = {INT_2, INT2_RISING_EDGE};
     418:	ea 82       	std	Y+2, r14	; 0x02
     41a:	ce 01       	movw	r24, r28
            INT_Init(&a_str_interrupt); 
     41c:	01 96       	adiw	r24, 0x01	; 1
     41e:	0e 94 ce 0a 	call	0x159c	; 0x159c <INT_Init>
     422:	20 e0       	ldi	r18, 0x00	; 0

            /* Activate Coins Interrupt. */
            /* Make Mutex of mailbox available By Default. */
            xSemaphoreGive(mutex_for_display_mailbox);
     424:	40 e0       	ldi	r20, 0x00	; 0
     426:	50 e0       	ldi	r21, 0x00	; 0
     428:	60 e0       	ldi	r22, 0x00	; 0
     42a:	70 e0       	ldi	r23, 0x00	; 0
     42c:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     430:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     434:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
     438:	80 e0       	ldi	r24, 0x00	; 0
            /* Send this task to DORMANT State. */
			vTaskDelete( NULL );
     43a:	90 e0       	ldi	r25, 0x00	; 0
     43c:	0e 94 3a 13 	call	0x2674	; 0x2674 <vTaskDelete>
     440:	82 e0       	ldi	r24, 0x02	; 2
		}
		vTaskDelay((CHARACTER_PERIOD_MS/portTICK_PERIOD_MS));
     442:	90 e0       	ldi	r25, 0x00	; 0
     444:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>
	Keypad_Init();
	Seven_Segment_Init();
	uint8_t au8_system_init_steps = FALSE;
	while( TRUE )
	{
		LCD_Init();
     448:	1b d5       	rcall	.+2614   	; 0xe80 <LCD_Init>
     44a:	f3 94       	inc	r15
		au8_system_init_steps++;
     44c:	12 ba       	out	0x12, r1	; 18
        PORTD  = 0x00;
     44e:	8a e0       	ldi	r24, 0x0A	; 10
		if ( au8_system_init_steps >= INIT_STEPS )
     450:	8f 15       	cp	r24, r15
     452:	b0 f7       	brcc	.-20     	; 0x440 <__LOCK_REGION_LENGTH__+0x40>
     454:	79 cf       	rjmp	.-270    	; 0x348 <System_Init_Task+0x4a>

00000456 <Collect_Coins_Task>:
     456:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <gu8_is_init>
 * @param a_ptr 
 */
void Collect_Coins_Task( void* a_ptr )
{
    /* Check if the system is Init Successfully or not. */
    if ( FALSE == gu8_is_init )
     45a:	81 11       	cpse	r24, r1
     45c:	04 c0       	rjmp	.+8      	; 0x466 <Collect_Coins_Task+0x10>
    {
        /* Block System for the Init Time. */
        vTaskDelay(200/portTICK_PERIOD_MS);
     45e:	88 ec       	ldi	r24, 0xC8	; 200
     460:	90 e0       	ldi	r25, 0x00	; 0
     462:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>
                /* Suspended this task. */
                /* This Task Resume by Deliver Coffee Task OR Refund_Task Based on 
                Specific logic inside Refund_task. */
                vTaskSuspend(NULL);
            }
            sema_allowable_time_passed = NULL; 
     466:	80 e0       	ldi	r24, 0x00	; 0
                    gu8_collected_coins = FALSE;
                taskEXIT_CRITICAL();
                
                au8_take_mutex_mailbox  = xSemaphoreTake( mutex_for_display_mailbox , (TickType_t)portMAX_DELAY);
                    /* Message To user that he/she did not put coins. */
                    g_mail_box.message_id   = SORRY_MSG_ID;
     468:	03 e6       	ldi	r16, 0x63	; 99
     46a:	10 e0       	ldi	r17, 0x00	; 0
     46c:	c4 e0       	ldi	r28, 0x04	; 4
    }
    uint8_t sema_allowable_time_passed = NULL;
    uint8_t au8_take_mutex_mailbox = NULL, au8_coffee_id = FALSE;
    while ( TRUE )
    {
        if ( NULL != sema_allowable_time_passed )
     46e:	88 23       	and	r24, r24
     470:	09 f4       	brne	.+2      	; 0x474 <Collect_Coins_Task+0x1e>
     472:	5f c0       	rjmp	.+190    	; 0x532 <Collect_Coins_Task+0xdc>
            
            /* Shared Resource With ISR. */
            /* It's more logic to disable source of interrupt only. */
            
            /* No coins Inserted. */
            taskENTER_CRITICAL();
     474:	0f b6       	in	r0, 0x3f	; 63
     476:	f8 94       	cli
     478:	0f 92       	push	r0
                /* take value of collected coins. */
                uint8_t au8_collected_coins = gu8_collected_coins;
            taskEXIT_CRITICAL();
     47a:	0f 90       	pop	r0
     47c:	0f be       	out	0x3f, r0	; 63
            
            if ( (uint8_t)au8_collected_coins <= (uint8_t)FALSE )
     47e:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <gu8_collected_coins>
     482:	81 11       	cpse	r24, r1
     484:	45 c0       	rjmp	.+138    	; 0x510 <Collect_Coins_Task+0xba>
            {
                
                taskENTER_CRITICAL();
     486:	0f b6       	in	r0, 0x3f	; 63
     488:	f8 94       	cli
     48a:	0f 92       	push	r0
                    /* take value of collected coins. */
                    gu8_collected_coins = FALSE;
     48c:	10 92 93 01 	sts	0x0193, r1	; 0x800193 <gu8_collected_coins>
                taskEXIT_CRITICAL();
     490:	0f 90       	pop	r0
     492:	0f be       	out	0x3f, r0	; 63
                
                au8_take_mutex_mailbox  = xSemaphoreTake( mutex_for_display_mailbox , (TickType_t)portMAX_DELAY);
     494:	6f ef       	ldi	r22, 0xFF	; 255
     496:	7f ef       	ldi	r23, 0xFF	; 255
     498:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     49c:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     4a0:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
                    /* Message To user that he/she did not put coins. */
                    g_mail_box.message_id   = SORRY_MSG_ID;
     4a4:	f8 01       	movw	r30, r16
     4a6:	c0 83       	st	Z, r28
                    strcpy(  g_mail_box.message , SORRY_INSUFFICENT_COINS);
     4a8:	86 e1       	ldi	r24, 0x16	; 22
     4aa:	ee eb       	ldi	r30, 0xBE	; 190
     4ac:	f0 e0       	ldi	r31, 0x00	; 0
     4ae:	a4 e6       	ldi	r26, 0x64	; 100
     4b0:	b0 e0       	ldi	r27, 0x00	; 0
     4b2:	01 90       	ld	r0, Z+
     4b4:	0d 92       	st	X+, r0
     4b6:	8a 95       	dec	r24
     4b8:	e1 f7       	brne	.-8      	; 0x4b2 <Collect_Coins_Task+0x5c>
                    
                    xQueueSend(display_msg_mail_box, &g_ptr_display_mailbox, (TickType_t)0);
     4ba:	20 e0       	ldi	r18, 0x00	; 0
     4bc:	40 e0       	ldi	r20, 0x00	; 0
     4be:	50 e0       	ldi	r21, 0x00	; 0
     4c0:	61 e6       	ldi	r22, 0x61	; 97
     4c2:	70 e0       	ldi	r23, 0x00	; 0
     4c4:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     4c8:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     4cc:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                
                    /* Wait for 5 Seconds. */
                    vTaskDelay((COUNT_DOWN_PERIOD_MS * (COUNT_DOWN_IN_SEC + 1))/portTICK_PERIOD_MS);
     4d0:	80 e7       	ldi	r24, 0x70	; 112
     4d2:	97 e1       	ldi	r25, 0x17	; 23
     4d4:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>
                    
                    /* Should Return Back To Idle State. */
                    /* Send another mailbox of idle state. */
                    send_default_page();
     4d8:	55 de       	rcall	.-854    	; 0x184 <send_default_page>
                    /* Naive Solution. */
                    /* TODO: Solve the problem Semaphore releasing twice by 
                    two condition inside switch case in Display Task. */
                    xSemaphoreTake(sema_allowable_time_for_insert_coins, (TickType_t)portMAX_DELAY);
     4da:	6f ef       	ldi	r22, 0xFF	; 255
     4dc:	7f ef       	ldi	r23, 0xFF	; 255
     4de:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <sema_allowable_time_for_insert_coins>
     4e2:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <sema_allowable_time_for_insert_coins+0x1>
     4e6:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
                xSemaphoreGive( mutex_for_display_mailbox );
     4ea:	20 e0       	ldi	r18, 0x00	; 0
     4ec:	40 e0       	ldi	r20, 0x00	; 0
     4ee:	50 e0       	ldi	r21, 0x00	; 0
     4f0:	60 e0       	ldi	r22, 0x00	; 0
     4f2:	70 e0       	ldi	r23, 0x00	; 0
     4f4:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     4f8:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     4fc:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                /* Resume read cmd task. */
                vTaskResume( gu8_read_cmd_handle );
     500:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <gu8_read_cmd_handle>
     504:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <gu8_read_cmd_handle+0x1>
     508:	0e 94 88 13 	call	0x2710	; 0x2710 <vTaskResume>
                /* Suspended this task. */
                /* This Task Resume by Deliver Coffee Task OR Refund_Task Based on 
                Specific logic inside Refund_task. */
                vTaskSuspend(NULL);
            }
            sema_allowable_time_passed = NULL; 
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	af cf       	rjmp	.-162    	; 0x46e <Collect_Coins_Task+0x18>
            }
            else
            {
                /* Coins inserted. */ 
                sema_allowable_time_passed = NULL; 
                xSemaphoreGive( sema_refund_task );
     510:	20 e0       	ldi	r18, 0x00	; 0
     512:	40 e0       	ldi	r20, 0x00	; 0
     514:	50 e0       	ldi	r21, 0x00	; 0
     516:	60 e0       	ldi	r22, 0x00	; 0
     518:	70 e0       	ldi	r23, 0x00	; 0
     51a:	80 91 87 01 	lds	r24, 0x0187	; 0x800187 <sema_refund_task>
     51e:	90 91 88 01 	lds	r25, 0x0188	; 0x800188 <sema_refund_task+0x1>
     522:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                /* Suspended this task. */
                /* This Task Resume by Deliver Coffee Task OR Refund_Task Based on 
                Specific logic inside Refund_task. */
                vTaskSuspend(NULL);
     526:	80 e0       	ldi	r24, 0x00	; 0
     528:	90 e0       	ldi	r25, 0x00	; 0
     52a:	0e 94 b9 15 	call	0x2b72	; 0x2b72 <vTaskSuspend>
            }
            sema_allowable_time_passed = NULL; 
     52e:	80 e0       	ldi	r24, 0x00	; 0
     530:	9e cf       	rjmp	.-196    	; 0x46e <Collect_Coins_Task+0x18>
        }
        else
        {
            /* Check if allowable time was posted. */
            sema_allowable_time_passed = xSemaphoreTake(sema_allowable_time_for_insert_coins, (TickType_t)portMAX_DELAY);
     532:	6f ef       	ldi	r22, 0xFF	; 255
     534:	7f ef       	ldi	r23, 0xFF	; 255
     536:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <sema_allowable_time_for_insert_coins>
     53a:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <sema_allowable_time_for_insert_coins+0x1>
     53e:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
     542:	95 cf       	rjmp	.-214    	; 0x46e <Collect_Coins_Task+0x18>

00000544 <Read_Cmd_Task>:
 * @brief This Task Responseable to take cmds from user via Keypad.
 * @priority 4 => Second Priority in the system.
 * @param a_ptr 
 */
void Read_Cmd_Task( void* a_ptr )
{
     544:	cf 93       	push	r28
     546:	df 93       	push	r29
     548:	00 d0       	rcall	.+0      	; 0x54a <Read_Cmd_Task+0x6>
     54a:	1f 92       	push	r1
     54c:	cd b7       	in	r28, 0x3d	; 61
     54e:	de b7       	in	r29, 0x3e	; 62

    /* Block This Task Until System init task finish. */
    if ( FALSE == gu8_is_init )
     550:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <gu8_is_init>
     554:	81 11       	cpse	r24, r1
     556:	04 c0       	rjmp	.+8      	; 0x560 <Read_Cmd_Task+0x1c>
    {
        vTaskDelay(200/portTICK_PERIOD_MS);
     558:	88 ec       	ldi	r24, 0xC8	; 200
     55a:	90 e0       	ldi	r25, 0x00	; 0
     55c:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>

       * admin state   => Which owner entered magic CMD.
       * Collect Money => Normal User choosed specific coffee product.
     */
    uint8_t au8_key_pressed = FALSE ,au8_keypad_status = FALSE;
    uint8_t au8_row = FALSE, au8_col = FALSE, au8_stage = FALSE,
     560:	19 82       	std	Y+1, r1	; 0x01
     562:	1a 82       	std	Y+2, r1	; 0x02
    au8_take_mutex_mailbox = NULL;

    /* Coffee_ID Choosen by User.  */
    uint8_t au8_coffee_id  = FALSE;
     564:	1b 82       	std	Y+3, r1	; 0x03

       * admin state   => Which owner entered magic CMD.
       * Collect Money => Normal User choosed specific coffee product.
     */
    uint8_t au8_key_pressed = FALSE ,au8_keypad_status = FALSE;
    uint8_t au8_row = FALSE, au8_col = FALSE, au8_stage = FALSE,
     566:	d1 2c       	mov	r13, r1

                        /* Mutex Available Write Your message Safely. */
                        au8_coffee_id = au8_key_pressed - 0x30;

                        /* Insert Coins Page. */
                        g_mail_box.message_id = INSERT_COINS_MESSAGE_ID;
     568:	0f 2e       	mov	r0, r31
     56a:	f3 e6       	ldi	r31, 0x63	; 99
     56c:	af 2e       	mov	r10, r31
     56e:	f0 e0       	ldi	r31, 0x00	; 0
     570:	bf 2e       	mov	r11, r31
     572:	f0 2d       	mov	r31, r0
     574:	0f 2e       	mov	r0, r31
     576:	f3 e0       	ldi	r31, 0x03	; 3
     578:	ef 2e       	mov	r14, r31
     57a:	f0 2d       	mov	r31, r0
        /* Check If user Pressed A Button. */
        Keypad_Get_Key(&au8_row, &au8_col);
        if (FALSE == au8_stage && NOKEY != au8_row && NOKEY != au8_col)
        {
            /* First Sample Taken. */
            au8_stage++;
     57c:	ff 24       	eor	r15, r15
     57e:	f3 94       	inc	r15
    uint8_t au8_coffee_id  = FALSE;

    while ( TRUE )
    {
        /* Check If user Pressed A Button. */
        Keypad_Get_Key(&au8_row, &au8_col);
     580:	be 01       	movw	r22, r28
     582:	6e 5f       	subi	r22, 0xFE	; 254
     584:	7f 4f       	sbci	r23, 0xFF	; 255
     586:	ce 01       	movw	r24, r28
     588:	01 96       	adiw	r24, 0x01	; 1
     58a:	c9 d2       	rcall	.+1426   	; 0xb1e <Keypad_Get_Key>
        if (FALSE == au8_stage && NOKEY != au8_row && NOKEY != au8_col)
     58c:	d1 10       	cpse	r13, r1
     58e:	08 c0       	rjmp	.+16     	; 0x5a0 <Read_Cmd_Task+0x5c>
     590:	89 81       	ldd	r24, Y+1	; 0x01
     592:	88 23       	and	r24, r24
     594:	09 f4       	brne	.+2      	; 0x598 <Read_Cmd_Task+0x54>
     596:	5f c0       	rjmp	.+190    	; 0x656 <Read_Cmd_Task+0x112>
     598:	8a 81       	ldd	r24, Y+2	; 0x02
     59a:	81 11       	cpse	r24, r1
     59c:	5f c0       	rjmp	.+190    	; 0x65c <Read_Cmd_Task+0x118>
     59e:	5b c0       	rjmp	.+182    	; 0x656 <Read_Cmd_Task+0x112>
            au8_stage++;
        }
        else
        {
            /* Check if Second Sample of button the same as the first. */
            if ( NOKEY != au8_row && NOKEY != au8_col )
     5a0:	89 81       	ldd	r24, Y+1	; 0x01
     5a2:	88 23       	and	r24, r24
     5a4:	09 f4       	brne	.+2      	; 0x5a8 <Read_Cmd_Task+0x64>
     5a6:	57 c0       	rjmp	.+174    	; 0x656 <Read_Cmd_Task+0x112>
     5a8:	2a 81       	ldd	r18, Y+2	; 0x02
     5aa:	22 23       	and	r18, r18
     5ac:	09 f4       	brne	.+2      	; 0x5b0 <Read_Cmd_Task+0x6c>
     5ae:	53 c0       	rjmp	.+166    	; 0x656 <Read_Cmd_Task+0x112>
            {
                if ( NULL == au8_take_mutex_mailbox  )
                {
                    /* User Pressed A key. */
                    au8_key_pressed = gu8_keypad_buttons_interface[au8_row - 1][au8_col - 1];
     5b0:	90 e0       	ldi	r25, 0x00	; 0
     5b2:	01 97       	sbiw	r24, 0x01	; 1
     5b4:	fc 01       	movw	r30, r24
     5b6:	ee 0f       	add	r30, r30
     5b8:	ff 1f       	adc	r31, r31
     5ba:	e8 0f       	add	r30, r24
     5bc:	f9 1f       	adc	r31, r25
     5be:	e0 56       	subi	r30, 0x60	; 96
     5c0:	ff 4f       	sbci	r31, 0xFF	; 255
     5c2:	e2 0f       	add	r30, r18
     5c4:	f1 1d       	adc	r31, r1
     5c6:	31 97       	sbiw	r30, 0x01	; 1
                    
                    /* Check If input is vailed. */
                    if ( TRUE == is_vailed_input(au8_key_pressed - 0x30) )
     5c8:	80 81       	ld	r24, Z
     5ca:	10 ed       	ldi	r17, 0xD0	; 208
     5cc:	18 0f       	add	r17, r24
     5ce:	14 30       	cpi	r17, 0x04	; 4
     5d0:	08 f0       	brcs	.+2      	; 0x5d4 <Read_Cmd_Task+0x90>
     5d2:	41 c0       	rjmp	.+130    	; 0x656 <Read_Cmd_Task+0x112>
                    {
                        /* Mutex for display task not Available try to take it.  */
                        au8_take_mutex_mailbox = xSemaphoreTake(mutex_for_display_mailbox, (TickType_t)portMAX_DELAY);
     5d4:	6f ef       	ldi	r22, 0xFF	; 255
     5d6:	7f ef       	ldi	r23, 0xFF	; 255
     5d8:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     5dc:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     5e0:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>

                        /* Mutex Available Write Your message Safely. */
                        au8_coffee_id = au8_key_pressed - 0x30;
     5e4:	1b 83       	std	Y+3, r17	; 0x03

                        /* Insert Coins Page. */
                        g_mail_box.message_id = INSERT_COINS_MESSAGE_ID;
     5e6:	f5 01       	movw	r30, r10
     5e8:	e0 82       	st	Z, r14
                        strcpy( g_mail_box.message, INSERT_COIN_MSG );
     5ea:	8e e0       	ldi	r24, 0x0E	; 14
     5ec:	e4 ed       	ldi	r30, 0xD4	; 212
     5ee:	f0 e0       	ldi	r31, 0x00	; 0
     5f0:	a4 e6       	ldi	r26, 0x64	; 100
     5f2:	b0 e0       	ldi	r27, 0x00	; 0
     5f4:	01 90       	ld	r0, Z+
     5f6:	0d 92       	st	X+, r0
     5f8:	8a 95       	dec	r24
     5fa:	e1 f7       	brne	.-8      	; 0x5f4 <Read_Cmd_Task+0xb0>
                        /* Reset Queue. */
                        xQueueReset(g_mailbox_coffee_id);
     5fc:	60 e0       	ldi	r22, 0x00	; 0
     5fe:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <g_mailbox_coffee_id>
     602:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <g_mailbox_coffee_id+0x1>
     606:	0e 94 e9 0e 	call	0x1dd2	; 0x1dd2 <xQueueGenericReset>
                        /* Send mailbox to Task => collect money with => gu8_coffee_id */
                        xQueueSend(g_mailbox_coffee_id, &au8_coffee_id, (TickType_t)portMAX_DELAY);
     60a:	20 e0       	ldi	r18, 0x00	; 0
     60c:	4f ef       	ldi	r20, 0xFF	; 255
     60e:	5f ef       	ldi	r21, 0xFF	; 255
     610:	be 01       	movw	r22, r28
     612:	6d 5f       	subi	r22, 0xFD	; 253
     614:	7f 4f       	sbci	r23, 0xFF	; 255
     616:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <g_mailbox_coffee_id>
     61a:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <g_mailbox_coffee_id+0x1>
     61e:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                        
                        xQueueSend(display_msg_mail_box, &g_ptr_display_mailbox, (TickType_t)portMAX_DELAY);
     622:	20 e0       	ldi	r18, 0x00	; 0
     624:	4f ef       	ldi	r20, 0xFF	; 255
     626:	5f ef       	ldi	r21, 0xFF	; 255
     628:	61 e6       	ldi	r22, 0x61	; 97
     62a:	70 e0       	ldi	r23, 0x00	; 0
     62c:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     630:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     634:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                        
                        /* Give Mutex Back. */
                        xSemaphoreGive(mutex_for_display_mailbox);
     638:	20 e0       	ldi	r18, 0x00	; 0
     63a:	40 e0       	ldi	r20, 0x00	; 0
     63c:	50 e0       	ldi	r21, 0x00	; 0
     63e:	60 e0       	ldi	r22, 0x00	; 0
     640:	70 e0       	ldi	r23, 0x00	; 0
     642:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     646:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     64a:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                        /* Suspend this task. */
                        vTaskSuspend(NULL);
     64e:	80 e0       	ldi	r24, 0x00	; 0
     650:	90 e0       	ldi	r25, 0x00	; 0
     652:	0e 94 b9 15 	call	0x2b72	; 0x2b72 <vTaskSuspend>
            else
            {
                /* NOP. */
            }
            au8_stage = FALSE;
            au8_coffee_id = FALSE;            
     656:	1b 82       	std	Y+3, r1	; 0x03
            }
            else
            {
                /* NOP. */
            }
            au8_stage = FALSE;
     658:	d1 2c       	mov	r13, r1
     65a:	01 c0       	rjmp	.+2      	; 0x65e <Read_Cmd_Task+0x11a>
        /* Check If user Pressed A Button. */
        Keypad_Get_Key(&au8_row, &au8_col);
        if (FALSE == au8_stage && NOKEY != au8_row && NOKEY != au8_col)
        {
            /* First Sample Taken. */
            au8_stage++;
     65c:	df 2c       	mov	r13, r15
            }
            au8_stage = FALSE;
            au8_coffee_id = FALSE;            
        }
        /* Resolving Bounce Problem by take two sample of Key pressed each sample after 50 ms. */
        vTaskDelay(DEBOUNCING_DELAY_IN_MS/portTICK_PERIOD_MS);
     65e:	82 e3       	ldi	r24, 0x32	; 50
     660:	90 e0       	ldi	r25, 0x00	; 0
     662:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>
    }
     666:	8c cf       	rjmp	.-232    	; 0x580 <Read_Cmd_Task+0x3c>

00000668 <Give_Refund_Task>:
    * if the user put coins > cofee price so the machine should return the differnce between it.
 * @priority 3 => Third Priority in the system.
 * @param a_ptr
 */
void Give_Refund_Task( void* a_ptr )
{
     668:	cf 93       	push	r28
     66a:	df 93       	push	r29
     66c:	1f 92       	push	r1
     66e:	cd b7       	in	r28, 0x3d	; 61
     670:	de b7       	in	r29, 0x3e	; 62
    /* Block This Task Until System init task finish. */
    if ( FALSE == gu8_is_init )
     672:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <gu8_is_init>
     676:	81 11       	cpse	r24, r1
     678:	04 c0       	rjmp	.+8      	; 0x682 <Give_Refund_Task+0x1a>
    {
        vTaskDelay(200/portTICK_PERIOD_MS);
     67a:	88 ec       	ldi	r24, 0xC8	; 200
     67c:	90 e0       	ldi	r25, 0x00	; 0
     67e:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>
    {
        /* NOP. */
    }
    /* Check if there's a coins inserted. */
    uint8_t sema_coins_inserted = NULL, 
    au8_coffee_id = NULL, au8_inserted_coins = NULL, 
     682:	19 82       	std	Y+1, r1	; 0x01
    else
    {
        /* NOP. */
    }
    /* Check if there's a coins inserted. */
    uint8_t sema_coins_inserted = NULL, 
     684:	10 e0       	ldi	r17, 0x00	; 0
                     
                        au8_take_mutex_mailbox = xSemaphoreTake(mutex_for_display_mailbox, (TickType_t)portMAX_DELAY);
                            
                            Seven_Segment_Write( au8_inserted_coins - gstr_products[au8_coffee_id - 1].coffee_price );
                            
                            g_mail_box.message_id =  TAKE_REFUND_MSG_ID;
     686:	0f 2e       	mov	r0, r31
     688:	f3 e6       	ldi	r31, 0x63	; 99
     68a:	ef 2e       	mov	r14, r31
     68c:	f0 e0       	ldi	r31, 0x00	; 0
     68e:	ff 2e       	mov	r15, r31
     690:	f0 2d       	mov	r31, r0
     692:	05 e0       	ldi	r16, 0x05	; 5
     694:	01 c0       	rjmp	.+2      	; 0x698 <Give_Refund_Task+0x30>
                    }
                    /* reset coins (7 Segment.) */
                    Seven_Segment_Write( FALSE );
                }
            }            
            sema_coins_inserted = NULL;
     696:	10 e0       	ldi	r17, 0x00	; 0
    while( TRUE )
    {
        /* Read Coffee choosen id from mailbox. */

        /* check if user insert coins. */
        if ( NULL != sema_coins_inserted )
     698:	11 23       	and	r17, r17
     69a:	09 f4       	brne	.+2      	; 0x69e <Give_Refund_Task+0x36>
     69c:	c1 c0       	rjmp	.+386    	; 0x820 <Give_Refund_Task+0x1b8>
        {

            if ( au8_coffee_id != NULL )
     69e:	89 81       	ldd	r24, Y+1	; 0x01
     6a0:	88 23       	and	r24, r24
     6a2:	c9 f3       	breq	.-14     	; 0x696 <Give_Refund_Task+0x2e>
            {
                taskENTER_CRITICAL();
     6a4:	0f b6       	in	r0, 0x3f	; 63
     6a6:	f8 94       	cli
     6a8:	0f 92       	push	r0
                    au8_inserted_coins  = gu8_collected_coins;
     6aa:	10 91 93 01 	lds	r17, 0x0193	; 0x800193 <gu8_collected_coins>
                    gu8_collected_coins = FALSE; 
     6ae:	10 92 93 01 	sts	0x0193, r1	; 0x800193 <gu8_collected_coins>
                taskEXIT_CRITICAL();
     6b2:	0f 90       	pop	r0
     6b4:	0f be       	out	0x3f, r0	; 63

                /* Suspend Collect Coins. */
                vTaskSuspend( gu8_collect_coins_handle );
     6b6:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <gu8_collect_coins_handle>
     6ba:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <gu8_collect_coins_handle+0x1>
     6be:	0e 94 b9 15 	call	0x2b72	; 0x2b72 <vTaskSuspend>
                /* Suspend read cmd task. */
                vTaskSuspend( gu8_read_cmd_handle );
     6c2:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <gu8_read_cmd_handle>
     6c6:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <gu8_read_cmd_handle+0x1>
     6ca:	0e 94 b9 15 	call	0x2b72	; 0x2b72 <vTaskSuspend>

                if ( au8_inserted_coins < gstr_products[au8_coffee_id - 1].coffee_price )
     6ce:	e9 81       	ldd	r30, Y+1	; 0x01
     6d0:	f0 e0       	ldi	r31, 0x00	; 0
     6d2:	ee 0f       	add	r30, r30
     6d4:	ff 1f       	adc	r31, r31
     6d6:	ee 0f       	add	r30, r30
     6d8:	ff 1f       	adc	r31, r31
     6da:	e6 5d       	subi	r30, 0xD6	; 214
     6dc:	fe 4f       	sbci	r31, 0xFE	; 254
     6de:	81 81       	ldd	r24, Z+1	; 0x01
     6e0:	18 17       	cp	r17, r24
     6e2:	08 f0       	brcs	.+2      	; 0x6e6 <Give_Refund_Task+0x7e>
     6e4:	46 c0       	rjmp	.+140    	; 0x772 <Give_Refund_Task+0x10a>
                {
                    /* if coins < product price */
                        /* Refund Coins. */
                        /* Message to user to take his/her refund. */
                        /* Transfer to IDLE State. */
                    Seven_Segment_Write( au8_inserted_coins );    
     6e6:	81 2f       	mov	r24, r17
     6e8:	f1 d4       	rcall	.+2530   	; 0x10cc <Seven_Segment_Write>
                    /* Mutex for display task not Available try to take it.  */
                    au8_take_mutex_mailbox = xSemaphoreTake(mutex_for_display_mailbox, (TickType_t)portMAX_DELAY); 
     6ea:	6f ef       	ldi	r22, 0xFF	; 255
     6ec:	7f ef       	ldi	r23, 0xFF	; 255
     6ee:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     6f2:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     6f6:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
                    
                        g_mail_box.message_id =  TAKE_REFUND_MSG_ID;
     6fa:	f7 01       	movw	r30, r14
     6fc:	00 83       	st	Z, r16
                        strcpy(g_mail_box.message, TAKE_YOUR_COINS);
     6fe:	87 e0       	ldi	r24, 0x07	; 7
     700:	e2 ee       	ldi	r30, 0xE2	; 226
     702:	f0 e0       	ldi	r31, 0x00	; 0
     704:	a4 e6       	ldi	r26, 0x64	; 100
     706:	b0 e0       	ldi	r27, 0x00	; 0
     708:	01 90       	ld	r0, Z+
     70a:	0d 92       	st	X+, r0
     70c:	8a 95       	dec	r24
     70e:	e1 f7       	brne	.-8      	; 0x708 <Give_Refund_Task+0xa0>
                    
                        xQueueSend(display_msg_mail_box, &g_ptr_display_mailbox , (TickType_t)portMAX_DELAY);
     710:	20 e0       	ldi	r18, 0x00	; 0
     712:	4f ef       	ldi	r20, 0xFF	; 255
     714:	5f ef       	ldi	r21, 0xFF	; 255
     716:	61 e6       	ldi	r22, 0x61	; 97
     718:	70 e0       	ldi	r23, 0x00	; 0
     71a:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     71e:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     722:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                        /* Naive Solution. */
                        
                        /* Block This Task. */
                        vTaskDelay((COUNT_DOWN_PERIOD_MS * (COUNT_DOWN_IN_SEC + 1))/portTICK_PERIOD_MS); 
     726:	80 e7       	ldi	r24, 0x70	; 112
     728:	97 e1       	ldi	r25, 0x17	; 23
     72a:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>

                        send_default_page();
     72e:	2a dd       	rcall	.-1452   	; 0x184 <send_default_page>
                        /* TODO: Solve the problem Semaphore releasing twice by 
                        two condition inside switch case in Display Task. */
                        xSemaphoreTake(sema_allowable_time_for_insert_coins, (TickType_t)portMAX_DELAY);
     730:	6f ef       	ldi	r22, 0xFF	; 255
     732:	7f ef       	ldi	r23, 0xFF	; 255
     734:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <sema_allowable_time_for_insert_coins>
     738:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <sema_allowable_time_for_insert_coins+0x1>
     73c:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>

                    xSemaphoreGive(mutex_for_display_mailbox);
     740:	20 e0       	ldi	r18, 0x00	; 0
     742:	40 e0       	ldi	r20, 0x00	; 0
     744:	50 e0       	ldi	r21, 0x00	; 0
     746:	60 e0       	ldi	r22, 0x00	; 0
     748:	70 e0       	ldi	r23, 0x00	; 0
     74a:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     74e:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     752:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>

                    /* Resume Collect Coins. */
                    vTaskResume( gu8_collect_coins_handle );
     756:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <gu8_collect_coins_handle>
     75a:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <gu8_collect_coins_handle+0x1>
     75e:	0e 94 88 13 	call	0x2710	; 0x2710 <vTaskResume>
                    /* Resume read cmd task. */
                    vTaskResume( gu8_read_cmd_handle );
     762:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <gu8_read_cmd_handle>
     766:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <gu8_read_cmd_handle+0x1>
     76a:	0e 94 88 13 	call	0x2710	; 0x2710 <vTaskResume>
                    }
                    /* reset coins (7 Segment.) */
                    Seven_Segment_Write( FALSE );
                }
            }            
            sema_coins_inserted = NULL;
     76e:	10 e0       	ldi	r17, 0x00	; 0
     770:	93 cf       	rjmp	.-218    	; 0x698 <Give_Refund_Task+0x30>
                    /* Resume read cmd task. */
                    vTaskResume( gu8_read_cmd_handle );
                }
                else
                {
                    if (( au8_inserted_coins > gstr_products[au8_coffee_id - 1].coffee_price ))
     772:	81 17       	cp	r24, r17
     774:	08 f0       	brcs	.+2      	; 0x778 <Give_Refund_Task+0x110>
     776:	45 c0       	rjmp	.+138    	; 0x802 <Give_Refund_Task+0x19a>
                        /* Send Mailbox for Display Task to inform user that coffee is preparing. */
                            /* if coins > product price */
                            /* give refund. */
                            /* transfer to Deliver coffee task. */
                     
                        au8_take_mutex_mailbox = xSemaphoreTake(mutex_for_display_mailbox, (TickType_t)portMAX_DELAY);
     778:	6f ef       	ldi	r22, 0xFF	; 255
     77a:	7f ef       	ldi	r23, 0xFF	; 255
     77c:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     780:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     784:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
                            
                            Seven_Segment_Write( au8_inserted_coins - gstr_products[au8_coffee_id - 1].coffee_price );
     788:	e9 81       	ldd	r30, Y+1	; 0x01
     78a:	f0 e0       	ldi	r31, 0x00	; 0
     78c:	ee 0f       	add	r30, r30
     78e:	ff 1f       	adc	r31, r31
     790:	ee 0f       	add	r30, r30
     792:	ff 1f       	adc	r31, r31
     794:	e6 5d       	subi	r30, 0xD6	; 214
     796:	fe 4f       	sbci	r31, 0xFE	; 254
     798:	81 81       	ldd	r24, Z+1	; 0x01
     79a:	18 1b       	sub	r17, r24
     79c:	81 2f       	mov	r24, r17
     79e:	96 d4       	rcall	.+2348   	; 0x10cc <Seven_Segment_Write>
                            
                            g_mail_box.message_id =  TAKE_REFUND_MSG_ID;
     7a0:	f7 01       	movw	r30, r14
     7a2:	00 83       	st	Z, r16
                            strcpy(g_mail_box.message, TAKE_YOUR_COINS);
     7a4:	87 e0       	ldi	r24, 0x07	; 7
     7a6:	e2 ee       	ldi	r30, 0xE2	; 226
     7a8:	f0 e0       	ldi	r31, 0x00	; 0
     7aa:	a4 e6       	ldi	r26, 0x64	; 100
     7ac:	b0 e0       	ldi	r27, 0x00	; 0
     7ae:	01 90       	ld	r0, Z+
     7b0:	0d 92       	st	X+, r0
     7b2:	8a 95       	dec	r24
     7b4:	e1 f7       	brne	.-8      	; 0x7ae <Give_Refund_Task+0x146>
                            
                            xQueueSend(display_msg_mail_box, &g_ptr_display_mailbox , (TickType_t)portMAX_DELAY);
     7b6:	20 e0       	ldi	r18, 0x00	; 0
     7b8:	4f ef       	ldi	r20, 0xFF	; 255
     7ba:	5f ef       	ldi	r21, 0xFF	; 255
     7bc:	61 e6       	ldi	r22, 0x61	; 97
     7be:	70 e0       	ldi	r23, 0x00	; 0
     7c0:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     7c4:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     7c8:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                            /* Block This Task. */
                            vTaskDelay((COUNT_DOWN_PERIOD_MS * COUNT_DOWN_IN_SEC)/portTICK_PERIOD_MS); 
     7cc:	88 e8       	ldi	r24, 0x88	; 136
     7ce:	93 e1       	ldi	r25, 0x13	; 19
     7d0:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>

                            /* Sync. with Deliver coffee task. */
                            xSemaphoreGive( sema_deliver_coffee );
     7d4:	20 e0       	ldi	r18, 0x00	; 0
     7d6:	40 e0       	ldi	r20, 0x00	; 0
     7d8:	50 e0       	ldi	r21, 0x00	; 0
     7da:	60 e0       	ldi	r22, 0x00	; 0
     7dc:	70 e0       	ldi	r23, 0x00	; 0
     7de:	80 91 85 01 	lds	r24, 0x0185	; 0x800185 <sema_deliver_coffee>
     7e2:	90 91 86 01 	lds	r25, 0x0186	; 0x800186 <sema_deliver_coffee+0x1>
     7e6:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                        xSemaphoreGive(mutex_for_display_mailbox);
     7ea:	20 e0       	ldi	r18, 0x00	; 0
     7ec:	40 e0       	ldi	r20, 0x00	; 0
     7ee:	50 e0       	ldi	r21, 0x00	; 0
     7f0:	60 e0       	ldi	r22, 0x00	; 0
     7f2:	70 e0       	ldi	r23, 0x00	; 0
     7f4:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     7f8:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     7fc:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
     800:	0b c0       	rjmp	.+22     	; 0x818 <Give_Refund_Task+0x1b0>
                    {
                        /**
                         * Coins == price.
                         * Sync. with semaphore with Deliver coffee task.
                         */
                        xSemaphoreGive( sema_deliver_coffee );
     802:	20 e0       	ldi	r18, 0x00	; 0
     804:	40 e0       	ldi	r20, 0x00	; 0
     806:	50 e0       	ldi	r21, 0x00	; 0
     808:	60 e0       	ldi	r22, 0x00	; 0
     80a:	70 e0       	ldi	r23, 0x00	; 0
     80c:	80 91 85 01 	lds	r24, 0x0185	; 0x800185 <sema_deliver_coffee>
     810:	90 91 86 01 	lds	r25, 0x0186	; 0x800186 <sema_deliver_coffee+0x1>
     814:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
                    }
                    /* reset coins (7 Segment.) */
                    Seven_Segment_Write( FALSE );
     818:	80 e0       	ldi	r24, 0x00	; 0
     81a:	58 d4       	rcall	.+2224   	; 0x10cc <Seven_Segment_Write>
                }
            }            
            sema_coins_inserted = NULL;
     81c:	10 e0       	ldi	r17, 0x00	; 0
     81e:	3c cf       	rjmp	.-392    	; 0x698 <Give_Refund_Task+0x30>
        }
        else
        {
            au8_coffee_id = NULL;
     820:	19 82       	std	Y+1, r1	; 0x01
            /* Waiting notication from collect coins. */
            sema_coins_inserted = xSemaphoreTake(sema_refund_task, (TickType_t)portMAX_DELAY);
     822:	6f ef       	ldi	r22, 0xFF	; 255
     824:	7f ef       	ldi	r23, 0xFF	; 255
     826:	80 91 87 01 	lds	r24, 0x0187	; 0x800187 <sema_refund_task>
     82a:	90 91 88 01 	lds	r25, 0x0188	; 0x800188 <sema_refund_task+0x1>
     82e:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
     832:	18 2f       	mov	r17, r24
            xQueueReceive( g_mailbox_coffee_id, &au8_coffee_id, (TickType_t)portMAX_DELAY );
     834:	4f ef       	ldi	r20, 0xFF	; 255
     836:	5f ef       	ldi	r21, 0xFF	; 255
     838:	be 01       	movw	r22, r28
     83a:	6f 5f       	subi	r22, 0xFF	; 255
     83c:	7f 4f       	sbci	r23, 0xFF	; 255
     83e:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <g_mailbox_coffee_id>
     842:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <g_mailbox_coffee_id+0x1>
     846:	0e 94 37 10 	call	0x206e	; 0x206e <xQueueReceive>
     84a:	26 cf       	rjmp	.-436    	; 0x698 <Give_Refund_Task+0x30>

0000084c <Deliver_Coffee_Task>:
 * @param a_ptr 
 */
void Deliver_Coffee_Task( void* a_ptr )
{
    /* Block This Task Until System init task finish. */
    if ( FALSE == gu8_is_init )
     84c:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <gu8_is_init>
     850:	81 11       	cpse	r24, r1
     852:	04 c0       	rjmp	.+8      	; 0x85c <Deliver_Coffee_Task+0x10>
    {
        vTaskDelay(200/portTICK_PERIOD_MS);
     854:	88 ec       	ldi	r24, 0xC8	; 200
     856:	90 e0       	ldi	r25, 0x00	; 0
     858:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>
            /* Resume read cmd task. */
            vTaskResume( gu8_read_cmd_handle );

            vTaskResume( gu8_give_refund );
            /* reset the flag. */
            deliver_coffee = NULL;
     85c:	80 e0       	ldi	r24, 0x00	; 0
            /* TODO: mechanical System Should works here. */
            
            /* Transfer this task to waiting state. */
            vTaskDelay(( COUNT_DOWN_IN_SEC * COUNT_DOWN_PERIOD_MS)/portTICK_PERIOD_MS); 
    
            g_mail_box.message_id = PREPARING_COFFEE_ID;
     85e:	c3 e6       	ldi	r28, 0x63	; 99
     860:	d0 e0       	ldi	r29, 0x00	; 0
     862:	06 e0       	ldi	r16, 0x06	; 6
            
            /* Transfer this task to waiting state. */
            vTaskDelay(( COUNT_DOWN_IN_SEC * COUNT_DOWN_PERIOD_MS)/portTICK_PERIOD_MS); 

            /* Send Thank you Message. */
            g_mail_box.message_id = THANK_YOU_MSG_ID;
     864:	17 e0       	ldi	r17, 0x07	; 7
    uint8_t au8_take_mutex_mailbox = NULL;

    while( TRUE )
    {
        /* check if a notification signal comes correctly from refund task. */
        if ( NULL != deliver_coffee )
     866:	88 23       	and	r24, r24
     868:	09 f4       	brne	.+2      	; 0x86c <__stack+0xd>
     86a:	7a c0       	rjmp	.+244    	; 0x960 <__stack+0x101>
        {
            Seven_Segment_Write( FALSE );
     86c:	80 e0       	ldi	r24, 0x00	; 0
     86e:	2e d4       	rcall	.+2140   	; 0x10cc <Seven_Segment_Write>

             /* Suspend Collect Coins. */
            vTaskSuspend( gu8_collect_coins_handle );
     870:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <gu8_collect_coins_handle>
     874:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <gu8_collect_coins_handle+0x1>
     878:	0e 94 b9 15 	call	0x2b72	; 0x2b72 <vTaskSuspend>
            /* Suspend read cmd task. */
            vTaskSuspend( gu8_read_cmd_handle );
     87c:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <gu8_read_cmd_handle>
     880:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <gu8_read_cmd_handle+0x1>
     884:	0e 94 b9 15 	call	0x2b72	; 0x2b72 <vTaskSuspend>
            /* Suspend Collect coins. */
            vTaskSuspend( gu8_give_refund );
     888:	80 91 89 01 	lds	r24, 0x0189	; 0x800189 <gu8_give_refund>
     88c:	90 91 8a 01 	lds	r25, 0x018A	; 0x80018a <gu8_give_refund+0x1>
     890:	0e 94 b9 15 	call	0x2b72	; 0x2b72 <vTaskSuspend>
            au8_take_mutex_mailbox = xSemaphoreTake( mutex_for_display_mailbox  , (TickType_t)portMAX_DELAY);
     894:	6f ef       	ldi	r22, 0xFF	; 255
     896:	7f ef       	ldi	r23, 0xFF	; 255
     898:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     89c:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     8a0:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
            /* Send A message to user .. preparing coffee. */
            
            /* TODO: mechanical System Should works here. */
            
            /* Transfer this task to waiting state. */
            vTaskDelay(( COUNT_DOWN_IN_SEC * COUNT_DOWN_PERIOD_MS)/portTICK_PERIOD_MS); 
     8a4:	88 e8       	ldi	r24, 0x88	; 136
     8a6:	93 e1       	ldi	r25, 0x13	; 19
     8a8:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>
    
            g_mail_box.message_id = PREPARING_COFFEE_ID;
     8ac:	08 83       	st	Y, r16

            strcpy( g_mail_box.message, "Preparing" );
     8ae:	8a e0       	ldi	r24, 0x0A	; 10
     8b0:	e9 ee       	ldi	r30, 0xE9	; 233
     8b2:	f0 e0       	ldi	r31, 0x00	; 0
     8b4:	a4 e6       	ldi	r26, 0x64	; 100
     8b6:	b0 e0       	ldi	r27, 0x00	; 0
     8b8:	01 90       	ld	r0, Z+
     8ba:	0d 92       	st	X+, r0
     8bc:	8a 95       	dec	r24
     8be:	e1 f7       	brne	.-8      	; 0x8b8 <__stack+0x59>
            
            xQueueSend( display_msg_mail_box, &g_ptr_display_mailbox, (TickType_t)0 );
     8c0:	20 e0       	ldi	r18, 0x00	; 0
     8c2:	40 e0       	ldi	r20, 0x00	; 0
     8c4:	50 e0       	ldi	r21, 0x00	; 0
     8c6:	61 e6       	ldi	r22, 0x61	; 97
     8c8:	70 e0       	ldi	r23, 0x00	; 0
     8ca:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     8ce:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     8d2:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
            
            /* Transfer this task to waiting state. */
            vTaskDelay(( COUNT_DOWN_IN_SEC * COUNT_DOWN_PERIOD_MS)/portTICK_PERIOD_MS); 
     8d6:	88 e8       	ldi	r24, 0x88	; 136
     8d8:	93 e1       	ldi	r25, 0x13	; 19
     8da:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>

            /* Send Thank you Message. */
            g_mail_box.message_id = THANK_YOU_MSG_ID;
     8de:	18 83       	st	Y, r17

            strcpy( g_mail_box.message, "Thanks" );
     8e0:	87 e0       	ldi	r24, 0x07	; 7
     8e2:	e3 ef       	ldi	r30, 0xF3	; 243
     8e4:	f0 e0       	ldi	r31, 0x00	; 0
     8e6:	a4 e6       	ldi	r26, 0x64	; 100
     8e8:	b0 e0       	ldi	r27, 0x00	; 0
     8ea:	01 90       	ld	r0, Z+
     8ec:	0d 92       	st	X+, r0
     8ee:	8a 95       	dec	r24
     8f0:	e1 f7       	brne	.-8      	; 0x8ea <__stack+0x8b>

            xQueueSend( display_msg_mail_box, &g_ptr_display_mailbox, (TickType_t)0 );
     8f2:	20 e0       	ldi	r18, 0x00	; 0
     8f4:	40 e0       	ldi	r20, 0x00	; 0
     8f6:	50 e0       	ldi	r21, 0x00	; 0
     8f8:	61 e6       	ldi	r22, 0x61	; 97
     8fa:	70 e0       	ldi	r23, 0x00	; 0
     8fc:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     900:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     904:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>

            /* Transfer this task to waiting state. */
            vTaskDelay(( COUNT_DOWN_IN_SEC * COUNT_DOWN_PERIOD_MS)/portTICK_PERIOD_MS); 
     908:	88 e8       	ldi	r24, 0x88	; 136
     90a:	93 e1       	ldi	r25, 0x13	; 19
     90c:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>
            /* Naive Solution. */

            xSemaphoreGive( mutex_for_display_mailbox );
     910:	20 e0       	ldi	r18, 0x00	; 0
     912:	40 e0       	ldi	r20, 0x00	; 0
     914:	50 e0       	ldi	r21, 0x00	; 0
     916:	60 e0       	ldi	r22, 0x00	; 0
     918:	70 e0       	ldi	r23, 0x00	; 0
     91a:	80 91 98 01 	lds	r24, 0x0198	; 0x800198 <mutex_for_display_mailbox>
     91e:	90 91 99 01 	lds	r25, 0x0199	; 0x800199 <mutex_for_display_mailbox+0x1>
     922:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>


            send_default_page();
     926:	2e dc       	rcall	.-1956   	; 0x184 <send_default_page>
            
            /* TODO: Solve the problem Semaphore releasing twice by 
            two condition inside switch case in Display Task. */
            xSemaphoreTake(sema_allowable_time_for_insert_coins, (TickType_t)portMAX_DELAY);
     928:	6f ef       	ldi	r22, 0xFF	; 255
     92a:	7f ef       	ldi	r23, 0xFF	; 255
     92c:	80 91 94 01 	lds	r24, 0x0194	; 0x800194 <sema_allowable_time_for_insert_coins>
     930:	90 91 95 01 	lds	r25, 0x0195	; 0x800195 <sema_allowable_time_for_insert_coins+0x1>
     934:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>

            /* Resume Collect Coins. */
            vTaskResume( gu8_collect_coins_handle );
     938:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <gu8_collect_coins_handle>
     93c:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <gu8_collect_coins_handle+0x1>
     940:	0e 94 88 13 	call	0x2710	; 0x2710 <vTaskResume>
            /* Resume read cmd task. */
            vTaskResume( gu8_read_cmd_handle );
     944:	80 91 8d 01 	lds	r24, 0x018D	; 0x80018d <gu8_read_cmd_handle>
     948:	90 91 8e 01 	lds	r25, 0x018E	; 0x80018e <gu8_read_cmd_handle+0x1>
     94c:	0e 94 88 13 	call	0x2710	; 0x2710 <vTaskResume>

            vTaskResume( gu8_give_refund );
     950:	80 91 89 01 	lds	r24, 0x0189	; 0x800189 <gu8_give_refund>
     954:	90 91 8a 01 	lds	r25, 0x018A	; 0x80018a <gu8_give_refund+0x1>
     958:	0e 94 88 13 	call	0x2710	; 0x2710 <vTaskResume>
            /* reset the flag. */
            deliver_coffee = NULL;
     95c:	80 e0       	ldi	r24, 0x00	; 0
     95e:	83 cf       	rjmp	.-250    	; 0x866 <__stack+0x7>
        }
        else
        {
            /* Deliver Coffee ? */
            deliver_coffee = xSemaphoreTake( sema_deliver_coffee , (TickType_t)portMAX_DELAY);
     960:	6f ef       	ldi	r22, 0xFF	; 255
     962:	7f ef       	ldi	r23, 0xFF	; 255
     964:	80 91 85 01 	lds	r24, 0x0185	; 0x800185 <sema_deliver_coffee>
     968:	90 91 86 01 	lds	r25, 0x0186	; 0x800186 <sema_deliver_coffee+0x1>
     96c:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>
     970:	7a cf       	rjmp	.-268    	; 0x866 <__stack+0x7>

00000972 <Display_Messages_Task>:
/** @brief This Task Responsiable to display messages to user.
 * @priority 1 => Lowest Priority in the system.
 * @param au8_ptr 
 */
void Display_Messages_Task( void* a_ptr )
{
     972:	cf 93       	push	r28
     974:	df 93       	push	r29
     976:	00 d0       	rcall	.+0      	; 0x978 <Display_Messages_Task+0x6>
     978:	cd b7       	in	r28, 0x3d	; 61
     97a:	de b7       	in	r29, 0x3e	; 62
	uint8_t au8_char_to_display = FALSE;
	uint8_t au8_counter         = FALSE;
	uint8_t au8_locker          = FALSE;

    /* Check if the system is Init Successfully or not. */
    if ( FALSE == gu8_is_init )
     97c:	80 91 84 01 	lds	r24, 0x0184	; 0x800184 <gu8_is_init>
     980:	81 11       	cpse	r24, r1
     982:	04 c0       	rjmp	.+8      	; 0x98c <Display_Messages_Task+0x1a>
    {
        /* Block System for the Init Time. */
       vTaskDelay(200/portTICK_PERIOD_MS);
     984:	88 ec       	ldi	r24, 0xC8	; 200
     986:	90 e0       	ldi	r25, 0x00	; 0
     988:	0e 94 43 15 	call	0x2a86	; 0x2a86 <vTaskDelay>

                /* Start SW Timer for counter down. */
                if ( mailbox->message_id != WELCOME_MSG_ID && mailbox->message_id != THANK_YOU_MSG_ID) xTimerStart(g_count_down_timer, (TickType_t)0);
                
                /* Wait for new Message to Come. */
                au8_locker          = FALSE;
     98c:	10 e0       	ldi	r17, 0x00	; 0
     98e:	f1 2c       	mov	r15, r1
     990:	05 c0       	rjmp	.+10     	; 0x99c <Display_Messages_Task+0x2a>
        if ( (TRUE == au8_locker) || pdPASS  == xQueueReceive( display_msg_mail_box, &mailbox, portMAX_DELAY ) )
        {
            /* Check the length of the incoming msg. */
            if ( FALSE == au8_locker ) /* Read Length only if locker is false which means new message came. */
            {
                au8_locker  = TRUE;
     992:	11 e0       	ldi	r17, 0x01	; 1
     994:	03 c0       	rjmp	.+6      	; 0x99c <Display_Messages_Task+0x2a>

                /* Start SW Timer for counter down. */
                if ( mailbox->message_id != WELCOME_MSG_ID && mailbox->message_id != THANK_YOU_MSG_ID) xTimerStart(g_count_down_timer, (TickType_t)0);
                
                /* Wait for new Message to Come. */
                au8_locker          = FALSE;
     996:	1f 2d       	mov	r17, r15
     998:	01 c0       	rjmp	.+2      	; 0x99c <Display_Messages_Task+0x2a>
     99a:	1f 2d       	mov	r17, r15
    ptr_to_task_display mailbox;
    uint8_t au8_take_mutex_mailbox = NULL;
    while( TRUE )
    {
        /* If it taken so another task is writting on it in this instance. */
        if ( (TRUE == au8_locker) || pdPASS  == xQueueReceive( display_msg_mail_box, &mailbox, portMAX_DELAY ) )
     99c:	11 30       	cpi	r17, 0x01	; 1
     99e:	79 f0       	breq	.+30     	; 0x9be <Display_Messages_Task+0x4c>
     9a0:	4f ef       	ldi	r20, 0xFF	; 255
     9a2:	5f ef       	ldi	r21, 0xFF	; 255
     9a4:	be 01       	movw	r22, r28
     9a6:	6f 5f       	subi	r22, 0xFF	; 255
     9a8:	7f 4f       	sbci	r23, 0xFF	; 255
     9aa:	80 91 a0 01 	lds	r24, 0x01A0	; 0x8001a0 <display_msg_mail_box>
     9ae:	90 91 a1 01 	lds	r25, 0x01A1	; 0x8001a1 <display_msg_mail_box+0x1>
     9b2:	0e 94 37 10 	call	0x206e	; 0x206e <xQueueReceive>
     9b6:	81 30       	cpi	r24, 0x01	; 1
     9b8:	89 f7       	brne	.-30     	; 0x99c <Display_Messages_Task+0x2a>
        {
            /* Check the length of the incoming msg. */
            if ( FALSE == au8_locker ) /* Read Length only if locker is false which means new message came. */
     9ba:	11 23       	and	r17, r17
     9bc:	51 f3       	breq	.-44     	; 0x992 <Display_Messages_Task+0x20>
                au8_locker  = TRUE;
            }
            else
            {       
                /* Clear LCD First. */
                LCD_Clear_Display();
     9be:	1f d3       	rcall	.+1598   	; 0xffe <LCD_Clear_Display>
                
                /* Display The Message. */
                /* Start SW Timer. */
                xTimerStart(display_characters_timer, (TickType_t)portMAX_DELAY);
     9c0:	0e 94 05 14 	call	0x280a	; 0x280a <xTaskGetTickCount>
     9c4:	0f ef       	ldi	r16, 0xFF	; 255
     9c6:	1f ef       	ldi	r17, 0xFF	; 255
     9c8:	20 e0       	ldi	r18, 0x00	; 0
     9ca:	30 e0       	ldi	r19, 0x00	; 0
     9cc:	ac 01       	movw	r20, r24
     9ce:	61 e0       	ldi	r22, 0x01	; 1
     9d0:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <display_characters_timer>
     9d4:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <display_characters_timer+0x1>
     9d8:	0e 94 8e 18 	call	0x311c	; 0x311c <xTimerGenericCommand>
               
                /* First Indicate any message is coming by message ID. */
                switch ( mailbox->message_id )
     9dc:	a9 81       	ldd	r26, Y+1	; 0x01
     9de:	ba 81       	ldd	r27, Y+2	; 0x02
     9e0:	8c 91       	ld	r24, X
     9e2:	86 30       	cpi	r24, 0x06	; 6
     9e4:	28 f4       	brcc	.+10     	; 0x9f0 <Display_Messages_Task+0x7e>
     9e6:	83 30       	cpi	r24, 0x03	; 3
     9e8:	18 f5       	brcc	.+70     	; 0xa30 <Display_Messages_Task+0xbe>
     9ea:	81 30       	cpi	r24, 0x01	; 1
     9ec:	39 f0       	breq	.+14     	; 0x9fc <Display_Messages_Task+0x8a>
     9ee:	34 c0       	rjmp	.+104    	; 0xa58 <Display_Messages_Task+0xe6>
     9f0:	88 30       	cpi	r24, 0x08	; 8
     9f2:	78 f1       	brcs	.+94     	; 0xa52 <Display_Messages_Task+0xe0>
     9f4:	31 c0       	rjmp	.+98     	; 0xa58 <Display_Messages_Task+0xe6>
     9f6:	1f 5f       	subi	r17, 0xFF	; 255
     9f8:	0f 5f       	subi	r16, 0xFF	; 255
     9fa:	02 c0       	rjmp	.+4      	; 0xa00 <Display_Messages_Task+0x8e>
     9fc:	00 e0       	ldi	r16, 0x00	; 0
     9fe:	1f ef       	ldi	r17, 0xFF	; 255
                    /* I need to print Menu. */        
                    /* I added The Condition to NUMBER_OF_PRODUCTS + 1 to add welcome Message. */
                    for(sint8_t i = -1; i < NUMBER_OF_PRODUCTS; ++i )
                    {
                        /* Wait Notification Signal From LCD. */
                        xSemaphoreTake(sema_display_string, (TickType_t) portMAX_DELAY );
     a00:	6f ef       	ldi	r22, 0xFF	; 255
     a02:	7f ef       	ldi	r23, 0xFF	; 255
     a04:	80 91 9e 01 	lds	r24, 0x019E	; 0x80019e <sema_display_string>
     a08:	90 91 9f 01 	lds	r25, 0x019F	; 0x80019f <sema_display_string+0x1>
     a0c:	0e 94 c0 10 	call	0x2180	; 0x2180 <xQueueSemaphoreTake>

                        if ( (-1) == i )
     a10:	1f 3f       	cpi	r17, 0xFF	; 255
     a12:	31 f4       	brne	.+12     	; 0xa20 <Display_Messages_Task+0xae>
                        {
                            COFFEE_MACHINE_Display_MainPage(i, &gstr_products, WELCOME_MSG_ID);
     a14:	41 e0       	ldi	r20, 0x01	; 1
     a16:	6e e2       	ldi	r22, 0x2E	; 46
     a18:	71 e0       	ldi	r23, 0x01	; 1
     a1a:	8f ef       	ldi	r24, 0xFF	; 255
     a1c:	d2 db       	rcall	.-2140   	; 0x1c2 <COFFEE_MACHINE_Display_MainPage>
     a1e:	eb cf       	rjmp	.-42     	; 0x9f6 <Display_Messages_Task+0x84>
                        }
                        else
                        {
                            COFFEE_MACHINE_Display_MainPage(i, &gstr_products, MENU_MSG_ID);
     a20:	42 e0       	ldi	r20, 0x02	; 2
     a22:	6e e2       	ldi	r22, 0x2E	; 46
     a24:	71 e0       	ldi	r23, 0x01	; 1
     a26:	81 2f       	mov	r24, r17
     a28:	cc db       	rcall	.-2152   	; 0x1c2 <COFFEE_MACHINE_Display_MainPage>
                switch ( mailbox->message_id )
                {
                    case WELCOME_MSG_ID:
                    /* I need to print Menu. */        
                    /* I added The Condition to NUMBER_OF_PRODUCTS + 1 to add welcome Message. */
                    for(sint8_t i = -1; i < NUMBER_OF_PRODUCTS; ++i )
     a2a:	03 30       	cpi	r16, 0x03	; 3
     a2c:	24 f3       	brlt	.-56     	; 0x9f6 <Display_Messages_Task+0x84>
     a2e:	14 c0       	rjmp	.+40     	; 0xa58 <Display_Messages_Task+0xe6>
                    break;
                    case INSERT_COINS_MESSAGE_ID:
                    case SORRY_MSG_ID:
                    case TAKE_REFUND_MSG_ID:
                        /* Display Insert Coins Message + Timer. */
                        strcat( mailbox->message, TIMER_MSG );
     a30:	11 96       	adiw	r26, 0x01	; 1
     a32:	0d 90       	ld	r0, X+
     a34:	00 20       	and	r0, r0
     a36:	e9 f7       	brne	.-6      	; 0xa32 <Display_Messages_Task+0xc0>
     a38:	11 97       	sbiw	r26, 0x01	; 1
     a3a:	88 e0       	ldi	r24, 0x08	; 8
     a3c:	ea ef       	ldi	r30, 0xFA	; 250
     a3e:	f0 e0       	ldi	r31, 0x00	; 0
     a40:	01 90       	ld	r0, Z+
     a42:	0d 92       	st	X+, r0
     a44:	8a 95       	dec	r24
     a46:	e1 f7       	brne	.-8      	; 0xa40 <Display_Messages_Task+0xce>
                        display_msg( mailbox->message  );
     a48:	89 81       	ldd	r24, Y+1	; 0x01
     a4a:	9a 81       	ldd	r25, Y+2	; 0x02
     a4c:	01 96       	adiw	r24, 0x01	; 1
     a4e:	33 dc       	rcall	.-1946   	; 0x2b6 <display_msg>
                    break;
     a50:	03 c0       	rjmp	.+6      	; 0xa58 <Display_Messages_Task+0xe6>
                    case PREPARING_COFFEE_ID:
                    case THANK_YOU_MSG_ID:
                        display_msg( mailbox->message );
     a52:	cd 01       	movw	r24, r26
     a54:	01 96       	adiw	r24, 0x01	; 1
     a56:	2f dc       	rcall	.-1954   	; 0x2b6 <display_msg>
     a58:	00 e0       	ldi	r16, 0x00	; 0
                    default:
                    break;
                }
                /* Stop SW Timer. */
                xTimerStop(display_characters_timer, (TickType_t)0);
     a5a:	10 e0       	ldi	r17, 0x00	; 0
     a5c:	20 e0       	ldi	r18, 0x00	; 0
     a5e:	30 e0       	ldi	r19, 0x00	; 0
     a60:	40 e0       	ldi	r20, 0x00	; 0
     a62:	50 e0       	ldi	r21, 0x00	; 0
     a64:	63 e0       	ldi	r22, 0x03	; 3
     a66:	80 91 9a 01 	lds	r24, 0x019A	; 0x80019a <display_characters_timer>
     a6a:	90 91 9b 01 	lds	r25, 0x019B	; 0x80019b <display_characters_timer+0x1>
     a6e:	0e 94 8e 18 	call	0x311c	; 0x311c <xTimerGenericCommand>
     a72:	e9 81       	ldd	r30, Y+1	; 0x01

                /* Start SW Timer for counter down. */
                if ( mailbox->message_id != WELCOME_MSG_ID && mailbox->message_id != THANK_YOU_MSG_ID) xTimerStart(g_count_down_timer, (TickType_t)0);
     a74:	fa 81       	ldd	r31, Y+2	; 0x02
     a76:	80 81       	ld	r24, Z
     a78:	81 30       	cpi	r24, 0x01	; 1
     a7a:	09 f4       	brne	.+2      	; 0xa7e <Display_Messages_Task+0x10c>
     a7c:	8c cf       	rjmp	.-232    	; 0x996 <Display_Messages_Task+0x24>
     a7e:	87 30       	cpi	r24, 0x07	; 7
     a80:	09 f4       	brne	.+2      	; 0xa84 <Display_Messages_Task+0x112>
     a82:	8b cf       	rjmp	.-234    	; 0x99a <Display_Messages_Task+0x28>
     a84:	0e 94 05 14 	call	0x280a	; 0x280a <xTaskGetTickCount>
     a88:	20 e0       	ldi	r18, 0x00	; 0
     a8a:	30 e0       	ldi	r19, 0x00	; 0
     a8c:	ac 01       	movw	r20, r24
     a8e:	61 e0       	ldi	r22, 0x01	; 1
     a90:	80 91 96 01 	lds	r24, 0x0196	; 0x800196 <g_count_down_timer>
     a94:	90 91 97 01 	lds	r25, 0x0197	; 0x800197 <g_count_down_timer+0x1>
     a98:	0e 94 8e 18 	call	0x311c	; 0x311c <xTimerGenericCommand>
     a9c:	1f 2d       	mov	r17, r15
                
                /* Wait for new Message to Come. */
                au8_locker          = FALSE;
     a9e:	7e cf       	rjmp	.-260    	; 0x99c <Display_Messages_Task+0x2a>

00000aa0 <__vector_3>:
     aa0:	1f 92       	push	r1
    /* Send A new mailbox for Display Task. */
    xQueueSend(display_msg_mail_box, &g_ptr_display_mailbox, (TickType_t)0);

}
ISR(INT2_vect)
{
     aa2:	0f 92       	push	r0
     aa4:	0f b6       	in	r0, 0x3f	; 63
     aa6:	0f 92       	push	r0
     aa8:	11 24       	eor	r1, r1
     aaa:	8f 93       	push	r24
    gu8_collected_coins++;
     aac:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <gu8_collected_coins>
     ab0:	8f 5f       	subi	r24, 0xFF	; 255
     ab2:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <gu8_collected_coins>
     ab6:	8f 91       	pop	r24
     ab8:	0f 90       	pop	r0
     aba:	0f be       	out	0x3f, r0	; 63
     abc:	0f 90       	pop	r0
     abe:	1f 90       	pop	r1
     ac0:	18 95       	reti

00000ac2 <Keypad_Init>:

extern Error Keypad_Init(void)
{
	Error u8Status = KEYPAD_E_OK;
	
	if (KEYPAD_E_INITIALIZED != Gu8_Init_Flag)
     ac2:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <Gu8_Init_Flag>
     ac6:	81 30       	cpi	r24, 0x01	; 1
     ac8:	41 f1       	breq	.+80     	; 0xb1a <Keypad_Init+0x58>
	{
		DIO_Pin_Init(ROW1,OUTPUT);
     aca:	61 e0       	ldi	r22, 0x01	; 1
     acc:	82 e1       	ldi	r24, 0x12	; 18
     ace:	10 d4       	rcall	.+2080   	; 0x12f0 <DIO_Pin_Init>
		DIO_Pin_Init(ROW2,OUTPUT);
     ad0:	61 e0       	ldi	r22, 0x01	; 1
     ad2:	83 e1       	ldi	r24, 0x13	; 19
     ad4:	0d d4       	rcall	.+2074   	; 0x12f0 <DIO_Pin_Init>
		DIO_Pin_Init(ROW3,OUTPUT);
     ad6:	61 e0       	ldi	r22, 0x01	; 1
     ad8:	84 e1       	ldi	r24, 0x14	; 20
     ada:	0a d4       	rcall	.+2068   	; 0x12f0 <DIO_Pin_Init>
		
		DIO_Pin_Init(COL1,INPUT);
     adc:	60 e0       	ldi	r22, 0x00	; 0
     ade:	85 e1       	ldi	r24, 0x15	; 21
     ae0:	07 d4       	rcall	.+2062   	; 0x12f0 <DIO_Pin_Init>
		DIO_Pin_Init(COL2,INPUT);
     ae2:	60 e0       	ldi	r22, 0x00	; 0
     ae4:	86 e1       	ldi	r24, 0x16	; 22
     ae6:	04 d4       	rcall	.+2056   	; 0x12f0 <DIO_Pin_Init>
		DIO_Pin_Init(COL3,INPUT);
     ae8:	60 e0       	ldi	r22, 0x00	; 0
     aea:	87 e1       	ldi	r24, 0x17	; 23
     aec:	01 d4       	rcall	.+2050   	; 0x12f0 <DIO_Pin_Init>
		
		DIO_Pin_Activate_pull_up(COL1);
     aee:	85 e1       	ldi	r24, 0x15	; 21
     af0:	ff d4       	rcall	.+2558   	; 0x14f0 <DIO_Pin_Activate_pull_up>
		DIO_Pin_Activate_pull_up(COL2);
     af2:	86 e1       	ldi	r24, 0x16	; 22
     af4:	fd d4       	rcall	.+2554   	; 0x14f0 <DIO_Pin_Activate_pull_up>
		DIO_Pin_Activate_pull_up(COL3);
     af6:	87 e1       	ldi	r24, 0x17	; 23
     af8:	fb d4       	rcall	.+2550   	; 0x14f0 <DIO_Pin_Activate_pull_up>
		
		DIO_Pin_Write(ROW1,HIGH);
     afa:	61 e0       	ldi	r22, 0x01	; 1
     afc:	82 e1       	ldi	r24, 0x12	; 18
     afe:	4f d3       	rcall	.+1694   	; 0x119e <DIO_Pin_Write>
     b00:	61 e0       	ldi	r22, 0x01	; 1
		DIO_Pin_Write(ROW2,HIGH);
     b02:	83 e1       	ldi	r24, 0x13	; 19
     b04:	4c d3       	rcall	.+1688   	; 0x119e <DIO_Pin_Write>
     b06:	61 e0       	ldi	r22, 0x01	; 1
     b08:	84 e1       	ldi	r24, 0x14	; 20
		DIO_Pin_Write(ROW3,HIGH);
     b0a:	49 d3       	rcall	.+1682   	; 0x119e <DIO_Pin_Write>
     b0c:	10 92 a2 01 	sts	0x01A2, r1	; 0x8001a2 <Gu8_Get_Key_State>
     b10:	81 e0       	ldi	r24, 0x01	; 1
		
		Gu8_Get_Key_State = CHECK;
     b12:	80 93 a3 01 	sts	0x01A3, r24	; 0x8001a3 <Gu8_Init_Flag>
		Gu8_Init_Flag = KEYPAD_E_INITIALIZED;
     b16:	80 e0       	ldi	r24, 0x00	; 0
     b18:	08 95       	ret
     b1a:	81 e0       	ldi	r24, 0x01	; 1
/*- APIs IMPLEMENTATION -----------------------------------*/


extern Error Keypad_Init(void)
{
	Error u8Status = KEYPAD_E_OK;
     b1c:	08 95       	ret

00000b1e <Keypad_Get_Key>:
     b1e:	cf 92       	push	r12
		Gu8_Get_Key_State = CHECK;
		Gu8_Init_Flag = KEYPAD_E_INITIALIZED;
	}
	else
	{
		u8Status = KEYPAD_E_INITIALIZED;
     b20:	df 92       	push	r13
	}
	return u8Status;
}
     b22:	ef 92       	push	r14

extern Error Keypad_Get_Key(u8* pu8Row,u8* pu8Col)
{
     b24:	ff 92       	push	r15
     b26:	0f 93       	push	r16
     b28:	1f 93       	push	r17
     b2a:	cf 93       	push	r28
     b2c:	df 93       	push	r29
     b2e:	1f 92       	push	r1
     b30:	cd b7       	in	r28, 0x3d	; 61
     b32:	de b7       	in	r29, 0x3e	; 62
     b34:	8c 01       	movw	r16, r24
     b36:	7b 01       	movw	r14, r22
	u8 u8_Detected_Row = NOKEY;
	u8 u8Detected_Col = NOKEY ;
	u8 u8Button_State = HIGH;
     b38:	81 e0       	ldi	r24, 0x01	; 1
     b3a:	89 83       	std	Y+1, r24	; 0x01
	u8 u8Row_index = 0 ;
	Error u8Status = KEYPAD_E_OK;

	*pu8Row = NOKEY ;
     b3c:	f8 01       	movw	r30, r16
     b3e:	10 82       	st	Z, r1
	*pu8Col = NOKEY ;
     b40:	fb 01       	movw	r30, r22
     b42:	10 82       	st	Z, r1
	
	switch (Gu8_Get_Key_State)
     b44:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <Gu8_Get_Key_State>
     b48:	88 23       	and	r24, r24
     b4a:	21 f0       	breq	.+8      	; 0xb54 <Keypad_Get_Key+0x36>
     b4c:	81 30       	cpi	r24, 0x01	; 1
     b4e:	09 f4       	brne	.+2      	; 0xb52 <Keypad_Get_Key+0x34>
     b50:	96 c0       	rjmp	.+300    	; 0xc7e <Keypad_Get_Key+0x160>
     b52:	58 c1       	rjmp	.+688    	; 0xe04 <Keypad_Get_Key+0x2e6>
	{
		case CHECK:
		{
			DIO_Pin_Toggle(B3);
     b54:	8b e0       	ldi	r24, 0x0B	; 11
     b56:	d1 d4       	rcall	.+2466   	; 0x14fa <DIO_Pin_Toggle>
			
			if (KEYPAD_E_INITIALIZED == Gu8_Init_Flag)
     b58:	80 91 a3 01 	lds	r24, 0x01A3	; 0x8001a3 <Gu8_Init_Flag>
     b5c:	81 30       	cpi	r24, 0x01	; 1
     b5e:	09 f0       	breq	.+2      	; 0xb62 <Keypad_Get_Key+0x44>
     b60:	51 c1       	rjmp	.+674    	; 0xe04 <Keypad_Get_Key+0x2e6>
			{
				if ((0 != pu8Row)&&(0 != pu8Col))
     b62:	01 2b       	or	r16, r17
     b64:	09 f4       	brne	.+2      	; 0xb68 <Keypad_Get_Key+0x4a>
     b66:	4e c1       	rjmp	.+668    	; 0xe04 <Keypad_Get_Key+0x2e6>
     b68:	ef 28       	or	r14, r15
     b6a:	09 f4       	brne	.+2      	; 0xb6e <Keypad_Get_Key+0x50>
     b6c:	4b c1       	rjmp	.+662    	; 0xe04 <Keypad_Get_Key+0x2e6>
				{
					DIO_Pin_Write(ROW1,LOW);
     b6e:	60 e0       	ldi	r22, 0x00	; 0
     b70:	82 e1       	ldi	r24, 0x12	; 18
     b72:	15 d3       	rcall	.+1578   	; 0x119e <DIO_Pin_Write>
					DIO_Pin_Write(ROW2,HIGH);
     b74:	61 e0       	ldi	r22, 0x01	; 1
     b76:	83 e1       	ldi	r24, 0x13	; 19
     b78:	12 d3       	rcall	.+1572   	; 0x119e <DIO_Pin_Write>
					DIO_Pin_Write(ROW3,HIGH);
     b7a:	61 e0       	ldi	r22, 0x01	; 1
     b7c:	84 e1       	ldi	r24, 0x14	; 20
     b7e:	0f d3       	rcall	.+1566   	; 0x119e <DIO_Pin_Write>
     b80:	be 01       	movw	r22, r28
					
					DIO_Pin_Read(COL1,&u8Button_State);
     b82:	6f 5f       	subi	r22, 0xFF	; 255
     b84:	7f 4f       	sbci	r23, 0xFF	; 255
     b86:	85 e1       	ldi	r24, 0x15	; 21
     b88:	5c d4       	rcall	.+2232   	; 0x1442 <DIO_Pin_Read>
     b8a:	89 81       	ldd	r24, Y+1	; 0x01
						
					if (LOW == u8Button_State)
     b8c:	81 11       	cpse	r24, r1
     b8e:	04 c0       	rjmp	.+8      	; 0xb98 <Keypad_Get_Key+0x7a>
     b90:	81 e0       	ldi	r24, 0x01	; 1
					{
						Gu8_Get_Key_State = TAKE_ACTION;
     b92:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
     b96:	17 c0       	rjmp	.+46     	; 0xbc6 <Keypad_Get_Key+0xa8>
					}
					else
					{
						DIO_Pin_Read(COL2,&u8Button_State);
     b98:	be 01       	movw	r22, r28
     b9a:	6f 5f       	subi	r22, 0xFF	; 255
     b9c:	7f 4f       	sbci	r23, 0xFF	; 255
     b9e:	86 e1       	ldi	r24, 0x16	; 22
     ba0:	50 d4       	rcall	.+2208   	; 0x1442 <DIO_Pin_Read>
     ba2:	89 81       	ldd	r24, Y+1	; 0x01
							
						if (LOW == u8Button_State)
     ba4:	81 11       	cpse	r24, r1
     ba6:	04 c0       	rjmp	.+8      	; 0xbb0 <Keypad_Get_Key+0x92>
     ba8:	81 e0       	ldi	r24, 0x01	; 1
						{
							Gu8_Get_Key_State = TAKE_ACTION;
     baa:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
     bae:	0b c0       	rjmp	.+22     	; 0xbc6 <Keypad_Get_Key+0xa8>
						}
						else
						{
							DIO_Pin_Read(COL3,&u8Button_State);
     bb0:	be 01       	movw	r22, r28
     bb2:	6f 5f       	subi	r22, 0xFF	; 255
     bb4:	7f 4f       	sbci	r23, 0xFF	; 255
     bb6:	87 e1       	ldi	r24, 0x17	; 23
     bb8:	44 d4       	rcall	.+2184   	; 0x1442 <DIO_Pin_Read>
     bba:	89 81       	ldd	r24, Y+1	; 0x01
								
							if (LOW == u8Button_State)
     bbc:	81 11       	cpse	r24, r1
     bbe:	03 c0       	rjmp	.+6      	; 0xbc6 <Keypad_Get_Key+0xa8>
							{
								Gu8_Get_Key_State = TAKE_ACTION;
     bc0:	81 e0       	ldi	r24, 0x01	; 1
     bc2:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
							}
						}
						
					}
					
					DIO_Pin_Write(ROW2,LOW);
     bc6:	60 e0       	ldi	r22, 0x00	; 0
     bc8:	83 e1       	ldi	r24, 0x13	; 19
					DIO_Pin_Write(ROW1,HIGH);
     bca:	e9 d2       	rcall	.+1490   	; 0x119e <DIO_Pin_Write>
     bcc:	61 e0       	ldi	r22, 0x01	; 1
     bce:	82 e1       	ldi	r24, 0x12	; 18
					DIO_Pin_Write(ROW3,HIGH);
     bd0:	e6 d2       	rcall	.+1484   	; 0x119e <DIO_Pin_Write>
     bd2:	61 e0       	ldi	r22, 0x01	; 1
     bd4:	84 e1       	ldi	r24, 0x14	; 20
     bd6:	e3 d2       	rcall	.+1478   	; 0x119e <DIO_Pin_Write>
					
					DIO_Pin_Read(COL1,&u8Button_State);
     bd8:	be 01       	movw	r22, r28
     bda:	6f 5f       	subi	r22, 0xFF	; 255
     bdc:	7f 4f       	sbci	r23, 0xFF	; 255
     bde:	85 e1       	ldi	r24, 0x15	; 21
     be0:	30 d4       	rcall	.+2144   	; 0x1442 <DIO_Pin_Read>
     be2:	89 81       	ldd	r24, Y+1	; 0x01
					
					if (LOW == u8Button_State)
     be4:	81 11       	cpse	r24, r1
     be6:	04 c0       	rjmp	.+8      	; 0xbf0 <Keypad_Get_Key+0xd2>
					{
						Gu8_Get_Key_State = TAKE_ACTION;
     be8:	81 e0       	ldi	r24, 0x01	; 1
     bea:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
     bee:	17 c0       	rjmp	.+46     	; 0xc1e <Keypad_Get_Key+0x100>
					}
					else
					{
						DIO_Pin_Read(COL2,&u8Button_State);
     bf0:	be 01       	movw	r22, r28
     bf2:	6f 5f       	subi	r22, 0xFF	; 255
     bf4:	7f 4f       	sbci	r23, 0xFF	; 255
     bf6:	86 e1       	ldi	r24, 0x16	; 22
     bf8:	24 d4       	rcall	.+2120   	; 0x1442 <DIO_Pin_Read>
						if (LOW == u8Button_State)
     bfa:	89 81       	ldd	r24, Y+1	; 0x01
     bfc:	81 11       	cpse	r24, r1
     bfe:	04 c0       	rjmp	.+8      	; 0xc08 <Keypad_Get_Key+0xea>
						{
							Gu8_Get_Key_State = TAKE_ACTION;
     c00:	81 e0       	ldi	r24, 0x01	; 1
     c02:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
     c06:	0b c0       	rjmp	.+22     	; 0xc1e <Keypad_Get_Key+0x100>
						}
						else
						{
							DIO_Pin_Read(COL3,&u8Button_State);
     c08:	be 01       	movw	r22, r28
     c0a:	6f 5f       	subi	r22, 0xFF	; 255
     c0c:	7f 4f       	sbci	r23, 0xFF	; 255
     c0e:	87 e1       	ldi	r24, 0x17	; 23
							if (LOW == u8Button_State)
     c10:	18 d4       	rcall	.+2096   	; 0x1442 <DIO_Pin_Read>
     c12:	89 81       	ldd	r24, Y+1	; 0x01
							{
								Gu8_Get_Key_State = TAKE_ACTION;
     c14:	81 11       	cpse	r24, r1
     c16:	03 c0       	rjmp	.+6      	; 0xc1e <Keypad_Get_Key+0x100>
     c18:	81 e0       	ldi	r24, 0x01	; 1
								/*Do Nothing*/
							}
						}
						
					}
					DIO_Pin_Write(ROW3,LOW);
     c1a:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
     c1e:	60 e0       	ldi	r22, 0x00	; 0
					DIO_Pin_Write(ROW1,HIGH);
     c20:	84 e1       	ldi	r24, 0x14	; 20
     c22:	bd d2       	rcall	.+1402   	; 0x119e <DIO_Pin_Write>
     c24:	61 e0       	ldi	r22, 0x01	; 1
     c26:	82 e1       	ldi	r24, 0x12	; 18
					DIO_Pin_Write(ROW2,HIGH);
     c28:	ba d2       	rcall	.+1396   	; 0x119e <DIO_Pin_Write>
     c2a:	61 e0       	ldi	r22, 0x01	; 1
     c2c:	83 e1       	ldi	r24, 0x13	; 19
     c2e:	b7 d2       	rcall	.+1390   	; 0x119e <DIO_Pin_Write>
					
					DIO_Pin_Read(COL1,&u8Button_State);
     c30:	be 01       	movw	r22, r28
     c32:	6f 5f       	subi	r22, 0xFF	; 255
     c34:	7f 4f       	sbci	r23, 0xFF	; 255
     c36:	85 e1       	ldi	r24, 0x15	; 21
     c38:	04 d4       	rcall	.+2056   	; 0x1442 <DIO_Pin_Read>
					if (LOW == u8Button_State)
     c3a:	89 81       	ldd	r24, Y+1	; 0x01
     c3c:	81 11       	cpse	r24, r1
     c3e:	04 c0       	rjmp	.+8      	; 0xc48 <Keypad_Get_Key+0x12a>
					{
						Gu8_Get_Key_State = TAKE_ACTION;
     c40:	81 e0       	ldi	r24, 0x01	; 1
     c42:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
					}
					else
					{
						DIO_Pin_Read(COL2,&u8Button_State);
     c46:	de c0       	rjmp	.+444    	; 0xe04 <Keypad_Get_Key+0x2e6>
     c48:	be 01       	movw	r22, r28
     c4a:	6f 5f       	subi	r22, 0xFF	; 255
     c4c:	7f 4f       	sbci	r23, 0xFF	; 255
     c4e:	86 e1       	ldi	r24, 0x16	; 22
     c50:	f8 d3       	rcall	.+2032   	; 0x1442 <DIO_Pin_Read>
						if (LOW == u8Button_State)
     c52:	89 81       	ldd	r24, Y+1	; 0x01
     c54:	81 11       	cpse	r24, r1
						{
							Gu8_Get_Key_State = TAKE_ACTION;
     c56:	04 c0       	rjmp	.+8      	; 0xc60 <Keypad_Get_Key+0x142>
     c58:	81 e0       	ldi	r24, 0x01	; 1
     c5a:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
						}
						else
						{
							DIO_Pin_Read(COL3,&u8Button_State);
     c5e:	d2 c0       	rjmp	.+420    	; 0xe04 <Keypad_Get_Key+0x2e6>
     c60:	be 01       	movw	r22, r28
     c62:	6f 5f       	subi	r22, 0xFF	; 255
     c64:	7f 4f       	sbci	r23, 0xFF	; 255
							if (LOW == u8Button_State)
     c66:	87 e1       	ldi	r24, 0x17	; 23
     c68:	ec d3       	rcall	.+2008   	; 0x1442 <DIO_Pin_Read>
     c6a:	89 81       	ldd	r24, Y+1	; 0x01
							{
								Gu8_Get_Key_State = TAKE_ACTION;
     c6c:	81 11       	cpse	r24, r1
     c6e:	03 c0       	rjmp	.+6      	; 0xc76 <Keypad_Get_Key+0x158>
							}
							else
							{
								/*Do Nothing*/
							}
							DIO_Pin_Write(ROW3,HIGH);
     c70:	81 e0       	ldi	r24, 0x01	; 1
     c72:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
     c76:	61 e0       	ldi	r22, 0x01	; 1
     c78:	84 e1       	ldi	r24, 0x14	; 20
		}
		case TAKE_ACTION:
		{
			if (0 == u8Row_index)
			{
				DIO_Pin_Write(ROW1,LOW);
     c7a:	91 d2       	rcall	.+1314   	; 0x119e <DIO_Pin_Write>
     c7c:	c3 c0       	rjmp	.+390    	; 0xe04 <Keypad_Get_Key+0x2e6>
     c7e:	60 e0       	ldi	r22, 0x00	; 0
     c80:	82 e1       	ldi	r24, 0x12	; 18
				DIO_Pin_Write(ROW2,HIGH);
     c82:	8d d2       	rcall	.+1306   	; 0x119e <DIO_Pin_Write>
     c84:	61 e0       	ldi	r22, 0x01	; 1
     c86:	83 e1       	ldi	r24, 0x13	; 19
				DIO_Pin_Write(ROW3,HIGH);
     c88:	8a d2       	rcall	.+1300   	; 0x119e <DIO_Pin_Write>
     c8a:	61 e0       	ldi	r22, 0x01	; 1
     c8c:	84 e1       	ldi	r24, 0x14	; 20
     c8e:	87 d2       	rcall	.+1294   	; 0x119e <DIO_Pin_Write>
				
				DIO_Pin_Read(COL1,&u8Button_State);
     c90:	be 01       	movw	r22, r28
     c92:	6f 5f       	subi	r22, 0xFF	; 255
     c94:	7f 4f       	sbci	r23, 0xFF	; 255
     c96:	85 e1       	ldi	r24, 0x15	; 21
     c98:	d4 d3       	rcall	.+1960   	; 0x1442 <DIO_Pin_Read>
     c9a:	89 81       	ldd	r24, Y+1	; 0x01
				
				if (LOW == u8Button_State)
     c9c:	81 11       	cpse	r24, r1
     c9e:	06 c0       	rjmp	.+12     	; 0xcac <Keypad_Get_Key+0x18e>
     ca0:	81 e0       	ldi	r24, 0x01	; 1
				{
					u8Detected_Col = FIRST_COL;
					u8_Detected_Row = FIRST_ROW;
					Gu8_Get_Key_State = TAKE_ACTION;
     ca2:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
				
				DIO_Pin_Read(COL1,&u8Button_State);
				
				if (LOW == u8Button_State)
				{
					u8Detected_Col = FIRST_COL;
     ca6:	cc 24       	eor	r12, r12
     ca8:	c3 94       	inc	r12
     caa:	af c0       	rjmp	.+350    	; 0xe0a <Keypad_Get_Key+0x2ec>
					u8_Detected_Row = FIRST_ROW;
					Gu8_Get_Key_State = TAKE_ACTION;
				}
				else
				{
					DIO_Pin_Read(COL2,&u8Button_State);
     cac:	be 01       	movw	r22, r28
     cae:	6f 5f       	subi	r22, 0xFF	; 255
     cb0:	7f 4f       	sbci	r23, 0xFF	; 255
     cb2:	86 e1       	ldi	r24, 0x16	; 22
     cb4:	c6 d3       	rcall	.+1932   	; 0x1442 <DIO_Pin_Read>
     cb6:	89 81       	ldd	r24, Y+1	; 0x01
					
					if (LOW == u8Button_State)
     cb8:	81 11       	cpse	r24, r1
     cba:	07 c0       	rjmp	.+14     	; 0xcca <Keypad_Get_Key+0x1ac>
     cbc:	81 e0       	ldi	r24, 0x01	; 1
					{
						u8Detected_Col = SECOND_COL;
						u8_Detected_Row = FIRST_ROW;
						Gu8_Get_Key_State = TAKE_ACTION;
     cbe:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
				{
					DIO_Pin_Read(COL2,&u8Button_State);
					
					if (LOW == u8Button_State)
					{
						u8Detected_Col = SECOND_COL;
     cc2:	68 94       	set
     cc4:	cc 24       	eor	r12, r12
     cc6:	c1 f8       	bld	r12, 1
						u8_Detected_Row = FIRST_ROW;
						Gu8_Get_Key_State = TAKE_ACTION;
					}
					else
					{
						DIO_Pin_Read(COL3,&u8Button_State);
     cc8:	a0 c0       	rjmp	.+320    	; 0xe0a <Keypad_Get_Key+0x2ec>
     cca:	be 01       	movw	r22, r28
     ccc:	6f 5f       	subi	r22, 0xFF	; 255
     cce:	7f 4f       	sbci	r23, 0xFF	; 255
     cd0:	87 e1       	ldi	r24, 0x17	; 23
						
						if (LOW == u8Button_State)
     cd2:	b7 d3       	rcall	.+1902   	; 0x1442 <DIO_Pin_Read>
     cd4:	89 81       	ldd	r24, Y+1	; 0x01
						{
							u8Detected_Col = THIRD_COL;
							u8_Detected_Row = FIRST_ROW;
							Gu8_Get_Key_State = TAKE_ACTION;
     cd6:	81 11       	cpse	r24, r1
     cd8:	08 c0       	rjmp	.+16     	; 0xcea <Keypad_Get_Key+0x1cc>
     cda:	81 e0       	ldi	r24, 0x01	; 1
					{
						DIO_Pin_Read(COL3,&u8Button_State);
						
						if (LOW == u8Button_State)
						{
							u8Detected_Col = THIRD_COL;
     cdc:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
     ce0:	0f 2e       	mov	r0, r31
     ce2:	f3 e0       	ldi	r31, 0x03	; 3
     ce4:	cf 2e       	mov	r12, r31
							u8_Detected_Row = FIRST_ROW;
							Gu8_Get_Key_State = TAKE_ACTION;
						}
						else
						{
							Gu8_Get_Key_State = CHECK;
     ce6:	f0 2d       	mov	r31, r0
     ce8:	90 c0       	rjmp	.+288    	; 0xe0a <Keypad_Get_Key+0x2ec>
			{
			}
			
			if (1 == u8Row_index)
			{
				DIO_Pin_Write(ROW2,LOW);
     cea:	10 92 a2 01 	sts	0x01A2, r1	; 0x8001a2 <Gu8_Get_Key_State>
     cee:	60 e0       	ldi	r22, 0x00	; 0
				DIO_Pin_Write(ROW1,HIGH);
     cf0:	83 e1       	ldi	r24, 0x13	; 19
     cf2:	55 d2       	rcall	.+1194   	; 0x119e <DIO_Pin_Write>
     cf4:	61 e0       	ldi	r22, 0x01	; 1
     cf6:	82 e1       	ldi	r24, 0x12	; 18
				DIO_Pin_Write(ROW3,HIGH);
     cf8:	52 d2       	rcall	.+1188   	; 0x119e <DIO_Pin_Write>
     cfa:	61 e0       	ldi	r22, 0x01	; 1
     cfc:	84 e1       	ldi	r24, 0x14	; 20
     cfe:	4f d2       	rcall	.+1182   	; 0x119e <DIO_Pin_Write>
				
				DIO_Pin_Read(COL1,&u8Button_State);
     d00:	be 01       	movw	r22, r28
     d02:	6f 5f       	subi	r22, 0xFF	; 255
     d04:	7f 4f       	sbci	r23, 0xFF	; 255
     d06:	85 e1       	ldi	r24, 0x15	; 21
     d08:	9c d3       	rcall	.+1848   	; 0x1442 <DIO_Pin_Read>
				if (LOW == u8Button_State)
     d0a:	89 81       	ldd	r24, Y+1	; 0x01
     d0c:	81 11       	cpse	r24, r1
     d0e:	06 c0       	rjmp	.+12     	; 0xd1c <Keypad_Get_Key+0x1fe>
				{
					u8Detected_Col = FIRST_COL;
					u8_Detected_Row = SECOND_ROW;
					Gu8_Get_Key_State = TAKE_ACTION;
     d10:	81 e0       	ldi	r24, 0x01	; 1
     d12:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
				DIO_Pin_Write(ROW3,HIGH);
				
				DIO_Pin_Read(COL1,&u8Button_State);
				if (LOW == u8Button_State)
				{
					u8Detected_Col = FIRST_COL;
     d16:	cc 24       	eor	r12, r12
     d18:	c3 94       	inc	r12
     d1a:	7a c0       	rjmp	.+244    	; 0xe10 <Keypad_Get_Key+0x2f2>
					u8_Detected_Row = SECOND_ROW;
					Gu8_Get_Key_State = TAKE_ACTION;
				}
				else
				{
					DIO_Pin_Read(COL2,&u8Button_State);
     d1c:	be 01       	movw	r22, r28
     d1e:	6f 5f       	subi	r22, 0xFF	; 255
     d20:	7f 4f       	sbci	r23, 0xFF	; 255
     d22:	86 e1       	ldi	r24, 0x16	; 22
     d24:	8e d3       	rcall	.+1820   	; 0x1442 <DIO_Pin_Read>
					if (LOW == u8Button_State)
     d26:	89 81       	ldd	r24, Y+1	; 0x01
     d28:	81 11       	cpse	r24, r1
					{
						u8Detected_Col = SECOND_COL;
						u8_Detected_Row = SECOND_ROW;
						Gu8_Get_Key_State = TAKE_ACTION;
     d2a:	07 c0       	rjmp	.+14     	; 0xd3a <Keypad_Get_Key+0x21c>
     d2c:	81 e0       	ldi	r24, 0x01	; 1
				else
				{
					DIO_Pin_Read(COL2,&u8Button_State);
					if (LOW == u8Button_State)
					{
						u8Detected_Col = SECOND_COL;
     d2e:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
     d32:	68 94       	set
     d34:	cc 24       	eor	r12, r12
						u8_Detected_Row = SECOND_ROW;
						Gu8_Get_Key_State = TAKE_ACTION;
					}
					else
					{
						DIO_Pin_Read(COL3,&u8Button_State);
     d36:	c1 f8       	bld	r12, 1
     d38:	6b c0       	rjmp	.+214    	; 0xe10 <Keypad_Get_Key+0x2f2>
     d3a:	be 01       	movw	r22, r28
     d3c:	6f 5f       	subi	r22, 0xFF	; 255
     d3e:	7f 4f       	sbci	r23, 0xFF	; 255
						if (LOW == u8Button_State)
     d40:	87 e1       	ldi	r24, 0x17	; 23
     d42:	7f d3       	rcall	.+1790   	; 0x1442 <DIO_Pin_Read>
     d44:	89 81       	ldd	r24, Y+1	; 0x01
						{
							u8Detected_Col = THIRD_COL;
							u8_Detected_Row = SECOND_ROW;
							Gu8_Get_Key_State = TAKE_ACTION;
     d46:	81 11       	cpse	r24, r1
     d48:	08 c0       	rjmp	.+16     	; 0xd5a <Keypad_Get_Key+0x23c>
     d4a:	81 e0       	ldi	r24, 0x01	; 1
					else
					{
						DIO_Pin_Read(COL3,&u8Button_State);
						if (LOW == u8Button_State)
						{
							u8Detected_Col = THIRD_COL;
     d4c:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
     d50:	0f 2e       	mov	r0, r31
     d52:	f3 e0       	ldi	r31, 0x03	; 3
     d54:	cf 2e       	mov	r12, r31
							u8_Detected_Row = SECOND_ROW;
							Gu8_Get_Key_State = TAKE_ACTION;
						}
						else
						{
							Gu8_Get_Key_State = CHECK;
     d56:	f0 2d       	mov	r31, r0
			{
			}
			
			if (2 == u8Row_index)
			{
				DIO_Pin_Write(ROW3,LOW);
     d58:	5b c0       	rjmp	.+182    	; 0xe10 <Keypad_Get_Key+0x2f2>
     d5a:	10 92 a2 01 	sts	0x01A2, r1	; 0x8001a2 <Gu8_Get_Key_State>
     d5e:	60 e0       	ldi	r22, 0x00	; 0
				DIO_Pin_Write(ROW1,HIGH);
     d60:	84 e1       	ldi	r24, 0x14	; 20
     d62:	1d d2       	rcall	.+1082   	; 0x119e <DIO_Pin_Write>
     d64:	61 e0       	ldi	r22, 0x01	; 1
     d66:	82 e1       	ldi	r24, 0x12	; 18
				DIO_Pin_Write(ROW2,HIGH);
     d68:	1a d2       	rcall	.+1076   	; 0x119e <DIO_Pin_Write>
     d6a:	61 e0       	ldi	r22, 0x01	; 1
     d6c:	83 e1       	ldi	r24, 0x13	; 19
     d6e:	17 d2       	rcall	.+1070   	; 0x119e <DIO_Pin_Write>
				
				DIO_Pin_Read(COL1,&u8Button_State);
     d70:	be 01       	movw	r22, r28
     d72:	6f 5f       	subi	r22, 0xFF	; 255
     d74:	7f 4f       	sbci	r23, 0xFF	; 255
     d76:	85 e1       	ldi	r24, 0x15	; 21
     d78:	64 d3       	rcall	.+1736   	; 0x1442 <DIO_Pin_Read>
     d7a:	89 81       	ldd	r24, Y+1	; 0x01
				if (LOW == u8Button_State)
     d7c:	81 11       	cpse	r24, r1
     d7e:	0a c0       	rjmp	.+20     	; 0xd94 <Keypad_Get_Key+0x276>
				{
					u8Detected_Col = FIRST_COL;
					u8_Detected_Row = THIRD_ROW;
					Gu8_Get_Key_State = TAKE_ACTION;
     d80:	81 e0       	ldi	r24, 0x01	; 1
     d82:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
				DIO_Pin_Write(ROW2,HIGH);
				
				DIO_Pin_Read(COL1,&u8Button_State);
				if (LOW == u8Button_State)
				{
					u8Detected_Col = FIRST_COL;
     d86:	cc 24       	eor	r12, r12
     d88:	c3 94       	inc	r12
					u8_Detected_Row = THIRD_ROW;
     d8a:	0f 2e       	mov	r0, r31
     d8c:	f3 e0       	ldi	r31, 0x03	; 3
     d8e:	df 2e       	mov	r13, r31
     d90:	f0 2d       	mov	r31, r0
     d92:	2b c0       	rjmp	.+86     	; 0xdea <Keypad_Get_Key+0x2cc>
					Gu8_Get_Key_State = TAKE_ACTION;
				}
				else
				{
					DIO_Pin_Read(COL2,&u8Button_State);
     d94:	be 01       	movw	r22, r28
     d96:	6f 5f       	subi	r22, 0xFF	; 255
     d98:	7f 4f       	sbci	r23, 0xFF	; 255
     d9a:	86 e1       	ldi	r24, 0x16	; 22
     d9c:	52 d3       	rcall	.+1700   	; 0x1442 <DIO_Pin_Read>
     d9e:	89 81       	ldd	r24, Y+1	; 0x01
					if (LOW == u8Button_State)
     da0:	81 11       	cpse	r24, r1
     da2:	0b c0       	rjmp	.+22     	; 0xdba <Keypad_Get_Key+0x29c>
     da4:	81 e0       	ldi	r24, 0x01	; 1
					{
						u8Detected_Col = SECOND_COL;
						u8_Detected_Row = THIRD_ROW;
						Gu8_Get_Key_State = TAKE_ACTION;
     da6:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
				else
				{
					DIO_Pin_Read(COL2,&u8Button_State);
					if (LOW == u8Button_State)
					{
						u8Detected_Col = SECOND_COL;
     daa:	68 94       	set
     dac:	cc 24       	eor	r12, r12
						u8_Detected_Row = THIRD_ROW;
     dae:	c1 f8       	bld	r12, 1
     db0:	0f 2e       	mov	r0, r31
     db2:	f3 e0       	ldi	r31, 0x03	; 3
     db4:	df 2e       	mov	r13, r31
						Gu8_Get_Key_State = TAKE_ACTION;
					}
					else
					{
						DIO_Pin_Read(COL3,&u8Button_State);
     db6:	f0 2d       	mov	r31, r0
     db8:	18 c0       	rjmp	.+48     	; 0xdea <Keypad_Get_Key+0x2cc>
     dba:	be 01       	movw	r22, r28
     dbc:	6f 5f       	subi	r22, 0xFF	; 255
     dbe:	7f 4f       	sbci	r23, 0xFF	; 255
     dc0:	87 e1       	ldi	r24, 0x17	; 23
						if (LOW == u8Button_State)
     dc2:	3f d3       	rcall	.+1662   	; 0x1442 <DIO_Pin_Read>
     dc4:	89 81       	ldd	r24, Y+1	; 0x01
     dc6:	81 11       	cpse	r24, r1
						{
							u8Detected_Col = THIRD_COL;
							u8_Detected_Row = THIRD_ROW;
							Gu8_Get_Key_State = TAKE_ACTION;
     dc8:	0c c0       	rjmp	.+24     	; 0xde2 <Keypad_Get_Key+0x2c4>
     dca:	81 e0       	ldi	r24, 0x01	; 1
     dcc:	80 93 a2 01 	sts	0x01A2, r24	; 0x8001a2 <Gu8_Get_Key_State>
					else
					{
						DIO_Pin_Read(COL3,&u8Button_State);
						if (LOW == u8Button_State)
						{
							u8Detected_Col = THIRD_COL;
     dd0:	0f 2e       	mov	r0, r31
     dd2:	f3 e0       	ldi	r31, 0x03	; 3
     dd4:	cf 2e       	mov	r12, r31
							u8_Detected_Row = THIRD_ROW;
     dd6:	f0 2d       	mov	r31, r0
     dd8:	0f 2e       	mov	r0, r31
     dda:	f3 e0       	ldi	r31, 0x03	; 3
     ddc:	df 2e       	mov	r13, r31
     dde:	f0 2d       	mov	r31, r0
							Gu8_Get_Key_State = TAKE_ACTION;
						}
						else
						{
							Gu8_Get_Key_State = CHECK;
     de0:	04 c0       	rjmp	.+8      	; 0xdea <Keypad_Get_Key+0x2cc>
     de2:	10 92 a2 01 	sts	0x01A2, r1	; 0x8001a2 <Gu8_Get_Key_State>
     de6:	c1 2c       	mov	r12, r1
			} 
			else
			{
			}
			
			DIO_Pin_Write(ROW3,HIGH);
     de8:	d1 2c       	mov	r13, r1
     dea:	61 e0       	ldi	r22, 0x01	; 1
     dec:	84 e1       	ldi	r24, 0x14	; 20
     dee:	d7 d1       	rcall	.+942    	; 0x119e <DIO_Pin_Write>
			DIO_Pin_Write(ROW1,HIGH);
     df0:	61 e0       	ldi	r22, 0x01	; 1
     df2:	82 e1       	ldi	r24, 0x12	; 18
     df4:	d4 d1       	rcall	.+936    	; 0x119e <DIO_Pin_Write>
     df6:	61 e0       	ldi	r22, 0x01	; 1
			DIO_Pin_Write(ROW2,HIGH);
     df8:	83 e1       	ldi	r24, 0x13	; 19
     dfa:	d1 d1       	rcall	.+930    	; 0x119e <DIO_Pin_Write>
     dfc:	f8 01       	movw	r30, r16
     dfe:	d0 82       	st	Z, r13
			
			*pu8Row = u8_Detected_Row;
     e00:	f7 01       	movw	r30, r14
     e02:	c0 82       	st	Z, r12
			*pu8Col = u8Detected_Col;
     e04:	80 91 a2 01 	lds	r24, 0x01A2	; 0x8001a2 <Gu8_Get_Key_State>
		}
		
		default:
		break;
	}
	return Gu8_Get_Key_State;
     e08:	07 c0       	rjmp	.+14     	; 0xe18 <Keypad_Get_Key+0x2fa>
     e0a:	dd 24       	eor	r13, r13
     e0c:	d3 94       	inc	r13
	}
	return u8Status;
}

extern Error Keypad_Get_Key(u8* pu8Row,u8* pu8Col)
{
     e0e:	ed cf       	rjmp	.-38     	; 0xdea <Keypad_Get_Key+0x2cc>
     e10:	68 94       	set
     e12:	dd 24       	eor	r13, r13
					{
						DIO_Pin_Read(COL3,&u8Button_State);
						if (LOW == u8Button_State)
						{
							u8Detected_Col = THIRD_COL;
							u8_Detected_Row = THIRD_ROW;
     e14:	d1 f8       	bld	r13, 1
     e16:	e9 cf       	rjmp	.-46     	; 0xdea <Keypad_Get_Key+0x2cc>
     e18:	0f 90       	pop	r0
     e1a:	df 91       	pop	r29
		
		default:
		break;
	}
	return Gu8_Get_Key_State;
     e1c:	cf 91       	pop	r28
     e1e:	1f 91       	pop	r17
     e20:	0f 91       	pop	r16
     e22:	ff 90       	pop	r15
     e24:	ef 90       	pop	r14
     e26:	df 90       	pop	r13
     e28:	cf 90       	pop	r12
     e2a:	08 95       	ret

00000e2c <LCD_Send_Command_Stage1>:
     e2c:	cf 93       	push	r28
     e2e:	c8 2f       	mov	r28, r24
	{
		/* handling of using LCD module before initializing it*/
		u8Execution_indication = LCD_E_NOT_INTIALIZED_YET ;
	}
	return u8Execution_indication;
}
     e30:	60 e0       	ldi	r22, 0x00	; 0
     e32:	83 e0       	ldi	r24, 0x03	; 3
     e34:	b4 d1       	rcall	.+872    	; 0x119e <DIO_Pin_Write>
     e36:	8b b3       	in	r24, 0x1b	; 27
     e38:	8f 70       	andi	r24, 0x0F	; 15
     e3a:	c0 7f       	andi	r28, 0xF0	; 240
     e3c:	c8 2b       	or	r28, r24
     e3e:	cb bb       	out	0x1b, r28	; 27
     e40:	60 e0       	ldi	r22, 0x00	; 0
     e42:	81 e0       	ldi	r24, 0x01	; 1
     e44:	ac d1       	rcall	.+856    	; 0x119e <DIO_Pin_Write>
     e46:	60 e0       	ldi	r22, 0x00	; 0
     e48:	82 e0       	ldi	r24, 0x02	; 2
     e4a:	a9 d1       	rcall	.+850    	; 0x119e <DIO_Pin_Write>
     e4c:	61 e0       	ldi	r22, 0x01	; 1
     e4e:	83 e0       	ldi	r24, 0x03	; 3
     e50:	a6 d1       	rcall	.+844    	; 0x119e <DIO_Pin_Write>
     e52:	80 e1       	ldi	r24, 0x10	; 16
     e54:	8a 95       	dec	r24
     e56:	f1 f7       	brne	.-4      	; 0xe54 <LCD_Send_Command_Stage1+0x28>
     e58:	00 c0       	rjmp	.+0      	; 0xe5a <LCD_Send_Command_Stage1+0x2e>
     e5a:	60 e0       	ldi	r22, 0x00	; 0
     e5c:	83 e0       	ldi	r24, 0x03	; 3
     e5e:	9f d1       	rcall	.+830    	; 0x119e <DIO_Pin_Write>
     e60:	cf 91       	pop	r28
     e62:	08 95       	ret

00000e64 <LCD_Send_Command_Stage2>:
     e64:	82 95       	swap	r24
     e66:	80 7f       	andi	r24, 0xF0	; 240
     e68:	8b bb       	out	0x1b, r24	; 27
     e6a:	61 e0       	ldi	r22, 0x01	; 1
     e6c:	83 e0       	ldi	r24, 0x03	; 3
     e6e:	97 d1       	rcall	.+814    	; 0x119e <DIO_Pin_Write>
     e70:	80 e1       	ldi	r24, 0x10	; 16
     e72:	8a 95       	dec	r24
     e74:	f1 f7       	brne	.-4      	; 0xe72 <LCD_Send_Command_Stage2+0xe>
     e76:	00 c0       	rjmp	.+0      	; 0xe78 <LCD_Send_Command_Stage2+0x14>
     e78:	60 e0       	ldi	r22, 0x00	; 0
     e7a:	83 e0       	ldi	r24, 0x03	; 3
     e7c:	90 c1       	rjmp	.+800    	; 0x119e <DIO_Pin_Write>
     e7e:	08 95       	ret

00000e80 <LCD_Init>:
     e80:	e0 91 a5 01 	lds	r30, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     e84:	8e 2f       	mov	r24, r30
     e86:	90 e0       	ldi	r25, 0x00	; 0
     e88:	8b 30       	cpi	r24, 0x0B	; 11
     e8a:	91 05       	cpc	r25, r1
     e8c:	08 f0       	brcs	.+2      	; 0xe90 <LCD_Init+0x10>
     e8e:	70 c0       	rjmp	.+224    	; 0xf70 <LCD_Init+0xf0>
     e90:	fc 01       	movw	r30, r24
     e92:	e6 5d       	subi	r30, 0xD6	; 214
     e94:	ff 4f       	sbci	r31, 0xFF	; 255
     e96:	0c 94 3e 1a 	jmp	0x347c	; 0x347c <__tablejump2__>
     e9a:	61 e0       	ldi	r22, 0x01	; 1
     e9c:	82 e0       	ldi	r24, 0x02	; 2
     e9e:	28 d2       	rcall	.+1104   	; 0x12f0 <DIO_Pin_Init>
     ea0:	61 e0       	ldi	r22, 0x01	; 1
     ea2:	81 e0       	ldi	r24, 0x01	; 1
     ea4:	25 d2       	rcall	.+1098   	; 0x12f0 <DIO_Pin_Init>
     ea6:	61 e0       	ldi	r22, 0x01	; 1
     ea8:	83 e0       	ldi	r24, 0x03	; 3
     eaa:	22 d2       	rcall	.+1092   	; 0x12f0 <DIO_Pin_Init>
     eac:	61 e0       	ldi	r22, 0x01	; 1
     eae:	84 e0       	ldi	r24, 0x04	; 4
     eb0:	1f d2       	rcall	.+1086   	; 0x12f0 <DIO_Pin_Init>
     eb2:	61 e0       	ldi	r22, 0x01	; 1
     eb4:	85 e0       	ldi	r24, 0x05	; 5
     eb6:	1c d2       	rcall	.+1080   	; 0x12f0 <DIO_Pin_Init>
     eb8:	61 e0       	ldi	r22, 0x01	; 1
     eba:	86 e0       	ldi	r24, 0x06	; 6
     ebc:	19 d2       	rcall	.+1074   	; 0x12f0 <DIO_Pin_Init>
     ebe:	61 e0       	ldi	r22, 0x01	; 1
     ec0:	87 e0       	ldi	r24, 0x07	; 7
     ec2:	16 d2       	rcall	.+1068   	; 0x12f0 <DIO_Pin_Init>
     ec4:	83 e3       	ldi	r24, 0x33	; 51
     ec6:	b2 df       	rcall	.-156    	; 0xe2c <LCD_Send_Command_Stage1>
     ec8:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     ecc:	8f 5f       	subi	r24, 0xFF	; 255
     ece:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     ed2:	4e c0       	rjmp	.+156    	; 0xf70 <LCD_Init+0xf0>
     ed4:	83 e3       	ldi	r24, 0x33	; 51
     ed6:	c6 df       	rcall	.-116    	; 0xe64 <LCD_Send_Command_Stage2>
     ed8:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     edc:	8f 5f       	subi	r24, 0xFF	; 255
     ede:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     ee2:	46 c0       	rjmp	.+140    	; 0xf70 <LCD_Init+0xf0>
     ee4:	82 e3       	ldi	r24, 0x32	; 50
     ee6:	a2 df       	rcall	.-188    	; 0xe2c <LCD_Send_Command_Stage1>
     ee8:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     eec:	8f 5f       	subi	r24, 0xFF	; 255
     eee:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     ef2:	3e c0       	rjmp	.+124    	; 0xf70 <LCD_Init+0xf0>
     ef4:	82 e3       	ldi	r24, 0x32	; 50
     ef6:	b6 df       	rcall	.-148    	; 0xe64 <LCD_Send_Command_Stage2>
     ef8:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     efc:	8f 5f       	subi	r24, 0xFF	; 255
     efe:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     f02:	36 c0       	rjmp	.+108    	; 0xf70 <LCD_Init+0xf0>
     f04:	88 e2       	ldi	r24, 0x28	; 40
     f06:	92 df       	rcall	.-220    	; 0xe2c <LCD_Send_Command_Stage1>
     f08:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     f0c:	8f 5f       	subi	r24, 0xFF	; 255
     f0e:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     f12:	2e c0       	rjmp	.+92     	; 0xf70 <LCD_Init+0xf0>
     f14:	88 e2       	ldi	r24, 0x28	; 40
     f16:	a6 df       	rcall	.-180    	; 0xe64 <LCD_Send_Command_Stage2>
     f18:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     f1c:	8f 5f       	subi	r24, 0xFF	; 255
     f1e:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     f22:	26 c0       	rjmp	.+76     	; 0xf70 <LCD_Init+0xf0>
     f24:	8f e0       	ldi	r24, 0x0F	; 15
     f26:	82 df       	rcall	.-252    	; 0xe2c <LCD_Send_Command_Stage1>
     f28:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     f2c:	8f 5f       	subi	r24, 0xFF	; 255
     f2e:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     f32:	1e c0       	rjmp	.+60     	; 0xf70 <LCD_Init+0xf0>
     f34:	8f e0       	ldi	r24, 0x0F	; 15
     f36:	96 df       	rcall	.-212    	; 0xe64 <LCD_Send_Command_Stage2>
     f38:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     f3c:	8f 5f       	subi	r24, 0xFF	; 255
     f3e:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     f42:	16 c0       	rjmp	.+44     	; 0xf70 <LCD_Init+0xf0>
     f44:	81 e0       	ldi	r24, 0x01	; 1
     f46:	72 df       	rcall	.-284    	; 0xe2c <LCD_Send_Command_Stage1>
     f48:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     f4c:	8f 5f       	subi	r24, 0xFF	; 255
     f4e:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     f52:	0e c0       	rjmp	.+28     	; 0xf70 <LCD_Init+0xf0>
     f54:	81 e0       	ldi	r24, 0x01	; 1
     f56:	86 df       	rcall	.-244    	; 0xe64 <LCD_Send_Command_Stage2>
     f58:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     f5c:	8f 5f       	subi	r24, 0xFF	; 255
     f5e:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     f62:	06 c0       	rjmp	.+12     	; 0xf70 <LCD_Init+0xf0>
     f64:	8b e0       	ldi	r24, 0x0B	; 11
     f66:	80 93 a5 01 	sts	0x01A5, r24	; 0x8001a5 <slu8Init_state.1817>
     f6a:	85 e0       	ldi	r24, 0x05	; 5
     f6c:	80 93 a9 00 	sts	0x00A9, r24	; 0x8000a9 <gu8Is_LCD_initialized>
     f70:	80 91 a5 01 	lds	r24, 0x01A5	; 0x8001a5 <slu8Init_state.1817>
     f74:	08 95       	ret

00000f76 <LCD_Display_Char_Stage1>:
     f76:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <gu8Is_LCD_initialized>
     f7a:	95 30       	cpi	r25, 0x05	; 5
     f7c:	91 f4       	brne	.+36     	; 0xfa2 <LCD_Display_Char_Stage1+0x2c>
     f7e:	9b b3       	in	r25, 0x1b	; 27
     f80:	9f 70       	andi	r25, 0x0F	; 15
     f82:	80 7f       	andi	r24, 0xF0	; 240
     f84:	89 2b       	or	r24, r25
     f86:	8b bb       	out	0x1b, r24	; 27
     f88:	d9 9a       	sbi	0x1b, 1	; 27
     f8a:	61 e0       	ldi	r22, 0x01	; 1
     f8c:	83 e0       	ldi	r24, 0x03	; 3
     f8e:	07 d1       	rcall	.+526    	; 0x119e <DIO_Pin_Write>
     f90:	80 e1       	ldi	r24, 0x10	; 16
     f92:	8a 95       	dec	r24
     f94:	f1 f7       	brne	.-4      	; 0xf92 <LCD_Display_Char_Stage1+0x1c>
     f96:	00 c0       	rjmp	.+0      	; 0xf98 <LCD_Display_Char_Stage1+0x22>
     f98:	60 e0       	ldi	r22, 0x00	; 0
     f9a:	83 e0       	ldi	r24, 0x03	; 3
     f9c:	00 d1       	rcall	.+512    	; 0x119e <DIO_Pin_Write>
     f9e:	80 e0       	ldi	r24, 0x00	; 0
     fa0:	08 95       	ret
     fa2:	84 e0       	ldi	r24, 0x04	; 4
     fa4:	08 95       	ret

00000fa6 <LCD_Display_Char_Stage2>:
     fa6:	30 e1       	ldi	r19, 0x10	; 16
     fa8:	3a 95       	dec	r19
     faa:	f1 f7       	brne	.-4      	; 0xfa8 <LCD_Display_Char_Stage2+0x2>
     fac:	00 c0       	rjmp	.+0      	; 0xfae <LCD_Display_Char_Stage2+0x8>
     fae:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <gu8Is_LCD_initialized>
     fb2:	95 30       	cpi	r25, 0x05	; 5
     fb4:	91 f4       	brne	.+36     	; 0xfda <LCD_Display_Char_Stage2+0x34>
     fb6:	98 2f       	mov	r25, r24
     fb8:	8b b3       	in	r24, 0x1b	; 27
     fba:	28 2f       	mov	r18, r24
     fbc:	2f 70       	andi	r18, 0x0F	; 15
     fbe:	30 e1       	ldi	r19, 0x10	; 16
     fc0:	93 9f       	mul	r25, r19
     fc2:	c0 01       	movw	r24, r0
     fc4:	11 24       	eor	r1, r1
     fc6:	82 2b       	or	r24, r18
     fc8:	8b bb       	out	0x1b, r24	; 27
     fca:	61 e0       	ldi	r22, 0x01	; 1
     fcc:	83 e0       	ldi	r24, 0x03	; 3
     fce:	e7 d0       	rcall	.+462    	; 0x119e <DIO_Pin_Write>
     fd0:	60 e0       	ldi	r22, 0x00	; 0
     fd2:	83 e0       	ldi	r24, 0x03	; 3
     fd4:	e4 d0       	rcall	.+456    	; 0x119e <DIO_Pin_Write>
     fd6:	80 e0       	ldi	r24, 0x00	; 0
     fd8:	08 95       	ret
     fda:	84 e0       	ldi	r24, 0x04	; 4
     fdc:	08 95       	ret

00000fde <LCD_Display_Char>:
     fde:	cf 93       	push	r28
     fe0:	c8 2f       	mov	r28, r24
     fe2:	c9 df       	rcall	.-110    	; 0xf76 <LCD_Display_Char_Stage1>
     fe4:	81 e2       	ldi	r24, 0x21	; 33
     fe6:	8a 95       	dec	r24
     fe8:	f1 f7       	brne	.-4      	; 0xfe6 <LCD_Display_Char+0x8>
     fea:	00 00       	nop
     fec:	8c 2f       	mov	r24, r28
     fee:	db df       	rcall	.-74     	; 0xfa6 <LCD_Display_Char_Stage2>
     ff0:	81 e2       	ldi	r24, 0x21	; 33
     ff2:	8a 95       	dec	r24
     ff4:	f1 f7       	brne	.-4      	; 0xff2 <LCD_Display_Char+0x14>
     ff6:	00 00       	nop
     ff8:	80 e0       	ldi	r24, 0x00	; 0
     ffa:	cf 91       	pop	r28
     ffc:	08 95       	ret

00000ffe <LCD_Clear_Display>:
     ffe:	81 e0       	ldi	r24, 0x01	; 1
    1000:	80 93 a6 01 	sts	0x01A6, r24	; 0x8001a6 <gu8LCD_status>
    1004:	80 91 a9 00 	lds	r24, 0x00A9	; 0x8000a9 <gu8Is_LCD_initialized>
    1008:	85 30       	cpi	r24, 0x05	; 5
    100a:	51 f4       	brne	.+20     	; 0x1020 <LCD_Clear_Display+0x22>
    100c:	81 e0       	ldi	r24, 0x01	; 1
    100e:	0e df       	rcall	.-484    	; 0xe2c <LCD_Send_Command_Stage1>
    1010:	81 e2       	ldi	r24, 0x21	; 33
    1012:	8a 95       	dec	r24
    1014:	f1 f7       	brne	.-4      	; 0x1012 <LCD_Clear_Display+0x14>
    1016:	00 00       	nop
    1018:	81 e0       	ldi	r24, 0x01	; 1
    101a:	24 df       	rcall	.-440    	; 0xe64 <LCD_Send_Command_Stage2>
    101c:	80 e0       	ldi	r24, 0x00	; 0
    101e:	01 c0       	rjmp	.+2      	; 0x1022 <LCD_Clear_Display+0x24>
    1020:	84 e0       	ldi	r24, 0x04	; 4
    1022:	91 e2       	ldi	r25, 0x21	; 33
    1024:	9a 95       	dec	r25
    1026:	f1 f7       	brne	.-4      	; 0x1024 <LCD_Clear_Display+0x26>
    1028:	00 00       	nop
    102a:	08 95       	ret

0000102c <LCD_Display_String>:
    102c:	9c 01       	movw	r18, r24
    102e:	91 e0       	ldi	r25, 0x01	; 1
    1030:	90 93 a6 01 	sts	0x01A6, r25	; 0x8001a6 <gu8LCD_status>
    1034:	90 91 a9 00 	lds	r25, 0x00A9	; 0x8000a9 <gu8Is_LCD_initialized>
    1038:	95 30       	cpi	r25, 0x05	; 5
    103a:	e9 f4       	brne	.+58     	; 0x1076 <LCD_Display_String+0x4a>
    103c:	21 15       	cp	r18, r1
    103e:	31 05       	cpc	r19, r1
    1040:	e1 f0       	breq	.+56     	; 0x107a <LCD_Display_String+0x4e>
    1042:	fa 01       	movw	r30, r20
    1044:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <slu8Count.1860>
    1048:	86 17       	cp	r24, r22
    104a:	60 f4       	brcc	.+24     	; 0x1064 <LCD_Display_String+0x38>
    104c:	f9 01       	movw	r30, r18
    104e:	e8 0f       	add	r30, r24
    1050:	f1 1d       	adc	r31, r1
    1052:	80 81       	ld	r24, Z
    1054:	c4 df       	rcall	.-120    	; 0xfde <LCD_Display_Char>
    1056:	80 91 a4 01 	lds	r24, 0x01A4	; 0x8001a4 <slu8Count.1860>
    105a:	8f 5f       	subi	r24, 0xFF	; 255
    105c:	80 93 a4 01 	sts	0x01A4, r24	; 0x8001a4 <slu8Count.1860>
    1060:	80 e0       	ldi	r24, 0x00	; 0
    1062:	08 95       	ret
    1064:	30 97       	sbiw	r30, 0x00	; 0
    1066:	59 f0       	breq	.+22     	; 0x107e <LCD_Display_String+0x52>
    1068:	09 95       	icall
    106a:	10 92 a6 01 	sts	0x01A6, r1	; 0x8001a6 <gu8LCD_status>
    106e:	10 92 a4 01 	sts	0x01A4, r1	; 0x8001a4 <slu8Count.1860>
    1072:	80 e0       	ldi	r24, 0x00	; 0
    1074:	08 95       	ret
    1076:	84 e0       	ldi	r24, 0x04	; 4
    1078:	08 95       	ret
    107a:	81 e0       	ldi	r24, 0x01	; 1
    107c:	08 95       	ret
    107e:	81 e0       	ldi	r24, 0x01	; 1
    1080:	08 95       	ret

00001082 <LCD_Goto>:

extern Error LCD_Goto(u8 row, u8 col)
{
    1082:	cf 93       	push	r28
	
	uint8_t address;
	switch(row)
    1084:	81 30       	cpi	r24, 0x01	; 1
    1086:	49 f0       	breq	.+18     	; 0x109a <LCD_Goto+0x18>
    1088:	28 f0       	brcs	.+10     	; 0x1094 <LCD_Goto+0x12>
    108a:	82 30       	cpi	r24, 0x02	; 2
    108c:	49 f0       	breq	.+18     	; 0x10a0 <LCD_Goto+0x1e>
    108e:	83 30       	cpi	r24, 0x03	; 3
    1090:	51 f0       	breq	.+20     	; 0x10a6 <LCD_Goto+0x24>
    1092:	0b c0       	rjmp	.+22     	; 0x10aa <LCD_Goto+0x28>
	{
		case 0:
		address = 0x80 + col - 1;
    1094:	cf e7       	ldi	r28, 0x7F	; 127
    1096:	c6 0f       	add	r28, r22
		//OR LCD_sendCommand(0x80).
		break;
    1098:	08 c0       	rjmp	.+16     	; 0x10aa <LCD_Goto+0x28>
		case 1:
		address = 0xC0 + col -1 ;
    109a:	cf eb       	ldi	r28, 0xBF	; 191
    109c:	c6 0f       	add	r28, r22
		//OR LCD_sendCommand(0xC0);
		break;
    109e:	05 c0       	rjmp	.+10     	; 0x10aa <LCD_Goto+0x28>
		case 2:
		address = 0x94 + col - 1;
    10a0:	c3 e9       	ldi	r28, 0x93	; 147
    10a2:	c6 0f       	add	r28, r22
		//OR LCD_sendCommand(0xC0);
		break;
    10a4:	02 c0       	rjmp	.+4      	; 0x10aa <LCD_Goto+0x28>
		case 3:
		address = 0xD4 + col - 1;
    10a6:	c3 ed       	ldi	r28, 0xD3	; 211
    10a8:	c6 0f       	add	r28, r22
		break;
		default:
		break;
		//Nothing.
	}
	LCD_Send_Command_Stage1(address | 0b100000000);
    10aa:	8c 2f       	mov	r24, r28
    10ac:	bf de       	rcall	.-642    	; 0xe2c <LCD_Send_Command_Stage1>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    10ae:	82 e3       	ldi	r24, 0x32	; 50
    10b0:	8a 95       	dec	r24
    10b2:	f1 f7       	brne	.-4      	; 0x10b0 <LCD_Goto+0x2e>
	_delay_us(150);
	LCD_Send_Command_Stage2(address | 0b100000000);
    10b4:	8c 2f       	mov	r24, r28
    10b6:	d6 de       	rcall	.-596    	; 0xe64 <LCD_Send_Command_Stage2>
    10b8:	81 e2       	ldi	r24, 0x21	; 33
    10ba:	8a 95       	dec	r24
    10bc:	f1 f7       	brne	.-4      	; 0x10ba <LCD_Goto+0x38>
    10be:	00 00       	nop
	_delay_us(100);
	return 0;
}
    10c0:	80 e0       	ldi	r24, 0x00	; 0
    10c2:	cf 91       	pop	r28
    10c4:	08 95       	ret

000010c6 <Seven_Segment_Init>:



void Seven_Segment_Init()
{
	DDRD = 0xff;
    10c6:	8f ef       	ldi	r24, 0xFF	; 255
    10c8:	81 bb       	out	0x11, r24	; 17
    10ca:	08 95       	ret

000010cc <Seven_Segment_Write>:
 * @brief Write value inside seven segment.
 * @param au8_port_value 
 */
void Seven_Segment_Write(uint8_t au8_port_value)
{
    PORTD = au8_port_value;
    10cc:	82 bb       	out	0x12, r24	; 18
    10ce:	08 95       	ret

000010d0 <main>:
#define FIFTH_PRIORITY    (uint8_t) 1
#define SIXTH_PRIORITY    (uint8_t) 1


int main(void)
{
    10d0:	ef 92       	push	r14
    10d2:	ff 92       	push	r15
    10d4:	0f 93       	push	r16
    /* Create Tasks. */
    /* Creation of init Task. */
    xTaskCreate (   System_Init_Task,
    10d6:	e1 2c       	mov	r14, r1
    10d8:	f1 2c       	mov	r15, r1
    10da:	04 e0       	ldi	r16, 0x04	; 4
    10dc:	20 e0       	ldi	r18, 0x00	; 0
    10de:	30 e0       	ldi	r19, 0x00	; 0
    10e0:	44 e6       	ldi	r20, 0x64	; 100
    10e2:	50 e0       	ldi	r21, 0x00	; 0
    10e4:	60 e0       	ldi	r22, 0x00	; 0
    10e6:	70 e0       	ldi	r23, 0x00	; 0
    10e8:	8f e7       	ldi	r24, 0x7F	; 127
    10ea:	91 e0       	ldi	r25, 0x01	; 1
    10ec:	0e 94 32 12 	call	0x2464	; 0x2464 <xTaskCreate>
                    NULL,
                    FIRST_PRIORITY,
                    NULL
                );

    xTaskCreate (   Collect_Coins_Task,
    10f0:	0f 2e       	mov	r0, r31
    10f2:	ff e8       	ldi	r31, 0x8F	; 143
    10f4:	ef 2e       	mov	r14, r31
    10f6:	f1 e0       	ldi	r31, 0x01	; 1
    10f8:	ff 2e       	mov	r15, r31
    10fa:	f0 2d       	mov	r31, r0
    10fc:	03 e0       	ldi	r16, 0x03	; 3
    10fe:	20 e0       	ldi	r18, 0x00	; 0
    1100:	30 e0       	ldi	r19, 0x00	; 0
    1102:	4c e3       	ldi	r20, 0x3C	; 60
    1104:	50 e0       	ldi	r21, 0x00	; 0
    1106:	60 e0       	ldi	r22, 0x00	; 0
    1108:	70 e0       	ldi	r23, 0x00	; 0
    110a:	8b e2       	ldi	r24, 0x2B	; 43
    110c:	92 e0       	ldi	r25, 0x02	; 2
    110e:	0e 94 32 12 	call	0x2464	; 0x2464 <xTaskCreate>
                    NULL,
                    SECOND_PRIORITY,
                    &gu8_collect_coins_handle
                );

    xTaskCreate (   Read_Cmd_Task,
    1112:	0f 2e       	mov	r0, r31
    1114:	fd e8       	ldi	r31, 0x8D	; 141
    1116:	ef 2e       	mov	r14, r31
    1118:	f1 e0       	ldi	r31, 0x01	; 1
    111a:	ff 2e       	mov	r15, r31
    111c:	f0 2d       	mov	r31, r0
    111e:	20 e0       	ldi	r18, 0x00	; 0
    1120:	30 e0       	ldi	r19, 0x00	; 0
    1122:	4c e3       	ldi	r20, 0x3C	; 60
    1124:	50 e0       	ldi	r21, 0x00	; 0
    1126:	60 e0       	ldi	r22, 0x00	; 0
    1128:	70 e0       	ldi	r23, 0x00	; 0
    112a:	82 ea       	ldi	r24, 0xA2	; 162
    112c:	92 e0       	ldi	r25, 0x02	; 2
    112e:	0e 94 32 12 	call	0x2464	; 0x2464 <xTaskCreate>
                    NULL,
                    THIRD_PRIORITY,
                   &gu8_read_cmd_handle
                );

   xTaskCreate (   Give_Refund_Task,
    1132:	0f 2e       	mov	r0, r31
    1134:	f9 e8       	ldi	r31, 0x89	; 137
    1136:	ef 2e       	mov	r14, r31
    1138:	f1 e0       	ldi	r31, 0x01	; 1
    113a:	ff 2e       	mov	r15, r31
    113c:	f0 2d       	mov	r31, r0
    113e:	02 e0       	ldi	r16, 0x02	; 2
    1140:	20 e0       	ldi	r18, 0x00	; 0
    1142:	30 e0       	ldi	r19, 0x00	; 0
    1144:	4c e3       	ldi	r20, 0x3C	; 60
    1146:	50 e0       	ldi	r21, 0x00	; 0
    1148:	60 e0       	ldi	r22, 0x00	; 0
    114a:	70 e0       	ldi	r23, 0x00	; 0
    114c:	84 e3       	ldi	r24, 0x34	; 52
    114e:	93 e0       	ldi	r25, 0x03	; 3
    1150:	0e 94 32 12 	call	0x2464	; 0x2464 <xTaskCreate>
                   NULL,
                   FOURTH_PRIORITY,
                   &gu8_give_refund
                );
     
    xTaskCreate (   Deliver_Coffee_Task,
    1154:	e1 2c       	mov	r14, r1
    1156:	f1 2c       	mov	r15, r1
    1158:	01 e0       	ldi	r16, 0x01	; 1
    115a:	20 e0       	ldi	r18, 0x00	; 0
    115c:	30 e0       	ldi	r19, 0x00	; 0
    115e:	4c e3       	ldi	r20, 0x3C	; 60
    1160:	50 e0       	ldi	r21, 0x00	; 0
    1162:	60 e0       	ldi	r22, 0x00	; 0
    1164:	70 e0       	ldi	r23, 0x00	; 0
    1166:	86 e2       	ldi	r24, 0x26	; 38
    1168:	94 e0       	ldi	r25, 0x04	; 4
    116a:	0e 94 32 12 	call	0x2464	; 0x2464 <xTaskCreate>
                    NULL,
                    FIFTH_PRIORITY,
                    NULL
                ); 

    xTaskCreate (   Display_Messages_Task,
    116e:	0f 2e       	mov	r0, r31
    1170:	fb e8       	ldi	r31, 0x8B	; 139
    1172:	ef 2e       	mov	r14, r31
    1174:	f1 e0       	ldi	r31, 0x01	; 1
    1176:	ff 2e       	mov	r15, r31
    1178:	f0 2d       	mov	r31, r0
    117a:	20 e0       	ldi	r18, 0x00	; 0
    117c:	30 e0       	ldi	r19, 0x00	; 0
    117e:	44 e6       	ldi	r20, 0x64	; 100
    1180:	50 e0       	ldi	r21, 0x00	; 0
    1182:	60 e0       	ldi	r22, 0x00	; 0
    1184:	70 e0       	ldi	r23, 0x00	; 0
    1186:	89 eb       	ldi	r24, 0xB9	; 185
    1188:	94 e0       	ldi	r25, 0x04	; 4
    118a:	0e 94 32 12 	call	0x2464	; 0x2464 <xTaskCreate>
                    100,
                    NULL,
                    FIFTH_PRIORITY,
                    &gu8_display_handle
                ); 
    vTaskStartScheduler();
    118e:	0e 94 d4 13 	call	0x27a8	; 0x27a8 <vTaskStartScheduler>
    /* Error Happen Here. */
   
}
    1192:	80 e0       	ldi	r24, 0x00	; 0
    1194:	90 e0       	ldi	r25, 0x00	; 0
    1196:	0f 91       	pop	r16
    1198:	ff 90       	pop	r15
    119a:	ef 90       	pop	r14
    119c:	08 95       	ret

0000119e <DIO_Pin_Write>:
	{
		
	}
	
	return u8Execution_indication ;
}
    119e:	80 32       	cpi	r24, 0x20	; 32
    11a0:	08 f0       	brcs	.+2      	; 0x11a4 <DIO_Pin_Write+0x6>
    11a2:	9e c0       	rjmp	.+316    	; 0x12e0 <DIO_Pin_Write+0x142>
    11a4:	61 11       	cpse	r22, r1
    11a6:	4f c0       	rjmp	.+158    	; 0x1246 <DIO_Pin_Write+0xa8>
    11a8:	88 30       	cpi	r24, 0x08	; 8
    11aa:	80 f4       	brcc	.+32     	; 0x11cc <DIO_Pin_Write+0x2e>
    11ac:	4b b3       	in	r20, 0x1b	; 27
    11ae:	87 70       	andi	r24, 0x07	; 7
    11b0:	21 e0       	ldi	r18, 0x01	; 1
    11b2:	30 e0       	ldi	r19, 0x00	; 0
    11b4:	b9 01       	movw	r22, r18
    11b6:	02 c0       	rjmp	.+4      	; 0x11bc <DIO_Pin_Write+0x1e>
    11b8:	66 0f       	add	r22, r22
    11ba:	77 1f       	adc	r23, r23
    11bc:	8a 95       	dec	r24
    11be:	e2 f7       	brpl	.-8      	; 0x11b8 <DIO_Pin_Write+0x1a>
    11c0:	cb 01       	movw	r24, r22
    11c2:	80 95       	com	r24
    11c4:	84 23       	and	r24, r20
    11c6:	8b bb       	out	0x1b, r24	; 27
    11c8:	80 e0       	ldi	r24, 0x00	; 0
    11ca:	08 95       	ret
    11cc:	98 ef       	ldi	r25, 0xF8	; 248
    11ce:	98 0f       	add	r25, r24
    11d0:	98 30       	cpi	r25, 0x08	; 8
    11d2:	80 f4       	brcc	.+32     	; 0x11f4 <DIO_Pin_Write+0x56>
    11d4:	48 b3       	in	r20, 0x18	; 24
    11d6:	87 70       	andi	r24, 0x07	; 7
    11d8:	21 e0       	ldi	r18, 0x01	; 1
    11da:	30 e0       	ldi	r19, 0x00	; 0
    11dc:	b9 01       	movw	r22, r18
    11de:	02 c0       	rjmp	.+4      	; 0x11e4 <DIO_Pin_Write+0x46>
    11e0:	66 0f       	add	r22, r22
    11e2:	77 1f       	adc	r23, r23
    11e4:	8a 95       	dec	r24
    11e6:	e2 f7       	brpl	.-8      	; 0x11e0 <DIO_Pin_Write+0x42>
    11e8:	cb 01       	movw	r24, r22
    11ea:	80 95       	com	r24
    11ec:	84 23       	and	r24, r20
    11ee:	88 bb       	out	0x18, r24	; 24
    11f0:	80 e0       	ldi	r24, 0x00	; 0
    11f2:	08 95       	ret
    11f4:	90 ef       	ldi	r25, 0xF0	; 240
    11f6:	98 0f       	add	r25, r24
    11f8:	98 30       	cpi	r25, 0x08	; 8
    11fa:	80 f4       	brcc	.+32     	; 0x121c <DIO_Pin_Write+0x7e>
    11fc:	45 b3       	in	r20, 0x15	; 21
    11fe:	87 70       	andi	r24, 0x07	; 7
    1200:	21 e0       	ldi	r18, 0x01	; 1
    1202:	30 e0       	ldi	r19, 0x00	; 0
    1204:	b9 01       	movw	r22, r18
    1206:	02 c0       	rjmp	.+4      	; 0x120c <DIO_Pin_Write+0x6e>
    1208:	66 0f       	add	r22, r22
    120a:	77 1f       	adc	r23, r23
    120c:	8a 95       	dec	r24
    120e:	e2 f7       	brpl	.-8      	; 0x1208 <DIO_Pin_Write+0x6a>
    1210:	cb 01       	movw	r24, r22
    1212:	80 95       	com	r24
    1214:	84 23       	and	r24, r20
    1216:	85 bb       	out	0x15, r24	; 21
    1218:	80 e0       	ldi	r24, 0x00	; 0
    121a:	08 95       	ret
    121c:	98 ee       	ldi	r25, 0xE8	; 232
    121e:	98 0f       	add	r25, r24
    1220:	98 30       	cpi	r25, 0x08	; 8
    1222:	08 f0       	brcs	.+2      	; 0x1226 <DIO_Pin_Write+0x88>
    1224:	5f c0       	rjmp	.+190    	; 0x12e4 <DIO_Pin_Write+0x146>
    1226:	42 b3       	in	r20, 0x12	; 18
    1228:	87 70       	andi	r24, 0x07	; 7
    122a:	21 e0       	ldi	r18, 0x01	; 1
    122c:	30 e0       	ldi	r19, 0x00	; 0
    122e:	b9 01       	movw	r22, r18
    1230:	02 c0       	rjmp	.+4      	; 0x1236 <DIO_Pin_Write+0x98>
    1232:	66 0f       	add	r22, r22
    1234:	77 1f       	adc	r23, r23
    1236:	8a 95       	dec	r24
    1238:	e2 f7       	brpl	.-8      	; 0x1232 <DIO_Pin_Write+0x94>
    123a:	cb 01       	movw	r24, r22
    123c:	80 95       	com	r24
    123e:	84 23       	and	r24, r20
    1240:	82 bb       	out	0x12, r24	; 18
    1242:	80 e0       	ldi	r24, 0x00	; 0
    1244:	08 95       	ret
    1246:	61 30       	cpi	r22, 0x01	; 1
    1248:	09 f0       	breq	.+2      	; 0x124c <DIO_Pin_Write+0xae>
    124a:	4e c0       	rjmp	.+156    	; 0x12e8 <DIO_Pin_Write+0x14a>
    124c:	88 30       	cpi	r24, 0x08	; 8
    124e:	78 f4       	brcc	.+30     	; 0x126e <DIO_Pin_Write+0xd0>
    1250:	4b b3       	in	r20, 0x1b	; 27
    1252:	87 70       	andi	r24, 0x07	; 7
    1254:	21 e0       	ldi	r18, 0x01	; 1
    1256:	30 e0       	ldi	r19, 0x00	; 0
    1258:	b9 01       	movw	r22, r18
    125a:	02 c0       	rjmp	.+4      	; 0x1260 <DIO_Pin_Write+0xc2>
    125c:	66 0f       	add	r22, r22
    125e:	77 1f       	adc	r23, r23
    1260:	8a 95       	dec	r24
    1262:	e2 f7       	brpl	.-8      	; 0x125c <DIO_Pin_Write+0xbe>
    1264:	cb 01       	movw	r24, r22
    1266:	84 2b       	or	r24, r20
    1268:	8b bb       	out	0x1b, r24	; 27
    126a:	80 e0       	ldi	r24, 0x00	; 0
    126c:	08 95       	ret
    126e:	98 ef       	ldi	r25, 0xF8	; 248
    1270:	98 0f       	add	r25, r24
    1272:	98 30       	cpi	r25, 0x08	; 8
    1274:	78 f4       	brcc	.+30     	; 0x1294 <DIO_Pin_Write+0xf6>
    1276:	48 b3       	in	r20, 0x18	; 24
    1278:	87 70       	andi	r24, 0x07	; 7
    127a:	21 e0       	ldi	r18, 0x01	; 1
    127c:	30 e0       	ldi	r19, 0x00	; 0
    127e:	b9 01       	movw	r22, r18
    1280:	02 c0       	rjmp	.+4      	; 0x1286 <DIO_Pin_Write+0xe8>
    1282:	66 0f       	add	r22, r22
    1284:	77 1f       	adc	r23, r23
    1286:	8a 95       	dec	r24
    1288:	e2 f7       	brpl	.-8      	; 0x1282 <DIO_Pin_Write+0xe4>
    128a:	cb 01       	movw	r24, r22
    128c:	84 2b       	or	r24, r20
    128e:	88 bb       	out	0x18, r24	; 24
    1290:	80 e0       	ldi	r24, 0x00	; 0
    1292:	08 95       	ret
    1294:	90 ef       	ldi	r25, 0xF0	; 240
    1296:	98 0f       	add	r25, r24
    1298:	98 30       	cpi	r25, 0x08	; 8
    129a:	78 f4       	brcc	.+30     	; 0x12ba <DIO_Pin_Write+0x11c>
    129c:	45 b3       	in	r20, 0x15	; 21
    129e:	87 70       	andi	r24, 0x07	; 7
    12a0:	21 e0       	ldi	r18, 0x01	; 1
    12a2:	30 e0       	ldi	r19, 0x00	; 0
    12a4:	b9 01       	movw	r22, r18
    12a6:	02 c0       	rjmp	.+4      	; 0x12ac <DIO_Pin_Write+0x10e>
    12a8:	66 0f       	add	r22, r22
    12aa:	77 1f       	adc	r23, r23
    12ac:	8a 95       	dec	r24
    12ae:	e2 f7       	brpl	.-8      	; 0x12a8 <DIO_Pin_Write+0x10a>
    12b0:	cb 01       	movw	r24, r22
    12b2:	84 2b       	or	r24, r20
    12b4:	85 bb       	out	0x15, r24	; 21
    12b6:	80 e0       	ldi	r24, 0x00	; 0
    12b8:	08 95       	ret
    12ba:	98 ee       	ldi	r25, 0xE8	; 232
    12bc:	98 0f       	add	r25, r24
    12be:	98 30       	cpi	r25, 0x08	; 8
    12c0:	a8 f4       	brcc	.+42     	; 0x12ec <DIO_Pin_Write+0x14e>
    12c2:	42 b3       	in	r20, 0x12	; 18
    12c4:	87 70       	andi	r24, 0x07	; 7
    12c6:	21 e0       	ldi	r18, 0x01	; 1
    12c8:	30 e0       	ldi	r19, 0x00	; 0
    12ca:	b9 01       	movw	r22, r18
    12cc:	02 c0       	rjmp	.+4      	; 0x12d2 <DIO_Pin_Write+0x134>
    12ce:	66 0f       	add	r22, r22
    12d0:	77 1f       	adc	r23, r23
    12d2:	8a 95       	dec	r24
    12d4:	e2 f7       	brpl	.-8      	; 0x12ce <DIO_Pin_Write+0x130>
    12d6:	cb 01       	movw	r24, r22
    12d8:	84 2b       	or	r24, r20
    12da:	82 bb       	out	0x12, r24	; 18
    12dc:	80 e0       	ldi	r24, 0x00	; 0
    12de:	08 95       	ret
    12e0:	81 e0       	ldi	r24, 0x01	; 1
    12e2:	08 95       	ret
    12e4:	80 e0       	ldi	r24, 0x00	; 0
    12e6:	08 95       	ret
    12e8:	84 e0       	ldi	r24, 0x04	; 4
    12ea:	08 95       	ret
    12ec:	80 e0       	ldi	r24, 0x00	; 0
    12ee:	08 95       	ret

000012f0 <DIO_Pin_Init>:
    12f0:	80 32       	cpi	r24, 0x20	; 32
    12f2:	08 f0       	brcs	.+2      	; 0x12f6 <DIO_Pin_Init+0x6>
    12f4:	9e c0       	rjmp	.+316    	; 0x1432 <DIO_Pin_Init+0x142>
    12f6:	61 11       	cpse	r22, r1
    12f8:	4f c0       	rjmp	.+158    	; 0x1398 <DIO_Pin_Init+0xa8>
    12fa:	88 30       	cpi	r24, 0x08	; 8
    12fc:	80 f4       	brcc	.+32     	; 0x131e <DIO_Pin_Init+0x2e>
    12fe:	4a b3       	in	r20, 0x1a	; 26
    1300:	87 70       	andi	r24, 0x07	; 7
    1302:	21 e0       	ldi	r18, 0x01	; 1
    1304:	30 e0       	ldi	r19, 0x00	; 0
    1306:	b9 01       	movw	r22, r18
    1308:	02 c0       	rjmp	.+4      	; 0x130e <DIO_Pin_Init+0x1e>
    130a:	66 0f       	add	r22, r22
    130c:	77 1f       	adc	r23, r23
    130e:	8a 95       	dec	r24
    1310:	e2 f7       	brpl	.-8      	; 0x130a <DIO_Pin_Init+0x1a>
    1312:	cb 01       	movw	r24, r22
    1314:	80 95       	com	r24
    1316:	84 23       	and	r24, r20
    1318:	8a bb       	out	0x1a, r24	; 26
    131a:	80 e0       	ldi	r24, 0x00	; 0
    131c:	08 95       	ret
    131e:	98 ef       	ldi	r25, 0xF8	; 248
    1320:	98 0f       	add	r25, r24
    1322:	98 30       	cpi	r25, 0x08	; 8
    1324:	80 f4       	brcc	.+32     	; 0x1346 <DIO_Pin_Init+0x56>
    1326:	47 b3       	in	r20, 0x17	; 23
    1328:	87 70       	andi	r24, 0x07	; 7
    132a:	21 e0       	ldi	r18, 0x01	; 1
    132c:	30 e0       	ldi	r19, 0x00	; 0
    132e:	b9 01       	movw	r22, r18
    1330:	02 c0       	rjmp	.+4      	; 0x1336 <DIO_Pin_Init+0x46>
    1332:	66 0f       	add	r22, r22
    1334:	77 1f       	adc	r23, r23
    1336:	8a 95       	dec	r24
    1338:	e2 f7       	brpl	.-8      	; 0x1332 <DIO_Pin_Init+0x42>
    133a:	cb 01       	movw	r24, r22
    133c:	80 95       	com	r24
    133e:	84 23       	and	r24, r20
    1340:	87 bb       	out	0x17, r24	; 23
    1342:	80 e0       	ldi	r24, 0x00	; 0
    1344:	08 95       	ret
    1346:	90 ef       	ldi	r25, 0xF0	; 240
    1348:	98 0f       	add	r25, r24
    134a:	98 30       	cpi	r25, 0x08	; 8
    134c:	80 f4       	brcc	.+32     	; 0x136e <DIO_Pin_Init+0x7e>
    134e:	44 b3       	in	r20, 0x14	; 20
    1350:	87 70       	andi	r24, 0x07	; 7
    1352:	21 e0       	ldi	r18, 0x01	; 1
    1354:	30 e0       	ldi	r19, 0x00	; 0
    1356:	b9 01       	movw	r22, r18
    1358:	02 c0       	rjmp	.+4      	; 0x135e <DIO_Pin_Init+0x6e>
    135a:	66 0f       	add	r22, r22
    135c:	77 1f       	adc	r23, r23
    135e:	8a 95       	dec	r24
    1360:	e2 f7       	brpl	.-8      	; 0x135a <DIO_Pin_Init+0x6a>
    1362:	cb 01       	movw	r24, r22
    1364:	80 95       	com	r24
    1366:	84 23       	and	r24, r20
    1368:	84 bb       	out	0x14, r24	; 20
    136a:	80 e0       	ldi	r24, 0x00	; 0
    136c:	08 95       	ret
    136e:	98 ee       	ldi	r25, 0xE8	; 232
    1370:	98 0f       	add	r25, r24
    1372:	98 30       	cpi	r25, 0x08	; 8
    1374:	08 f0       	brcs	.+2      	; 0x1378 <DIO_Pin_Init+0x88>
    1376:	5f c0       	rjmp	.+190    	; 0x1436 <DIO_Pin_Init+0x146>
    1378:	41 b3       	in	r20, 0x11	; 17
    137a:	87 70       	andi	r24, 0x07	; 7
    137c:	21 e0       	ldi	r18, 0x01	; 1
    137e:	30 e0       	ldi	r19, 0x00	; 0
    1380:	b9 01       	movw	r22, r18
    1382:	02 c0       	rjmp	.+4      	; 0x1388 <DIO_Pin_Init+0x98>
    1384:	66 0f       	add	r22, r22
    1386:	77 1f       	adc	r23, r23
    1388:	8a 95       	dec	r24
    138a:	e2 f7       	brpl	.-8      	; 0x1384 <DIO_Pin_Init+0x94>
    138c:	cb 01       	movw	r24, r22
    138e:	80 95       	com	r24
    1390:	84 23       	and	r24, r20
    1392:	81 bb       	out	0x11, r24	; 17
    1394:	80 e0       	ldi	r24, 0x00	; 0
    1396:	08 95       	ret
    1398:	61 30       	cpi	r22, 0x01	; 1
    139a:	09 f0       	breq	.+2      	; 0x139e <DIO_Pin_Init+0xae>
    139c:	4e c0       	rjmp	.+156    	; 0x143a <DIO_Pin_Init+0x14a>
    139e:	88 30       	cpi	r24, 0x08	; 8
    13a0:	78 f4       	brcc	.+30     	; 0x13c0 <DIO_Pin_Init+0xd0>
    13a2:	4a b3       	in	r20, 0x1a	; 26
    13a4:	87 70       	andi	r24, 0x07	; 7
    13a6:	21 e0       	ldi	r18, 0x01	; 1
    13a8:	30 e0       	ldi	r19, 0x00	; 0
    13aa:	b9 01       	movw	r22, r18
    13ac:	02 c0       	rjmp	.+4      	; 0x13b2 <DIO_Pin_Init+0xc2>
    13ae:	66 0f       	add	r22, r22
    13b0:	77 1f       	adc	r23, r23
    13b2:	8a 95       	dec	r24
    13b4:	e2 f7       	brpl	.-8      	; 0x13ae <DIO_Pin_Init+0xbe>
    13b6:	cb 01       	movw	r24, r22
    13b8:	84 2b       	or	r24, r20
    13ba:	8a bb       	out	0x1a, r24	; 26
    13bc:	80 e0       	ldi	r24, 0x00	; 0
    13be:	08 95       	ret
    13c0:	98 ef       	ldi	r25, 0xF8	; 248
    13c2:	98 0f       	add	r25, r24
    13c4:	98 30       	cpi	r25, 0x08	; 8
    13c6:	78 f4       	brcc	.+30     	; 0x13e6 <DIO_Pin_Init+0xf6>
    13c8:	47 b3       	in	r20, 0x17	; 23
    13ca:	87 70       	andi	r24, 0x07	; 7
    13cc:	21 e0       	ldi	r18, 0x01	; 1
    13ce:	30 e0       	ldi	r19, 0x00	; 0
    13d0:	b9 01       	movw	r22, r18
    13d2:	02 c0       	rjmp	.+4      	; 0x13d8 <DIO_Pin_Init+0xe8>
    13d4:	66 0f       	add	r22, r22
    13d6:	77 1f       	adc	r23, r23
    13d8:	8a 95       	dec	r24
    13da:	e2 f7       	brpl	.-8      	; 0x13d4 <DIO_Pin_Init+0xe4>
    13dc:	cb 01       	movw	r24, r22
    13de:	84 2b       	or	r24, r20
    13e0:	87 bb       	out	0x17, r24	; 23
    13e2:	80 e0       	ldi	r24, 0x00	; 0
    13e4:	08 95       	ret
    13e6:	90 ef       	ldi	r25, 0xF0	; 240
    13e8:	98 0f       	add	r25, r24
    13ea:	98 30       	cpi	r25, 0x08	; 8
    13ec:	78 f4       	brcc	.+30     	; 0x140c <DIO_Pin_Init+0x11c>
    13ee:	44 b3       	in	r20, 0x14	; 20
    13f0:	87 70       	andi	r24, 0x07	; 7
    13f2:	21 e0       	ldi	r18, 0x01	; 1
    13f4:	30 e0       	ldi	r19, 0x00	; 0
    13f6:	b9 01       	movw	r22, r18
    13f8:	02 c0       	rjmp	.+4      	; 0x13fe <DIO_Pin_Init+0x10e>
    13fa:	66 0f       	add	r22, r22
    13fc:	77 1f       	adc	r23, r23
    13fe:	8a 95       	dec	r24
    1400:	e2 f7       	brpl	.-8      	; 0x13fa <DIO_Pin_Init+0x10a>
    1402:	cb 01       	movw	r24, r22
    1404:	84 2b       	or	r24, r20
    1406:	84 bb       	out	0x14, r24	; 20
    1408:	80 e0       	ldi	r24, 0x00	; 0
    140a:	08 95       	ret
    140c:	98 ee       	ldi	r25, 0xE8	; 232
    140e:	98 0f       	add	r25, r24
    1410:	98 30       	cpi	r25, 0x08	; 8
    1412:	a8 f4       	brcc	.+42     	; 0x143e <DIO_Pin_Init+0x14e>
    1414:	41 b3       	in	r20, 0x11	; 17
    1416:	87 70       	andi	r24, 0x07	; 7
    1418:	21 e0       	ldi	r18, 0x01	; 1
    141a:	30 e0       	ldi	r19, 0x00	; 0
    141c:	b9 01       	movw	r22, r18
    141e:	02 c0       	rjmp	.+4      	; 0x1424 <DIO_Pin_Init+0x134>
    1420:	66 0f       	add	r22, r22
    1422:	77 1f       	adc	r23, r23
    1424:	8a 95       	dec	r24
    1426:	e2 f7       	brpl	.-8      	; 0x1420 <DIO_Pin_Init+0x130>
    1428:	cb 01       	movw	r24, r22
    142a:	84 2b       	or	r24, r20
    142c:	81 bb       	out	0x11, r24	; 17
    142e:	80 e0       	ldi	r24, 0x00	; 0
    1430:	08 95       	ret
    1432:	81 e0       	ldi	r24, 0x01	; 1
    1434:	08 95       	ret
    1436:	80 e0       	ldi	r24, 0x00	; 0
    1438:	08 95       	ret
    143a:	83 e0       	ldi	r24, 0x03	; 3
    143c:	08 95       	ret
    143e:	80 e0       	ldi	r24, 0x00	; 0
    1440:	08 95       	ret

00001442 <DIO_Pin_Read>:
    1442:	80 32       	cpi	r24, 0x20	; 32
    1444:	08 f0       	brcs	.+2      	; 0x1448 <DIO_Pin_Read+0x6>
    1446:	50 c0       	rjmp	.+160    	; 0x14e8 <DIO_Pin_Read+0xa6>
    1448:	61 15       	cp	r22, r1
    144a:	71 05       	cpc	r23, r1
    144c:	09 f4       	brne	.+2      	; 0x1450 <DIO_Pin_Read+0xe>
    144e:	4e c0       	rjmp	.+156    	; 0x14ec <DIO_Pin_Read+0xaa>
    1450:	88 30       	cpi	r24, 0x08	; 8
    1452:	68 f4       	brcc	.+26     	; 0x146e <DIO_Pin_Read+0x2c>
    1454:	49 b3       	in	r20, 0x19	; 25
    1456:	87 70       	andi	r24, 0x07	; 7
    1458:	21 e0       	ldi	r18, 0x01	; 1
    145a:	30 e0       	ldi	r19, 0x00	; 0
    145c:	f9 01       	movw	r30, r18
    145e:	02 c0       	rjmp	.+4      	; 0x1464 <DIO_Pin_Read+0x22>
    1460:	ee 0f       	add	r30, r30
    1462:	ff 1f       	adc	r31, r31
    1464:	8a 95       	dec	r24
    1466:	e2 f7       	brpl	.-8      	; 0x1460 <DIO_Pin_Read+0x1e>
    1468:	cf 01       	movw	r24, r30
    146a:	84 23       	and	r24, r20
    146c:	32 c0       	rjmp	.+100    	; 0x14d2 <DIO_Pin_Read+0x90>
    146e:	98 ef       	ldi	r25, 0xF8	; 248
    1470:	98 0f       	add	r25, r24
    1472:	98 30       	cpi	r25, 0x08	; 8
    1474:	68 f4       	brcc	.+26     	; 0x1490 <DIO_Pin_Read+0x4e>
    1476:	46 b3       	in	r20, 0x16	; 22
    1478:	87 70       	andi	r24, 0x07	; 7
    147a:	21 e0       	ldi	r18, 0x01	; 1
    147c:	30 e0       	ldi	r19, 0x00	; 0
    147e:	f9 01       	movw	r30, r18
    1480:	02 c0       	rjmp	.+4      	; 0x1486 <DIO_Pin_Read+0x44>
    1482:	ee 0f       	add	r30, r30
    1484:	ff 1f       	adc	r31, r31
    1486:	8a 95       	dec	r24
    1488:	e2 f7       	brpl	.-8      	; 0x1482 <DIO_Pin_Read+0x40>
    148a:	cf 01       	movw	r24, r30
    148c:	84 23       	and	r24, r20
    148e:	21 c0       	rjmp	.+66     	; 0x14d2 <DIO_Pin_Read+0x90>
    1490:	90 ef       	ldi	r25, 0xF0	; 240
    1492:	98 0f       	add	r25, r24
    1494:	98 30       	cpi	r25, 0x08	; 8
    1496:	68 f4       	brcc	.+26     	; 0x14b2 <DIO_Pin_Read+0x70>
    1498:	43 b3       	in	r20, 0x13	; 19
    149a:	87 70       	andi	r24, 0x07	; 7
    149c:	21 e0       	ldi	r18, 0x01	; 1
    149e:	30 e0       	ldi	r19, 0x00	; 0
    14a0:	f9 01       	movw	r30, r18
    14a2:	02 c0       	rjmp	.+4      	; 0x14a8 <DIO_Pin_Read+0x66>
    14a4:	ee 0f       	add	r30, r30
    14a6:	ff 1f       	adc	r31, r31
    14a8:	8a 95       	dec	r24
    14aa:	e2 f7       	brpl	.-8      	; 0x14a4 <DIO_Pin_Read+0x62>
    14ac:	cf 01       	movw	r24, r30
    14ae:	84 23       	and	r24, r20
    14b0:	10 c0       	rjmp	.+32     	; 0x14d2 <DIO_Pin_Read+0x90>
    14b2:	98 ee       	ldi	r25, 0xE8	; 232
    14b4:	98 0f       	add	r25, r24
    14b6:	98 30       	cpi	r25, 0x08	; 8
    14b8:	98 f4       	brcc	.+38     	; 0x14e0 <DIO_Pin_Read+0x9e>
    14ba:	40 b3       	in	r20, 0x10	; 16
    14bc:	87 70       	andi	r24, 0x07	; 7
    14be:	21 e0       	ldi	r18, 0x01	; 1
    14c0:	30 e0       	ldi	r19, 0x00	; 0
    14c2:	f9 01       	movw	r30, r18
    14c4:	02 c0       	rjmp	.+4      	; 0x14ca <DIO_Pin_Read+0x88>
    14c6:	ee 0f       	add	r30, r30
    14c8:	ff 1f       	adc	r31, r31
    14ca:	8a 95       	dec	r24
    14cc:	e2 f7       	brpl	.-8      	; 0x14c6 <DIO_Pin_Read+0x84>
    14ce:	cf 01       	movw	r24, r30
    14d0:	84 23       	and	r24, r20
    14d2:	88 23       	and	r24, r24
    14d4:	29 f0       	breq	.+10     	; 0x14e0 <DIO_Pin_Read+0x9e>
    14d6:	81 e0       	ldi	r24, 0x01	; 1
    14d8:	fb 01       	movw	r30, r22
    14da:	80 83       	st	Z, r24
    14dc:	80 e0       	ldi	r24, 0x00	; 0
    14de:	08 95       	ret
    14e0:	fb 01       	movw	r30, r22
    14e2:	10 82       	st	Z, r1
    14e4:	80 e0       	ldi	r24, 0x00	; 0
    14e6:	08 95       	ret
    14e8:	81 e0       	ldi	r24, 0x01	; 1
    14ea:	08 95       	ret
    14ec:	86 e0       	ldi	r24, 0x06	; 6
    14ee:	08 95       	ret

000014f0 <DIO_Pin_Activate_pull_up>:
    14f0:	61 e0       	ldi	r22, 0x01	; 1
    14f2:	55 de       	rcall	.-854    	; 0x119e <DIO_Pin_Write>
    14f4:	81 11       	cpse	r24, r1
    14f6:	85 e0       	ldi	r24, 0x05	; 5
    14f8:	08 95       	ret

000014fa <DIO_Pin_Toggle>:
	Error u8Execution_indication  = DIO_E_OK ;

	/*
	*	Making sure that the input pin number is in range
	*/
	if (u8Pin_number < MAX_PINS) 
    14fa:	80 32       	cpi	r24, 0x20	; 32
    14fc:	08 f0       	brcs	.+2      	; 0x1500 <DIO_Pin_Toggle+0x6>
    14fe:	4a c0       	rjmp	.+148    	; 0x1594 <DIO_Pin_Toggle+0x9a>
	{
		if(u8Pin_number >= 0 && u8Pin_number < 8u)     
    1500:	88 30       	cpi	r24, 0x08	; 8
    1502:	78 f4       	brcc	.+30     	; 0x1522 <DIO_Pin_Toggle+0x28>
		{
			PORT_A ^=  (1u << (u8Pin_number%BITS_PER_REGISTER)) ;
    1504:	4b b3       	in	r20, 0x1b	; 27
    1506:	87 70       	andi	r24, 0x07	; 7
    1508:	21 e0       	ldi	r18, 0x01	; 1
    150a:	30 e0       	ldi	r19, 0x00	; 0
    150c:	b9 01       	movw	r22, r18
    150e:	02 c0       	rjmp	.+4      	; 0x1514 <DIO_Pin_Toggle+0x1a>
    1510:	66 0f       	add	r22, r22
    1512:	77 1f       	adc	r23, r23
    1514:	8a 95       	dec	r24
    1516:	e2 f7       	brpl	.-8      	; 0x1510 <DIO_Pin_Toggle+0x16>
    1518:	cb 01       	movw	r24, r22
    151a:	84 27       	eor	r24, r20
    151c:	8b bb       	out	0x1b, r24	; 27
extern Error DIO_Pin_Toggle(uint8_t u8Pin_number) 
{
	/*
	*	The variable that will hold the indication of the execution
	*/
	Error u8Execution_indication  = DIO_E_OK ;
    151e:	80 e0       	ldi	r24, 0x00	; 0
    1520:	08 95       	ret
	{
		if(u8Pin_number >= 0 && u8Pin_number < 8u)     
		{
			PORT_A ^=  (1u << (u8Pin_number%BITS_PER_REGISTER)) ;
		}
		else if (u8Pin_number >= 8u && u8Pin_number < 16u)    
    1522:	98 ef       	ldi	r25, 0xF8	; 248
    1524:	98 0f       	add	r25, r24
    1526:	98 30       	cpi	r25, 0x08	; 8
    1528:	78 f4       	brcc	.+30     	; 0x1548 <DIO_Pin_Toggle+0x4e>
		{
			PORT_B ^=  (1u << (u8Pin_number%BITS_PER_REGISTER)) ;
    152a:	48 b3       	in	r20, 0x18	; 24
    152c:	87 70       	andi	r24, 0x07	; 7
    152e:	21 e0       	ldi	r18, 0x01	; 1
    1530:	30 e0       	ldi	r19, 0x00	; 0
    1532:	b9 01       	movw	r22, r18
    1534:	02 c0       	rjmp	.+4      	; 0x153a <DIO_Pin_Toggle+0x40>
    1536:	66 0f       	add	r22, r22
    1538:	77 1f       	adc	r23, r23
    153a:	8a 95       	dec	r24
    153c:	e2 f7       	brpl	.-8      	; 0x1536 <DIO_Pin_Toggle+0x3c>
    153e:	cb 01       	movw	r24, r22
    1540:	84 27       	eor	r24, r20
    1542:	88 bb       	out	0x18, r24	; 24
extern Error DIO_Pin_Toggle(uint8_t u8Pin_number) 
{
	/*
	*	The variable that will hold the indication of the execution
	*/
	Error u8Execution_indication  = DIO_E_OK ;
    1544:	80 e0       	ldi	r24, 0x00	; 0
    1546:	08 95       	ret
		}
		else if (u8Pin_number >= 8u && u8Pin_number < 16u)    
		{
			PORT_B ^=  (1u << (u8Pin_number%BITS_PER_REGISTER)) ;
		}
		else if(u8Pin_number >= 16u && u8Pin_number < 24u)    
    1548:	90 ef       	ldi	r25, 0xF0	; 240
    154a:	98 0f       	add	r25, r24
    154c:	98 30       	cpi	r25, 0x08	; 8
    154e:	78 f4       	brcc	.+30     	; 0x156e <DIO_Pin_Toggle+0x74>
		{
			PORT_C ^=  (1u << (u8Pin_number%BITS_PER_REGISTER)) ;
    1550:	45 b3       	in	r20, 0x15	; 21
    1552:	87 70       	andi	r24, 0x07	; 7
    1554:	21 e0       	ldi	r18, 0x01	; 1
    1556:	30 e0       	ldi	r19, 0x00	; 0
    1558:	b9 01       	movw	r22, r18
    155a:	02 c0       	rjmp	.+4      	; 0x1560 <DIO_Pin_Toggle+0x66>
    155c:	66 0f       	add	r22, r22
    155e:	77 1f       	adc	r23, r23
    1560:	8a 95       	dec	r24
    1562:	e2 f7       	brpl	.-8      	; 0x155c <DIO_Pin_Toggle+0x62>
    1564:	cb 01       	movw	r24, r22
    1566:	84 27       	eor	r24, r20
    1568:	85 bb       	out	0x15, r24	; 21
extern Error DIO_Pin_Toggle(uint8_t u8Pin_number) 
{
	/*
	*	The variable that will hold the indication of the execution
	*/
	Error u8Execution_indication  = DIO_E_OK ;
    156a:	80 e0       	ldi	r24, 0x00	; 0
    156c:	08 95       	ret
		}
		else if(u8Pin_number >= 16u && u8Pin_number < 24u)    
		{
			PORT_C ^=  (1u << (u8Pin_number%BITS_PER_REGISTER)) ;
		}
		else if(u8Pin_number >= 24u && u8Pin_number < 32u)    
    156e:	98 ee       	ldi	r25, 0xE8	; 232
    1570:	98 0f       	add	r25, r24
    1572:	98 30       	cpi	r25, 0x08	; 8
    1574:	88 f4       	brcc	.+34     	; 0x1598 <DIO_Pin_Toggle+0x9e>
		{
			PORT_D ^=  (1u << (u8Pin_number%BITS_PER_REGISTER)) ;
    1576:	42 b3       	in	r20, 0x12	; 18
    1578:	87 70       	andi	r24, 0x07	; 7
    157a:	21 e0       	ldi	r18, 0x01	; 1
    157c:	30 e0       	ldi	r19, 0x00	; 0
    157e:	b9 01       	movw	r22, r18
    1580:	02 c0       	rjmp	.+4      	; 0x1586 <DIO_Pin_Toggle+0x8c>
    1582:	66 0f       	add	r22, r22
    1584:	77 1f       	adc	r23, r23
    1586:	8a 95       	dec	r24
    1588:	e2 f7       	brpl	.-8      	; 0x1582 <DIO_Pin_Toggle+0x88>
    158a:	cb 01       	movw	r24, r22
    158c:	84 27       	eor	r24, r20
    158e:	82 bb       	out	0x12, r24	; 18
extern Error DIO_Pin_Toggle(uint8_t u8Pin_number) 
{
	/*
	*	The variable that will hold the indication of the execution
	*/
	Error u8Execution_indication  = DIO_E_OK ;
    1590:	80 e0       	ldi	r24, 0x00	; 0
    1592:	08 95       	ret
		}
	}
	else
	{
		/*Handling of entering wrong pin number*/
		u8Execution_indication = DIO_E_WRONG_PIN_NUMBER ;
    1594:	81 e0       	ldi	r24, 0x01	; 1
    1596:	08 95       	ret
extern Error DIO_Pin_Toggle(uint8_t u8Pin_number) 
{
	/*
	*	The variable that will hold the indication of the execution
	*/
	Error u8Execution_indication  = DIO_E_OK ;
    1598:	80 e0       	ldi	r24, 0x00	; 0
	{
		/*Handling of entering wrong pin number*/
		u8Execution_indication = DIO_E_WRONG_PIN_NUMBER ;
	}
	return u8Execution_indication ;
    159a:	08 95       	ret

0000159c <INT_Init>:
void __vector_2(void)__attribute((signal,used,externally_visible));
void __vector_3(void)__attribute((signal,used,externally_visible));


void INT_Init(INT_CFG_S *INT_cfg)
{
    159c:	cf 93       	push	r28
    159e:	df 93       	push	r29
    15a0:	ec 01       	movw	r28, r24
	CLEAR_BIT(SREG,7);
    15a2:	8f b7       	in	r24, 0x3f	; 63
    15a4:	8f 77       	andi	r24, 0x7F	; 127
    15a6:	8f bf       	out	0x3f, r24	; 63
	if(INT_cfg->u8_int_channel == INT_0)
    15a8:	88 81       	ld	r24, Y
    15aa:	81 11       	cpse	r24, r1
    15ac:	0c c0       	rjmp	.+24     	; 0x15c6 <INT_Init+0x2a>
	{
		DIO_Pin_Init(D2,LOW);
    15ae:	60 e0       	ldi	r22, 0x00	; 0
    15b0:	8a e1       	ldi	r24, 0x1A	; 26
    15b2:	9e de       	rcall	.-708    	; 0x12f0 <DIO_Pin_Init>
		GICR|=(1<<INT0);
    15b4:	8b b7       	in	r24, 0x3b	; 59
    15b6:	80 64       	ori	r24, 0x40	; 64
    15b8:	8b bf       	out	0x3b, r24	; 59
		MCUCR = (MCUCR&0xFC) |INT_cfg->u8_int_sense;
    15ba:	85 b7       	in	r24, 0x35	; 53
    15bc:	8c 7f       	andi	r24, 0xFC	; 252
    15be:	99 81       	ldd	r25, Y+1	; 0x01
    15c0:	89 2b       	or	r24, r25
    15c2:	85 bf       	out	0x35, r24	; 53
    15c4:	1b c0       	rjmp	.+54     	; 0x15fc <INT_Init+0x60>
	}
	else if(INT_cfg->u8_int_channel == INT_1)
    15c6:	81 30       	cpi	r24, 0x01	; 1
    15c8:	61 f4       	brne	.+24     	; 0x15e2 <INT_Init+0x46>
	{
		DIO_Pin_Init(D3,LOW);
    15ca:	60 e0       	ldi	r22, 0x00	; 0
    15cc:	8b e1       	ldi	r24, 0x1B	; 27
    15ce:	90 de       	rcall	.-736    	; 0x12f0 <DIO_Pin_Init>
		GICR|=(1<<INT1);
    15d0:	8b b7       	in	r24, 0x3b	; 59
    15d2:	80 68       	ori	r24, 0x80	; 128
    15d4:	8b bf       	out	0x3b, r24	; 59
		MCUCR = (MCUCR&0xF3) |INT_cfg->u8_int_sense;
    15d6:	85 b7       	in	r24, 0x35	; 53
    15d8:	83 7f       	andi	r24, 0xF3	; 243
    15da:	99 81       	ldd	r25, Y+1	; 0x01
    15dc:	89 2b       	or	r24, r25
    15de:	85 bf       	out	0x35, r24	; 53
    15e0:	0d c0       	rjmp	.+26     	; 0x15fc <INT_Init+0x60>

	}
	else if(INT_cfg->u8_int_channel == INT_2)
    15e2:	82 30       	cpi	r24, 0x02	; 2
    15e4:	59 f4       	brne	.+22     	; 0x15fc <INT_Init+0x60>
	{
		DIO_Pin_Init(B2,LOW);
    15e6:	60 e0       	ldi	r22, 0x00	; 0
    15e8:	8a e0       	ldi	r24, 0x0A	; 10
    15ea:	82 de       	rcall	.-764    	; 0x12f0 <DIO_Pin_Init>
		GICR|=(1<<INT2);
    15ec:	8b b7       	in	r24, 0x3b	; 59
    15ee:	80 62       	ori	r24, 0x20	; 32
    15f0:	8b bf       	out	0x3b, r24	; 59
		MCUCSR = (MCUCSR&0xBF) |INT_cfg->u8_int_sense;
    15f2:	84 b7       	in	r24, 0x34	; 52
    15f4:	8f 7b       	andi	r24, 0xBF	; 191
    15f6:	99 81       	ldd	r25, Y+1	; 0x01
    15f8:	89 2b       	or	r24, r25
    15fa:	84 bf       	out	0x34, r24	; 52
	}
	else
	{

	}
	SET_BIT(SREG,7);
    15fc:	8f b7       	in	r24, 0x3f	; 63
    15fe:	80 68       	ori	r24, 0x80	; 128
    1600:	8f bf       	out	0x3f, r24	; 63
}
    1602:	df 91       	pop	r29
    1604:	cf 91       	pop	r28
    1606:	08 95       	ret

00001608 <prvInsertBlockIntoFreeList>:
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
}
/*-----------------------------------------------------------*/

static void prvInsertBlockIntoFreeList( BlockLink_t *pxBlockToInsert )
{
    1608:	cf 93       	push	r28
    160a:	df 93       	push	r29
    160c:	dc 01       	movw	r26, r24
BlockLink_t *pxIterator;
uint8_t *puc;

	/* Iterate through the list until a block is found that has a higher address
	than the block being inserted. */
	for( pxIterator = &xStart; pxIterator->pxNextFreeBlock < pxBlockToInsert; pxIterator = pxIterator->pxNextFreeBlock )
    160e:	ef ea       	ldi	r30, 0xAF	; 175
    1610:	f1 e0       	ldi	r31, 0x01	; 1
    1612:	01 c0       	rjmp	.+2      	; 0x1616 <prvInsertBlockIntoFreeList+0xe>
    1614:	f9 01       	movw	r30, r18
    1616:	20 81       	ld	r18, Z
    1618:	31 81       	ldd	r19, Z+1	; 0x01
    161a:	2a 17       	cp	r18, r26
    161c:	3b 07       	cpc	r19, r27
    161e:	d0 f3       	brcs	.-12     	; 0x1614 <prvInsertBlockIntoFreeList+0xc>
	}

	/* Do the block being inserted, and the block it is being inserted after
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxIterator;
	if( ( puc + pxIterator->xBlockSize ) == ( uint8_t * ) pxBlockToInsert )
    1620:	82 81       	ldd	r24, Z+2	; 0x02
    1622:	93 81       	ldd	r25, Z+3	; 0x03
    1624:	af 01       	movw	r20, r30
    1626:	48 0f       	add	r20, r24
    1628:	59 1f       	adc	r21, r25
    162a:	a4 17       	cp	r26, r20
    162c:	b5 07       	cpc	r27, r21
    162e:	49 f4       	brne	.+18     	; 0x1642 <prvInsertBlockIntoFreeList+0x3a>
	{
		pxIterator->xBlockSize += pxBlockToInsert->xBlockSize;
    1630:	12 96       	adiw	r26, 0x02	; 2
    1632:	4d 91       	ld	r20, X+
    1634:	5c 91       	ld	r21, X
    1636:	13 97       	sbiw	r26, 0x03	; 3
    1638:	84 0f       	add	r24, r20
    163a:	95 1f       	adc	r25, r21
    163c:	93 83       	std	Z+3, r25	; 0x03
    163e:	82 83       	std	Z+2, r24	; 0x02
    1640:	df 01       	movw	r26, r30
	}

	/* Do the block being inserted, and the block it is being inserted before
	make a contiguous block of memory? */
	puc = ( uint8_t * ) pxBlockToInsert;
	if( ( puc + pxBlockToInsert->xBlockSize ) == ( uint8_t * ) pxIterator->pxNextFreeBlock )
    1642:	12 96       	adiw	r26, 0x02	; 2
    1644:	8d 91       	ld	r24, X+
    1646:	9c 91       	ld	r25, X
    1648:	13 97       	sbiw	r26, 0x03	; 3
    164a:	ed 01       	movw	r28, r26
    164c:	c8 0f       	add	r28, r24
    164e:	d9 1f       	adc	r29, r25
    1650:	2c 17       	cp	r18, r28
    1652:	3d 07       	cpc	r19, r29
    1654:	d9 f4       	brne	.+54     	; 0x168c <prvInsertBlockIntoFreeList+0x84>
	{
		if( pxIterator->pxNextFreeBlock != pxEnd )
    1656:	20 91 ad 01 	lds	r18, 0x01AD	; 0x8001ad <pxEnd>
    165a:	30 91 ae 01 	lds	r19, 0x01AE	; 0x8001ae <pxEnd+0x1>
    165e:	c2 17       	cp	r28, r18
    1660:	d3 07       	cpc	r29, r19
    1662:	81 f0       	breq	.+32     	; 0x1684 <prvInsertBlockIntoFreeList+0x7c>
		{
			/* Form one big block from the two blocks. */
			pxBlockToInsert->xBlockSize += pxIterator->pxNextFreeBlock->xBlockSize;
    1664:	2a 81       	ldd	r18, Y+2	; 0x02
    1666:	3b 81       	ldd	r19, Y+3	; 0x03
    1668:	82 0f       	add	r24, r18
    166a:	93 1f       	adc	r25, r19
    166c:	13 96       	adiw	r26, 0x03	; 3
    166e:	9c 93       	st	X, r25
    1670:	8e 93       	st	-X, r24
    1672:	12 97       	sbiw	r26, 0x02	; 2
			pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock->pxNextFreeBlock;
    1674:	c0 81       	ld	r28, Z
    1676:	d1 81       	ldd	r29, Z+1	; 0x01
    1678:	88 81       	ld	r24, Y
    167a:	99 81       	ldd	r25, Y+1	; 0x01
    167c:	11 96       	adiw	r26, 0x01	; 1
    167e:	9c 93       	st	X, r25
    1680:	8e 93       	st	-X, r24
    1682:	07 c0       	rjmp	.+14     	; 0x1692 <prvInsertBlockIntoFreeList+0x8a>
		}
		else
		{
			pxBlockToInsert->pxNextFreeBlock = pxEnd;
    1684:	11 96       	adiw	r26, 0x01	; 1
    1686:	dc 93       	st	X, r29
    1688:	ce 93       	st	-X, r28
    168a:	03 c0       	rjmp	.+6      	; 0x1692 <prvInsertBlockIntoFreeList+0x8a>
		}
	}
	else
	{
		pxBlockToInsert->pxNextFreeBlock = pxIterator->pxNextFreeBlock;
    168c:	11 96       	adiw	r26, 0x01	; 1
    168e:	3c 93       	st	X, r19
    1690:	2e 93       	st	-X, r18

	/* If the block being inserted plugged a gab, so was merged with the block
	before and the block after, then it's pxNextFreeBlock pointer will have
	already been set, and should not be set here as that would make it point
	to itself. */
	if( pxIterator != pxBlockToInsert )
    1692:	ae 17       	cp	r26, r30
    1694:	bf 07       	cpc	r27, r31
    1696:	11 f0       	breq	.+4      	; 0x169c <prvInsertBlockIntoFreeList+0x94>
	{
		pxIterator->pxNextFreeBlock = pxBlockToInsert;
    1698:	b1 83       	std	Z+1, r27	; 0x01
    169a:	a0 83       	st	Z, r26
	}
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}
}
    169c:	df 91       	pop	r29
    169e:	cf 91       	pop	r28
    16a0:	08 95       	ret

000016a2 <pvPortMalloc>:
static size_t xBlockAllocatedBit = 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    16a2:	cf 92       	push	r12
    16a4:	df 92       	push	r13
    16a6:	ef 92       	push	r14
    16a8:	ff 92       	push	r15
    16aa:	0f 93       	push	r16
    16ac:	1f 93       	push	r17
    16ae:	cf 93       	push	r28
    16b0:	df 93       	push	r29
    16b2:	ec 01       	movw	r28, r24
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;

	vTaskSuspendAll();
    16b4:	0e 94 ff 13 	call	0x27fe	; 0x27fe <vTaskSuspendAll>
	{
		/* If this is the first call to malloc then the heap will require
		initialisation to setup the list of free blocks. */
		if( pxEnd == NULL )
    16b8:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <pxEnd>
    16bc:	90 91 ae 01 	lds	r25, 0x01AE	; 0x8001ae <pxEnd+0x1>
    16c0:	89 2b       	or	r24, r25
    16c2:	41 f5       	brne	.+80     	; 0x1714 <pvPortMalloc+0x72>

	pucAlignedHeap = ( uint8_t * ) uxAddress;

	/* xStart is used to hold a pointer to the first item in the list of free
	blocks.  The void cast is used to prevent compiler warnings. */
	xStart.pxNextFreeBlock = ( void * ) pucAlignedHeap;
    16c4:	ef ea       	ldi	r30, 0xAF	; 175
    16c6:	f1 e0       	ldi	r31, 0x01	; 1
    16c8:	a3 eb       	ldi	r26, 0xB3	; 179
    16ca:	b1 e0       	ldi	r27, 0x01	; 1
    16cc:	b1 83       	std	Z+1, r27	; 0x01
    16ce:	a0 83       	st	Z, r26
	xStart.xBlockSize = ( size_t ) 0;
    16d0:	13 82       	std	Z+3, r1	; 0x03
    16d2:	12 82       	std	Z+2, r1	; 0x02
	/* pxEnd is used to mark the end of the list of free blocks and is inserted
	at the end of the heap space. */
	uxAddress = ( ( size_t ) pucAlignedHeap ) + xTotalHeapSize;
	uxAddress -= xHeapStructSize;
	uxAddress &= ~( ( size_t ) portBYTE_ALIGNMENT_MASK );
	pxEnd = ( void * ) uxAddress;
    16d4:	eb e8       	ldi	r30, 0x8B	; 139
    16d6:	f7 e0       	ldi	r31, 0x07	; 7
    16d8:	f0 93 ae 01 	sts	0x01AE, r31	; 0x8001ae <pxEnd+0x1>
    16dc:	e0 93 ad 01 	sts	0x01AD, r30	; 0x8001ad <pxEnd>
	pxEnd->xBlockSize = 0;
    16e0:	13 82       	std	Z+3, r1	; 0x03
    16e2:	12 82       	std	Z+2, r1	; 0x02
	pxEnd->pxNextFreeBlock = NULL;
    16e4:	11 82       	std	Z+1, r1	; 0x01
    16e6:	10 82       	st	Z, r1

	/* To start with there is a single free block that is sized to take up the
	entire heap space, minus the space taken by pxEnd. */
	pxFirstFreeBlock = ( void * ) pucAlignedHeap;
	pxFirstFreeBlock->xBlockSize = uxAddress - ( size_t ) pxFirstFreeBlock;
    16e8:	88 ed       	ldi	r24, 0xD8	; 216
    16ea:	95 e0       	ldi	r25, 0x05	; 5
    16ec:	13 96       	adiw	r26, 0x03	; 3
    16ee:	9c 93       	st	X, r25
    16f0:	8e 93       	st	-X, r24
    16f2:	12 97       	sbiw	r26, 0x02	; 2
	pxFirstFreeBlock->pxNextFreeBlock = pxEnd;
    16f4:	ed 93       	st	X+, r30
    16f6:	fc 93       	st	X, r31

	/* Only one block exists - and it covers the entire usable heap space. */
	xMinimumEverFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    16f8:	90 93 aa 01 	sts	0x01AA, r25	; 0x8001aa <xMinimumEverFreeBytesRemaining+0x1>
    16fc:	80 93 a9 01 	sts	0x01A9, r24	; 0x8001a9 <xMinimumEverFreeBytesRemaining>
	xFreeBytesRemaining = pxFirstFreeBlock->xBlockSize;
    1700:	90 93 ac 01 	sts	0x01AC, r25	; 0x8001ac <xFreeBytesRemaining+0x1>
    1704:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <xFreeBytesRemaining>

	/* Work out the position of the top bit in a size_t variable. */
	xBlockAllocatedBit = ( ( size_t ) 1 ) << ( ( sizeof( size_t ) * heapBITS_PER_BYTE ) - 1 );
    1708:	80 e0       	ldi	r24, 0x00	; 0
    170a:	90 e8       	ldi	r25, 0x80	; 128
    170c:	90 93 a8 01 	sts	0x01A8, r25	; 0x8001a8 <xBlockAllocatedBit+0x1>
    1710:	80 93 a7 01 	sts	0x01A7, r24	; 0x8001a7 <xBlockAllocatedBit>

		/* Check the requested block size is not so large that the top bit is
		set.  The top bit of the block size member of the BlockLink_t structure
		is used to determine who owns the block - the application or the
		kernel, so it must be free. */
		if( ( xWantedSize & xBlockAllocatedBit ) == 0 )
    1714:	e0 90 a7 01 	lds	r14, 0x01A7	; 0x8001a7 <xBlockAllocatedBit>
    1718:	f0 90 a8 01 	lds	r15, 0x01A8	; 0x8001a8 <xBlockAllocatedBit+0x1>
    171c:	c7 01       	movw	r24, r14
    171e:	8c 23       	and	r24, r28
    1720:	9d 23       	and	r25, r29
    1722:	89 2b       	or	r24, r25
    1724:	09 f0       	breq	.+2      	; 0x1728 <pvPortMalloc+0x86>
    1726:	5e c0       	rjmp	.+188    	; 0x17e4 <pvPortMalloc+0x142>
		{
			/* The wanted size is increased so it can contain a BlockLink_t
			structure in addition to the requested amount of bytes. */
			if( xWantedSize > 0 )
    1728:	20 97       	sbiw	r28, 0x00	; 0
    172a:	09 f4       	brne	.+2      	; 0x172e <pvPortMalloc+0x8c>
    172c:	5e c0       	rjmp	.+188    	; 0x17ea <pvPortMalloc+0x148>
			{
				xWantedSize += xHeapStructSize;
    172e:	ae 01       	movw	r20, r28
    1730:	4c 5f       	subi	r20, 0xFC	; 252
    1732:	5f 4f       	sbci	r21, 0xFF	; 255
			else
			{
				mtCOVERAGE_TEST_MARKER();
			}

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
    1734:	09 f4       	brne	.+2      	; 0x1738 <pvPortMalloc+0x96>
    1736:	5c c0       	rjmp	.+184    	; 0x17f0 <pvPortMalloc+0x14e>
    1738:	00 91 ab 01 	lds	r16, 0x01AB	; 0x8001ab <xFreeBytesRemaining>
    173c:	10 91 ac 01 	lds	r17, 0x01AC	; 0x8001ac <xFreeBytesRemaining+0x1>
    1740:	04 17       	cp	r16, r20
    1742:	15 07       	cpc	r17, r21
    1744:	08 f4       	brcc	.+2      	; 0x1748 <pvPortMalloc+0xa6>
    1746:	57 c0       	rjmp	.+174    	; 0x17f6 <pvPortMalloc+0x154>
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
    1748:	c0 91 af 01 	lds	r28, 0x01AF	; 0x8001af <xStart>
    174c:	d0 91 b0 01 	lds	r29, 0x01B0	; 0x8001b0 <xStart+0x1>

			if( ( xWantedSize > 0 ) && ( xWantedSize <= xFreeBytesRemaining ) )
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
    1750:	ef ea       	ldi	r30, 0xAF	; 175
    1752:	f1 e0       	ldi	r31, 0x01	; 1
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    1754:	02 c0       	rjmp	.+4      	; 0x175a <pvPortMalloc+0xb8>
    1756:	fe 01       	movw	r30, r28
				{
					pxPreviousBlock = pxBlock;
					pxBlock = pxBlock->pxNextFreeBlock;
    1758:	e9 01       	movw	r28, r18
			{
				/* Traverse the list from the start	(lowest address) block until
				one	of adequate size is found. */
				pxPreviousBlock = &xStart;
				pxBlock = xStart.pxNextFreeBlock;
				while( ( pxBlock->xBlockSize < xWantedSize ) && ( pxBlock->pxNextFreeBlock != NULL ) )
    175a:	2a 81       	ldd	r18, Y+2	; 0x02
    175c:	3b 81       	ldd	r19, Y+3	; 0x03
    175e:	24 17       	cp	r18, r20
    1760:	35 07       	cpc	r19, r21
    1762:	28 f4       	brcc	.+10     	; 0x176e <pvPortMalloc+0xcc>
    1764:	28 81       	ld	r18, Y
    1766:	39 81       	ldd	r19, Y+1	; 0x01
    1768:	21 15       	cp	r18, r1
    176a:	31 05       	cpc	r19, r1
    176c:	a1 f7       	brne	.-24     	; 0x1756 <pvPortMalloc+0xb4>
					pxBlock = pxBlock->pxNextFreeBlock;
				}

				/* If the end marker was reached then a block of adequate size
				was	not found. */
				if( pxBlock != pxEnd )
    176e:	80 91 ad 01 	lds	r24, 0x01AD	; 0x8001ad <pxEnd>
    1772:	90 91 ae 01 	lds	r25, 0x01AE	; 0x8001ae <pxEnd+0x1>
    1776:	c8 17       	cp	r28, r24
    1778:	d9 07       	cpc	r29, r25
    177a:	09 f4       	brne	.+2      	; 0x177e <pvPortMalloc+0xdc>
    177c:	3f c0       	rjmp	.+126    	; 0x17fc <pvPortMalloc+0x15a>
				{
					/* Return the memory space pointed to - jumping over the
					BlockLink_t structure at its start. */
					pvReturn = ( void * ) ( ( ( uint8_t * ) pxPreviousBlock->pxNextFreeBlock ) + xHeapStructSize );
    177e:	c0 80       	ld	r12, Z
    1780:	d1 80       	ldd	r13, Z+1	; 0x01
    1782:	84 e0       	ldi	r24, 0x04	; 4
    1784:	c8 0e       	add	r12, r24
    1786:	d1 1c       	adc	r13, r1

					/* This block is being returned for use so must be taken out
					of the list of free blocks. */
					pxPreviousBlock->pxNextFreeBlock = pxBlock->pxNextFreeBlock;
    1788:	88 81       	ld	r24, Y
    178a:	99 81       	ldd	r25, Y+1	; 0x01
    178c:	91 83       	std	Z+1, r25	; 0x01
    178e:	80 83       	st	Z, r24

					/* If the block is larger than required it can be split into
					two. */
					if( ( pxBlock->xBlockSize - xWantedSize ) > heapMINIMUM_BLOCK_SIZE )
    1790:	2a 81       	ldd	r18, Y+2	; 0x02
    1792:	3b 81       	ldd	r19, Y+3	; 0x03
    1794:	24 1b       	sub	r18, r20
    1796:	35 0b       	sbc	r19, r21
    1798:	29 30       	cpi	r18, 0x09	; 9
    179a:	31 05       	cpc	r19, r1
    179c:	48 f0       	brcs	.+18     	; 0x17b0 <pvPortMalloc+0x10e>
					{
						/* This block is to be split into two.  Create a new
						block following the number of bytes requested. The void
						cast is used to prevent byte alignment warnings from the
						compiler. */
						pxNewBlockLink = ( void * ) ( ( ( uint8_t * ) pxBlock ) + xWantedSize );
    179e:	ce 01       	movw	r24, r28
    17a0:	84 0f       	add	r24, r20
    17a2:	95 1f       	adc	r25, r21
						configASSERT( ( ( ( size_t ) pxNewBlockLink ) & portBYTE_ALIGNMENT_MASK ) == 0 );

						/* Calculate the sizes of two blocks split from the
						single block. */
						pxNewBlockLink->xBlockSize = pxBlock->xBlockSize - xWantedSize;
    17a4:	fc 01       	movw	r30, r24
    17a6:	33 83       	std	Z+3, r19	; 0x03
    17a8:	22 83       	std	Z+2, r18	; 0x02
						pxBlock->xBlockSize = xWantedSize;
    17aa:	5b 83       	std	Y+3, r21	; 0x03
    17ac:	4a 83       	std	Y+2, r20	; 0x02

						/* Insert the new block into the list of free blocks. */
						prvInsertBlockIntoFreeList( pxNewBlockLink );
    17ae:	2c df       	rcall	.-424    	; 0x1608 <prvInsertBlockIntoFreeList>
					else
					{
						mtCOVERAGE_TEST_MARKER();
					}

					xFreeBytesRemaining -= pxBlock->xBlockSize;
    17b0:	8a 81       	ldd	r24, Y+2	; 0x02
    17b2:	9b 81       	ldd	r25, Y+3	; 0x03
    17b4:	08 1b       	sub	r16, r24
    17b6:	19 0b       	sbc	r17, r25
    17b8:	10 93 ac 01 	sts	0x01AC, r17	; 0x8001ac <xFreeBytesRemaining+0x1>
    17bc:	00 93 ab 01 	sts	0x01AB, r16	; 0x8001ab <xFreeBytesRemaining>

					if( xFreeBytesRemaining < xMinimumEverFreeBytesRemaining )
    17c0:	20 91 a9 01 	lds	r18, 0x01A9	; 0x8001a9 <xMinimumEverFreeBytesRemaining>
    17c4:	30 91 aa 01 	lds	r19, 0x01AA	; 0x8001aa <xMinimumEverFreeBytesRemaining+0x1>
    17c8:	02 17       	cp	r16, r18
    17ca:	13 07       	cpc	r17, r19
    17cc:	20 f4       	brcc	.+8      	; 0x17d6 <pvPortMalloc+0x134>
					{
						xMinimumEverFreeBytesRemaining = xFreeBytesRemaining;
    17ce:	10 93 aa 01 	sts	0x01AA, r17	; 0x8001aa <xMinimumEverFreeBytesRemaining+0x1>
    17d2:	00 93 a9 01 	sts	0x01A9, r16	; 0x8001a9 <xMinimumEverFreeBytesRemaining>
						mtCOVERAGE_TEST_MARKER();
					}

					/* The block is being returned - it is allocated and owned
					by the application and has no "next" block. */
					pxBlock->xBlockSize |= xBlockAllocatedBit;
    17d6:	e8 2a       	or	r14, r24
    17d8:	f9 2a       	or	r15, r25
    17da:	fb 82       	std	Y+3, r15	; 0x03
    17dc:	ea 82       	std	Y+2, r14	; 0x02
					pxBlock->pxNextFreeBlock = NULL;
    17de:	19 82       	std	Y+1, r1	; 0x01
    17e0:	18 82       	st	Y, r1
    17e2:	0e c0       	rjmp	.+28     	; 0x1800 <pvPortMalloc+0x15e>
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
BlockLink_t *pxBlock, *pxPreviousBlock, *pxNewBlockLink;
void *pvReturn = NULL;
    17e4:	c1 2c       	mov	r12, r1
    17e6:	d1 2c       	mov	r13, r1
    17e8:	0b c0       	rjmp	.+22     	; 0x1800 <pvPortMalloc+0x15e>
    17ea:	c1 2c       	mov	r12, r1
    17ec:	d1 2c       	mov	r13, r1
    17ee:	08 c0       	rjmp	.+16     	; 0x1800 <pvPortMalloc+0x15e>
    17f0:	c1 2c       	mov	r12, r1
    17f2:	d1 2c       	mov	r13, r1
    17f4:	05 c0       	rjmp	.+10     	; 0x1800 <pvPortMalloc+0x15e>
    17f6:	c1 2c       	mov	r12, r1
    17f8:	d1 2c       	mov	r13, r1
    17fa:	02 c0       	rjmp	.+4      	; 0x1800 <pvPortMalloc+0x15e>
    17fc:	c1 2c       	mov	r12, r1
    17fe:	d1 2c       	mov	r13, r1
			mtCOVERAGE_TEST_MARKER();
		}

		traceMALLOC( pvReturn, xWantedSize );
	}
	( void ) xTaskResumeAll();
    1800:	0e 94 c7 14 	call	0x298e	; 0x298e <xTaskResumeAll>
	}
	#endif

	configASSERT( ( ( ( size_t ) pvReturn ) & ( size_t ) portBYTE_ALIGNMENT_MASK ) == 0 );
	return pvReturn;
}
    1804:	c6 01       	movw	r24, r12
    1806:	df 91       	pop	r29
    1808:	cf 91       	pop	r28
    180a:	1f 91       	pop	r17
    180c:	0f 91       	pop	r16
    180e:	ff 90       	pop	r15
    1810:	ef 90       	pop	r14
    1812:	df 90       	pop	r13
    1814:	cf 90       	pop	r12
    1816:	08 95       	ret

00001818 <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    1818:	cf 93       	push	r28
    181a:	df 93       	push	r29
uint8_t *puc = ( uint8_t * ) pv;
BlockLink_t *pxLink;

	if( pv != NULL )
    181c:	00 97       	sbiw	r24, 0x00	; 0
    181e:	49 f1       	breq	.+82     	; 0x1872 <vPortFree+0x5a>

		/* Check the block is actually allocated. */
		configASSERT( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 );
		configASSERT( pxLink->pxNextFreeBlock == NULL );

		if( ( pxLink->xBlockSize & xBlockAllocatedBit ) != 0 )
    1820:	fc 01       	movw	r30, r24
    1822:	34 97       	sbiw	r30, 0x04	; 4
    1824:	22 81       	ldd	r18, Z+2	; 0x02
    1826:	33 81       	ldd	r19, Z+3	; 0x03
    1828:	40 91 a7 01 	lds	r20, 0x01A7	; 0x8001a7 <xBlockAllocatedBit>
    182c:	50 91 a8 01 	lds	r21, 0x01A8	; 0x8001a8 <xBlockAllocatedBit+0x1>
    1830:	b9 01       	movw	r22, r18
    1832:	64 23       	and	r22, r20
    1834:	75 23       	and	r23, r21
    1836:	67 2b       	or	r22, r23
    1838:	e1 f0       	breq	.+56     	; 0x1872 <vPortFree+0x5a>
		{
			if( pxLink->pxNextFreeBlock == NULL )
    183a:	60 81       	ld	r22, Z
    183c:	71 81       	ldd	r23, Z+1	; 0x01
    183e:	67 2b       	or	r22, r23
    1840:	c1 f4       	brne	.+48     	; 0x1872 <vPortFree+0x5a>
			{
				/* The block is being returned to the heap - it is no longer
				allocated. */
				pxLink->xBlockSize &= ~xBlockAllocatedBit;
    1842:	ef 01       	movw	r28, r30
    1844:	40 95       	com	r20
    1846:	50 95       	com	r21
    1848:	24 23       	and	r18, r20
    184a:	35 23       	and	r19, r21
    184c:	33 83       	std	Z+3, r19	; 0x03
    184e:	22 83       	std	Z+2, r18	; 0x02

				vTaskSuspendAll();
    1850:	d6 d7       	rcall	.+4012   	; 0x27fe <vTaskSuspendAll>
				{
					/* Add this block to the list of free blocks. */
					xFreeBytesRemaining += pxLink->xBlockSize;
    1852:	20 91 ab 01 	lds	r18, 0x01AB	; 0x8001ab <xFreeBytesRemaining>
    1856:	30 91 ac 01 	lds	r19, 0x01AC	; 0x8001ac <xFreeBytesRemaining+0x1>
    185a:	8a 81       	ldd	r24, Y+2	; 0x02
    185c:	9b 81       	ldd	r25, Y+3	; 0x03
    185e:	82 0f       	add	r24, r18
    1860:	93 1f       	adc	r25, r19
    1862:	90 93 ac 01 	sts	0x01AC, r25	; 0x8001ac <xFreeBytesRemaining+0x1>
    1866:	80 93 ab 01 	sts	0x01AB, r24	; 0x8001ab <xFreeBytesRemaining>
					traceFREE( pv, pxLink->xBlockSize );
					prvInsertBlockIntoFreeList( ( ( BlockLink_t * ) pxLink ) );
    186a:	ce 01       	movw	r24, r28
    186c:	cd de       	rcall	.-614    	; 0x1608 <prvInsertBlockIntoFreeList>
				}
				( void ) xTaskResumeAll();
    186e:	0e 94 c7 14 	call	0x298e	; 0x298e <xTaskResumeAll>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
}
    1872:	df 91       	pop	r29
    1874:	cf 91       	pop	r28
    1876:	08 95       	ret

00001878 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( List_t * const pxList )
{
    1878:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( ListItem_t * ) &( pxList->xListEnd );			/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    187a:	03 96       	adiw	r24, 0x03	; 3
    187c:	92 83       	std	Z+2, r25	; 0x02
    187e:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    1880:	2f ef       	ldi	r18, 0xFF	; 255
    1882:	3f ef       	ldi	r19, 0xFF	; 255
    1884:	34 83       	std	Z+4, r19	; 0x04
    1886:	23 83       	std	Z+3, r18	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( ListItem_t * ) &( pxList->xListEnd );	/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    1888:	96 83       	std	Z+6, r25	; 0x06
    188a:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( ListItem_t * ) &( pxList->xListEnd );/*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. */
    188c:	90 87       	std	Z+8, r25	; 0x08
    188e:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( UBaseType_t ) 0U;
    1890:	10 82       	st	Z, r1
    1892:	08 95       	ret

00001894 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( ListItem_t * const pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pxContainer = NULL;
    1894:	fc 01       	movw	r30, r24
    1896:	11 86       	std	Z+9, r1	; 0x09
    1898:	10 86       	std	Z+8, r1	; 0x08
    189a:	08 95       	ret

0000189c <vListInsertEnd>:
	listSET_SECOND_LIST_ITEM_INTEGRITY_CHECK_VALUE( pxItem );
}
/*-----------------------------------------------------------*/

void vListInsertEnd( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    189c:	cf 93       	push	r28
    189e:	df 93       	push	r29
    18a0:	9c 01       	movw	r18, r24
    18a2:	fb 01       	movw	r30, r22
ListItem_t * const pxIndex = pxList->pxIndex;
    18a4:	dc 01       	movw	r26, r24
    18a6:	11 96       	adiw	r26, 0x01	; 1
    18a8:	cd 91       	ld	r28, X+
    18aa:	dc 91       	ld	r29, X
    18ac:	12 97       	sbiw	r26, 0x02	; 2
	listTEST_LIST_ITEM_INTEGRITY( pxNewListItem );

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	listGET_OWNER_OF_NEXT_ENTRY(). */
	pxNewListItem->pxNext = pxIndex;
    18ae:	d3 83       	std	Z+3, r29	; 0x03
    18b0:	c2 83       	std	Z+2, r28	; 0x02
	pxNewListItem->pxPrevious = pxIndex->pxPrevious;
    18b2:	8c 81       	ldd	r24, Y+4	; 0x04
    18b4:	9d 81       	ldd	r25, Y+5	; 0x05
    18b6:	95 83       	std	Z+5, r25	; 0x05
    18b8:	84 83       	std	Z+4, r24	; 0x04

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	pxIndex->pxPrevious->pxNext = pxNewListItem;
    18ba:	8c 81       	ldd	r24, Y+4	; 0x04
    18bc:	9d 81       	ldd	r25, Y+5	; 0x05
    18be:	dc 01       	movw	r26, r24
    18c0:	13 96       	adiw	r26, 0x03	; 3
    18c2:	7c 93       	st	X, r23
    18c4:	6e 93       	st	-X, r22
    18c6:	12 97       	sbiw	r26, 0x02	; 2
	pxIndex->pxPrevious = pxNewListItem;
    18c8:	7d 83       	std	Y+5, r23	; 0x05
    18ca:	6c 83       	std	Y+4, r22	; 0x04

	/* Remember which list the item is in. */
	pxNewListItem->pxContainer = pxList;
    18cc:	31 87       	std	Z+9, r19	; 0x09
    18ce:	20 87       	std	Z+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    18d0:	f9 01       	movw	r30, r18
    18d2:	80 81       	ld	r24, Z
    18d4:	8f 5f       	subi	r24, 0xFF	; 255
    18d6:	80 83       	st	Z, r24
}
    18d8:	df 91       	pop	r29
    18da:	cf 91       	pop	r28
    18dc:	08 95       	ret

000018de <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( List_t * const pxList, ListItem_t * const pxNewListItem )
{
    18de:	cf 93       	push	r28
    18e0:	df 93       	push	r29
    18e2:	eb 01       	movw	r28, r22
ListItem_t *pxIterator;
const TickType_t xValueOfInsertion = pxNewListItem->xItemValue;
    18e4:	48 81       	ld	r20, Y
    18e6:	59 81       	ldd	r21, Y+1	; 0x01
	new list item should be placed after it.  This ensures that TCBs which are
	stored in ready lists (all of which have the same xItemValue value) get a
	share of the CPU.  However, if the xItemValue is the same as the back marker
	the iteration loop below will not end.  Therefore the value is checked
	first, and the algorithm slightly modified if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    18e8:	4f 3f       	cpi	r20, 0xFF	; 255
    18ea:	2f ef       	ldi	r18, 0xFF	; 255
    18ec:	52 07       	cpc	r21, r18
    18ee:	21 f4       	brne	.+8      	; 0x18f8 <vListInsert+0x1a>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    18f0:	fc 01       	movw	r30, r24
    18f2:	a7 81       	ldd	r26, Z+7	; 0x07
    18f4:	b0 85       	ldd	r27, Z+8	; 0x08
    18f6:	0d c0       	rjmp	.+26     	; 0x1912 <vListInsert+0x34>
			4) Using a queue or semaphore before it has been initialised or
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		**********************************************************************/

		for( pxIterator = ( ListItem_t * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext ) /*lint !e826 !e740 !e9087 The mini list structure is used as the list end to save RAM.  This is checked and valid. *//*lint !e440 The iterator moves to a different value, not xValueOfInsertion. */
    18f8:	dc 01       	movw	r26, r24
    18fa:	13 96       	adiw	r26, 0x03	; 3
    18fc:	01 c0       	rjmp	.+2      	; 0x1900 <vListInsert+0x22>
    18fe:	df 01       	movw	r26, r30
    1900:	12 96       	adiw	r26, 0x02	; 2
    1902:	ed 91       	ld	r30, X+
    1904:	fc 91       	ld	r31, X
    1906:	13 97       	sbiw	r26, 0x03	; 3
    1908:	20 81       	ld	r18, Z
    190a:	31 81       	ldd	r19, Z+1	; 0x01
    190c:	42 17       	cp	r20, r18
    190e:	53 07       	cpc	r21, r19
    1910:	b0 f7       	brcc	.-20     	; 0x18fe <vListInsert+0x20>
			/* There is nothing to do here, just iterating to the wanted
			insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1912:	12 96       	adiw	r26, 0x02	; 2
    1914:	ed 91       	ld	r30, X+
    1916:	fc 91       	ld	r31, X
    1918:	13 97       	sbiw	r26, 0x03	; 3
    191a:	fb 83       	std	Y+3, r31	; 0x03
    191c:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = pxNewListItem;
    191e:	d5 83       	std	Z+5, r29	; 0x05
    1920:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1922:	bd 83       	std	Y+5, r27	; 0x05
    1924:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = pxNewListItem;
    1926:	13 96       	adiw	r26, 0x03	; 3
    1928:	dc 93       	st	X, r29
    192a:	ce 93       	st	-X, r28
    192c:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pxContainer = pxList;
    192e:	99 87       	std	Y+9, r25	; 0x09
    1930:	88 87       	std	Y+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    1932:	fc 01       	movw	r30, r24
    1934:	20 81       	ld	r18, Z
    1936:	2f 5f       	subi	r18, 0xFF	; 255
    1938:	20 83       	st	Z, r18
}
    193a:	df 91       	pop	r29
    193c:	cf 91       	pop	r28
    193e:	08 95       	ret

00001940 <uxListRemove>:
/*-----------------------------------------------------------*/

UBaseType_t uxListRemove( ListItem_t * const pxItemToRemove )
{
    1940:	cf 93       	push	r28
    1942:	df 93       	push	r29
    1944:	fc 01       	movw	r30, r24
/* The list item knows which list it is in.  Obtain the list from the list
item. */
List_t * const pxList = pxItemToRemove->pxContainer;
    1946:	a0 85       	ldd	r26, Z+8	; 0x08
    1948:	b1 85       	ldd	r27, Z+9	; 0x09

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    194a:	c2 81       	ldd	r28, Z+2	; 0x02
    194c:	d3 81       	ldd	r29, Z+3	; 0x03
    194e:	84 81       	ldd	r24, Z+4	; 0x04
    1950:	95 81       	ldd	r25, Z+5	; 0x05
    1952:	9d 83       	std	Y+5, r25	; 0x05
    1954:	8c 83       	std	Y+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    1956:	c4 81       	ldd	r28, Z+4	; 0x04
    1958:	d5 81       	ldd	r29, Z+5	; 0x05
    195a:	82 81       	ldd	r24, Z+2	; 0x02
    195c:	93 81       	ldd	r25, Z+3	; 0x03
    195e:	9b 83       	std	Y+3, r25	; 0x03
    1960:	8a 83       	std	Y+2, r24	; 0x02

	/* Only used during decision coverage testing. */
	mtCOVERAGE_TEST_DELAY();

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    1962:	11 96       	adiw	r26, 0x01	; 1
    1964:	8d 91       	ld	r24, X+
    1966:	9c 91       	ld	r25, X
    1968:	12 97       	sbiw	r26, 0x02	; 2
    196a:	e8 17       	cp	r30, r24
    196c:	f9 07       	cpc	r31, r25
    196e:	31 f4       	brne	.+12     	; 0x197c <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    1970:	84 81       	ldd	r24, Z+4	; 0x04
    1972:	95 81       	ldd	r25, Z+5	; 0x05
    1974:	12 96       	adiw	r26, 0x02	; 2
    1976:	9c 93       	st	X, r25
    1978:	8e 93       	st	-X, r24
    197a:	11 97       	sbiw	r26, 0x01	; 1
	else
	{
		mtCOVERAGE_TEST_MARKER();
	}

	pxItemToRemove->pxContainer = NULL;
    197c:	11 86       	std	Z+9, r1	; 0x09
    197e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1980:	8c 91       	ld	r24, X
    1982:	81 50       	subi	r24, 0x01	; 1
    1984:	8c 93       	st	X, r24

	return pxList->uxNumberOfItems;
    1986:	8c 91       	ld	r24, X
}
    1988:	df 91       	pop	r29
    198a:	cf 91       	pop	r28
    198c:	08 95       	ret

0000198e <pxPortInitialiseStack>:
	return pdTRUE;
}
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    198e:	31 e1       	ldi	r19, 0x11	; 17
    1990:	fc 01       	movw	r30, r24
    1992:	30 83       	st	Z, r19
    1994:	31 97       	sbiw	r30, 0x01	; 1
    1996:	22 e2       	ldi	r18, 0x22	; 34
    1998:	20 83       	st	Z, r18
    199a:	31 97       	sbiw	r30, 0x01	; 1
    199c:	a3 e3       	ldi	r26, 0x33	; 51
    199e:	a0 83       	st	Z, r26
    19a0:	31 97       	sbiw	r30, 0x01	; 1
    19a2:	60 83       	st	Z, r22
    19a4:	31 97       	sbiw	r30, 0x01	; 1
    19a6:	70 83       	st	Z, r23
    19a8:	31 97       	sbiw	r30, 0x01	; 1
    19aa:	10 82       	st	Z, r1
    19ac:	31 97       	sbiw	r30, 0x01	; 1
    19ae:	60 e8       	ldi	r22, 0x80	; 128
    19b0:	60 83       	st	Z, r22
    19b2:	31 97       	sbiw	r30, 0x01	; 1
    19b4:	10 82       	st	Z, r1
    19b6:	31 97       	sbiw	r30, 0x01	; 1
    19b8:	62 e0       	ldi	r22, 0x02	; 2
    19ba:	60 83       	st	Z, r22
    19bc:	31 97       	sbiw	r30, 0x01	; 1
    19be:	63 e0       	ldi	r22, 0x03	; 3
    19c0:	60 83       	st	Z, r22
    19c2:	31 97       	sbiw	r30, 0x01	; 1
    19c4:	64 e0       	ldi	r22, 0x04	; 4
    19c6:	60 83       	st	Z, r22
    19c8:	31 97       	sbiw	r30, 0x01	; 1
    19ca:	65 e0       	ldi	r22, 0x05	; 5
    19cc:	60 83       	st	Z, r22
    19ce:	31 97       	sbiw	r30, 0x01	; 1
    19d0:	66 e0       	ldi	r22, 0x06	; 6
    19d2:	60 83       	st	Z, r22
    19d4:	31 97       	sbiw	r30, 0x01	; 1
    19d6:	67 e0       	ldi	r22, 0x07	; 7
    19d8:	60 83       	st	Z, r22
    19da:	31 97       	sbiw	r30, 0x01	; 1
    19dc:	68 e0       	ldi	r22, 0x08	; 8
    19de:	60 83       	st	Z, r22
    19e0:	31 97       	sbiw	r30, 0x01	; 1
    19e2:	69 e0       	ldi	r22, 0x09	; 9
    19e4:	60 83       	st	Z, r22
    19e6:	31 97       	sbiw	r30, 0x01	; 1
    19e8:	60 e1       	ldi	r22, 0x10	; 16
    19ea:	60 83       	st	Z, r22
    19ec:	31 97       	sbiw	r30, 0x01	; 1
    19ee:	30 83       	st	Z, r19
    19f0:	31 97       	sbiw	r30, 0x01	; 1
    19f2:	32 e1       	ldi	r19, 0x12	; 18
    19f4:	30 83       	st	Z, r19
    19f6:	31 97       	sbiw	r30, 0x01	; 1
    19f8:	33 e1       	ldi	r19, 0x13	; 19
    19fa:	30 83       	st	Z, r19
    19fc:	31 97       	sbiw	r30, 0x01	; 1
    19fe:	34 e1       	ldi	r19, 0x14	; 20
    1a00:	30 83       	st	Z, r19
    1a02:	31 97       	sbiw	r30, 0x01	; 1
    1a04:	35 e1       	ldi	r19, 0x15	; 21
    1a06:	30 83       	st	Z, r19
    1a08:	31 97       	sbiw	r30, 0x01	; 1
    1a0a:	36 e1       	ldi	r19, 0x16	; 22
    1a0c:	30 83       	st	Z, r19
    1a0e:	31 97       	sbiw	r30, 0x01	; 1
    1a10:	37 e1       	ldi	r19, 0x17	; 23
    1a12:	30 83       	st	Z, r19
    1a14:	31 97       	sbiw	r30, 0x01	; 1
    1a16:	38 e1       	ldi	r19, 0x18	; 24
    1a18:	30 83       	st	Z, r19
    1a1a:	31 97       	sbiw	r30, 0x01	; 1
    1a1c:	39 e1       	ldi	r19, 0x19	; 25
    1a1e:	30 83       	st	Z, r19
    1a20:	31 97       	sbiw	r30, 0x01	; 1
    1a22:	30 e2       	ldi	r19, 0x20	; 32
    1a24:	30 83       	st	Z, r19
    1a26:	31 97       	sbiw	r30, 0x01	; 1
    1a28:	31 e2       	ldi	r19, 0x21	; 33
    1a2a:	30 83       	st	Z, r19
    1a2c:	31 97       	sbiw	r30, 0x01	; 1
    1a2e:	20 83       	st	Z, r18
    1a30:	31 97       	sbiw	r30, 0x01	; 1
    1a32:	23 e2       	ldi	r18, 0x23	; 35
    1a34:	20 83       	st	Z, r18
    1a36:	31 97       	sbiw	r30, 0x01	; 1
    1a38:	40 83       	st	Z, r20
    1a3a:	31 97       	sbiw	r30, 0x01	; 1
    1a3c:	50 83       	st	Z, r21
    1a3e:	31 97       	sbiw	r30, 0x01	; 1
    1a40:	26 e2       	ldi	r18, 0x26	; 38
    1a42:	20 83       	st	Z, r18
    1a44:	31 97       	sbiw	r30, 0x01	; 1
    1a46:	27 e2       	ldi	r18, 0x27	; 39
    1a48:	20 83       	st	Z, r18
    1a4a:	31 97       	sbiw	r30, 0x01	; 1
    1a4c:	28 e2       	ldi	r18, 0x28	; 40
    1a4e:	20 83       	st	Z, r18
    1a50:	31 97       	sbiw	r30, 0x01	; 1
    1a52:	29 e2       	ldi	r18, 0x29	; 41
    1a54:	20 83       	st	Z, r18
    1a56:	31 97       	sbiw	r30, 0x01	; 1
    1a58:	20 e3       	ldi	r18, 0x30	; 48
    1a5a:	20 83       	st	Z, r18
    1a5c:	31 97       	sbiw	r30, 0x01	; 1
    1a5e:	21 e3       	ldi	r18, 0x31	; 49
    1a60:	20 83       	st	Z, r18
    1a62:	86 97       	sbiw	r24, 0x26	; 38
    1a64:	08 95       	ret

00001a66 <xPortStartScheduler>:
    1a66:	1b bc       	out	0x2b, r1	; 43
    1a68:	8e e0       	ldi	r24, 0x0E	; 14
    1a6a:	8a bd       	out	0x2a, r24	; 42
    1a6c:	8b e0       	ldi	r24, 0x0B	; 11
    1a6e:	8e bd       	out	0x2e, r24	; 46
    1a70:	89 b7       	in	r24, 0x39	; 57
    1a72:	80 61       	ori	r24, 0x10	; 16
    1a74:	89 bf       	out	0x39, r24	; 57
    1a76:	a0 91 fc 07 	lds	r26, 0x07FC	; 0x8007fc <pxCurrentTCB>
    1a7a:	b0 91 fd 07 	lds	r27, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    1a7e:	cd 91       	ld	r28, X+
    1a80:	cd bf       	out	0x3d, r28	; 61
    1a82:	dd 91       	ld	r29, X+
    1a84:	de bf       	out	0x3e, r29	; 62
    1a86:	ff 91       	pop	r31
    1a88:	ef 91       	pop	r30
    1a8a:	df 91       	pop	r29
    1a8c:	cf 91       	pop	r28
    1a8e:	bf 91       	pop	r27
    1a90:	af 91       	pop	r26
    1a92:	9f 91       	pop	r25
    1a94:	8f 91       	pop	r24
    1a96:	7f 91       	pop	r23
    1a98:	6f 91       	pop	r22
    1a9a:	5f 91       	pop	r21
    1a9c:	4f 91       	pop	r20
    1a9e:	3f 91       	pop	r19
    1aa0:	2f 91       	pop	r18
    1aa2:	1f 91       	pop	r17
    1aa4:	0f 91       	pop	r16
    1aa6:	ff 90       	pop	r15
    1aa8:	ef 90       	pop	r14
    1aaa:	df 90       	pop	r13
    1aac:	cf 90       	pop	r12
    1aae:	bf 90       	pop	r11
    1ab0:	af 90       	pop	r10
    1ab2:	9f 90       	pop	r9
    1ab4:	8f 90       	pop	r8
    1ab6:	7f 90       	pop	r7
    1ab8:	6f 90       	pop	r6
    1aba:	5f 90       	pop	r5
    1abc:	4f 90       	pop	r4
    1abe:	3f 90       	pop	r3
    1ac0:	2f 90       	pop	r2
    1ac2:	1f 90       	pop	r1
    1ac4:	0f 90       	pop	r0
    1ac6:	0f be       	out	0x3f, r0	; 63
    1ac8:	0f 90       	pop	r0
    1aca:	08 95       	ret
    1acc:	81 e0       	ldi	r24, 0x01	; 1
    1ace:	08 95       	ret

00001ad0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1ad0:	0f 92       	push	r0
    1ad2:	0f b6       	in	r0, 0x3f	; 63
    1ad4:	f8 94       	cli
    1ad6:	0f 92       	push	r0
    1ad8:	1f 92       	push	r1
    1ada:	11 24       	eor	r1, r1
    1adc:	2f 92       	push	r2
    1ade:	3f 92       	push	r3
    1ae0:	4f 92       	push	r4
    1ae2:	5f 92       	push	r5
    1ae4:	6f 92       	push	r6
    1ae6:	7f 92       	push	r7
    1ae8:	8f 92       	push	r8
    1aea:	9f 92       	push	r9
    1aec:	af 92       	push	r10
    1aee:	bf 92       	push	r11
    1af0:	cf 92       	push	r12
    1af2:	df 92       	push	r13
    1af4:	ef 92       	push	r14
    1af6:	ff 92       	push	r15
    1af8:	0f 93       	push	r16
    1afa:	1f 93       	push	r17
    1afc:	2f 93       	push	r18
    1afe:	3f 93       	push	r19
    1b00:	4f 93       	push	r20
    1b02:	5f 93       	push	r21
    1b04:	6f 93       	push	r22
    1b06:	7f 93       	push	r23
    1b08:	8f 93       	push	r24
    1b0a:	9f 93       	push	r25
    1b0c:	af 93       	push	r26
    1b0e:	bf 93       	push	r27
    1b10:	cf 93       	push	r28
    1b12:	df 93       	push	r29
    1b14:	ef 93       	push	r30
    1b16:	ff 93       	push	r31
    1b18:	a0 91 fc 07 	lds	r26, 0x07FC	; 0x8007fc <pxCurrentTCB>
    1b1c:	b0 91 fd 07 	lds	r27, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    1b20:	0d b6       	in	r0, 0x3d	; 61
    1b22:	0d 92       	st	X+, r0
    1b24:	0e b6       	in	r0, 0x3e	; 62
    1b26:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1b28:	be d7       	rcall	.+3964   	; 0x2aa6 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1b2a:	a0 91 fc 07 	lds	r26, 0x07FC	; 0x8007fc <pxCurrentTCB>
    1b2e:	b0 91 fd 07 	lds	r27, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    1b32:	cd 91       	ld	r28, X+
    1b34:	cd bf       	out	0x3d, r28	; 61
    1b36:	dd 91       	ld	r29, X+
    1b38:	de bf       	out	0x3e, r29	; 62
    1b3a:	ff 91       	pop	r31
    1b3c:	ef 91       	pop	r30
    1b3e:	df 91       	pop	r29
    1b40:	cf 91       	pop	r28
    1b42:	bf 91       	pop	r27
    1b44:	af 91       	pop	r26
    1b46:	9f 91       	pop	r25
    1b48:	8f 91       	pop	r24
    1b4a:	7f 91       	pop	r23
    1b4c:	6f 91       	pop	r22
    1b4e:	5f 91       	pop	r21
    1b50:	4f 91       	pop	r20
    1b52:	3f 91       	pop	r19
    1b54:	2f 91       	pop	r18
    1b56:	1f 91       	pop	r17
    1b58:	0f 91       	pop	r16
    1b5a:	ff 90       	pop	r15
    1b5c:	ef 90       	pop	r14
    1b5e:	df 90       	pop	r13
    1b60:	cf 90       	pop	r12
    1b62:	bf 90       	pop	r11
    1b64:	af 90       	pop	r10
    1b66:	9f 90       	pop	r9
    1b68:	8f 90       	pop	r8
    1b6a:	7f 90       	pop	r7
    1b6c:	6f 90       	pop	r6
    1b6e:	5f 90       	pop	r5
    1b70:	4f 90       	pop	r4
    1b72:	3f 90       	pop	r3
    1b74:	2f 90       	pop	r2
    1b76:	1f 90       	pop	r1
    1b78:	0f 90       	pop	r0
    1b7a:	0f be       	out	0x3f, r0	; 63
    1b7c:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b7e:	08 95       	ret

00001b80 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1b80:	0f 92       	push	r0
    1b82:	0f b6       	in	r0, 0x3f	; 63
    1b84:	f8 94       	cli
    1b86:	0f 92       	push	r0
    1b88:	1f 92       	push	r1
    1b8a:	11 24       	eor	r1, r1
    1b8c:	2f 92       	push	r2
    1b8e:	3f 92       	push	r3
    1b90:	4f 92       	push	r4
    1b92:	5f 92       	push	r5
    1b94:	6f 92       	push	r6
    1b96:	7f 92       	push	r7
    1b98:	8f 92       	push	r8
    1b9a:	9f 92       	push	r9
    1b9c:	af 92       	push	r10
    1b9e:	bf 92       	push	r11
    1ba0:	cf 92       	push	r12
    1ba2:	df 92       	push	r13
    1ba4:	ef 92       	push	r14
    1ba6:	ff 92       	push	r15
    1ba8:	0f 93       	push	r16
    1baa:	1f 93       	push	r17
    1bac:	2f 93       	push	r18
    1bae:	3f 93       	push	r19
    1bb0:	4f 93       	push	r20
    1bb2:	5f 93       	push	r21
    1bb4:	6f 93       	push	r22
    1bb6:	7f 93       	push	r23
    1bb8:	8f 93       	push	r24
    1bba:	9f 93       	push	r25
    1bbc:	af 93       	push	r26
    1bbe:	bf 93       	push	r27
    1bc0:	cf 93       	push	r28
    1bc2:	df 93       	push	r29
    1bc4:	ef 93       	push	r30
    1bc6:	ff 93       	push	r31
    1bc8:	a0 91 fc 07 	lds	r26, 0x07FC	; 0x8007fc <pxCurrentTCB>
    1bcc:	b0 91 fd 07 	lds	r27, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    1bd0:	0d b6       	in	r0, 0x3d	; 61
    1bd2:	0d 92       	st	X+, r0
    1bd4:	0e b6       	in	r0, 0x3e	; 62
    1bd6:	0d 92       	st	X+, r0
	if( xTaskIncrementTick() != pdFALSE )
    1bd8:	22 d6       	rcall	.+3140   	; 0x281e <xTaskIncrementTick>
    1bda:	81 11       	cpse	r24, r1
	{
		vTaskSwitchContext();
    1bdc:	64 d7       	rcall	.+3784   	; 0x2aa6 <vTaskSwitchContext>
    1bde:	a0 91 fc 07 	lds	r26, 0x07FC	; 0x8007fc <pxCurrentTCB>
	}
	portRESTORE_CONTEXT();
    1be2:	b0 91 fd 07 	lds	r27, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    1be6:	cd 91       	ld	r28, X+
    1be8:	cd bf       	out	0x3d, r28	; 61
    1bea:	dd 91       	ld	r29, X+
    1bec:	de bf       	out	0x3e, r29	; 62
    1bee:	ff 91       	pop	r31
    1bf0:	ef 91       	pop	r30
    1bf2:	df 91       	pop	r29
    1bf4:	cf 91       	pop	r28
    1bf6:	bf 91       	pop	r27
    1bf8:	af 91       	pop	r26
    1bfa:	9f 91       	pop	r25
    1bfc:	8f 91       	pop	r24
    1bfe:	7f 91       	pop	r23
    1c00:	6f 91       	pop	r22
    1c02:	5f 91       	pop	r21
    1c04:	4f 91       	pop	r20
    1c06:	3f 91       	pop	r19
    1c08:	2f 91       	pop	r18
    1c0a:	1f 91       	pop	r17
    1c0c:	0f 91       	pop	r16
    1c0e:	ff 90       	pop	r15
    1c10:	ef 90       	pop	r14
    1c12:	df 90       	pop	r13
    1c14:	cf 90       	pop	r12
    1c16:	bf 90       	pop	r11
    1c18:	af 90       	pop	r10
    1c1a:	9f 90       	pop	r9
    1c1c:	8f 90       	pop	r8
    1c1e:	7f 90       	pop	r7
    1c20:	6f 90       	pop	r6
    1c22:	5f 90       	pop	r5
    1c24:	4f 90       	pop	r4
    1c26:	3f 90       	pop	r3
    1c28:	2f 90       	pop	r2
    1c2a:	1f 90       	pop	r1
    1c2c:	0f 90       	pop	r0
    1c2e:	0f be       	out	0x3f, r0	; 63
    1c30:	0f 90       	pop	r0
    1c32:	08 95       	ret

00001c34 <__vector_7>:

	asm volatile ( "ret" );
    1c34:	a5 df       	rcall	.-182    	; 0x1b80 <vPortYieldFromTick>
	 */
	void TIMER1_COMPA_vect( void ) __attribute__ ( ( signal, naked ) );
	void TIMER1_COMPA_vect( void )
	{
		vPortYieldFromTick();
		asm volatile ( "reti" );
    1c36:	18 95       	reti

00001c38 <prvIsQueueEmpty>:
	{
		xReturn = pdFALSE;
	}

	return xReturn;
} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
    1c38:	0f b6       	in	r0, 0x3f	; 63
    1c3a:	f8 94       	cli
    1c3c:	0f 92       	push	r0
    1c3e:	fc 01       	movw	r30, r24
    1c40:	92 8d       	ldd	r25, Z+26	; 0x1a
    1c42:	0f 90       	pop	r0
    1c44:	0f be       	out	0x3f, r0	; 63
    1c46:	81 e0       	ldi	r24, 0x01	; 1
    1c48:	91 11       	cpse	r25, r1
    1c4a:	80 e0       	ldi	r24, 0x00	; 0
    1c4c:	08 95       	ret

00001c4e <prvCopyDataToQueue>:
    1c4e:	0f 93       	push	r16
    1c50:	1f 93       	push	r17
    1c52:	cf 93       	push	r28
    1c54:	df 93       	push	r29
    1c56:	ec 01       	movw	r28, r24
    1c58:	04 2f       	mov	r16, r20
    1c5a:	1a 8d       	ldd	r17, Y+26	; 0x1a
    1c5c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1c5e:	41 11       	cpse	r20, r1
    1c60:	0c c0       	rjmp	.+24     	; 0x1c7a <prvCopyDataToQueue+0x2c>
    1c62:	88 81       	ld	r24, Y
    1c64:	99 81       	ldd	r25, Y+1	; 0x01
    1c66:	89 2b       	or	r24, r25
    1c68:	09 f0       	breq	.+2      	; 0x1c6c <prvCopyDataToQueue+0x1e>
    1c6a:	42 c0       	rjmp	.+132    	; 0x1cf0 <prvCopyDataToQueue+0xa2>
    1c6c:	8c 81       	ldd	r24, Y+4	; 0x04
    1c6e:	9d 81       	ldd	r25, Y+5	; 0x05
    1c70:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskPriorityDisinherit>
    1c74:	1d 82       	std	Y+5, r1	; 0x05
    1c76:	1c 82       	std	Y+4, r1	; 0x04
    1c78:	42 c0       	rjmp	.+132    	; 0x1cfe <prvCopyDataToQueue+0xb0>
    1c7a:	01 11       	cpse	r16, r1
    1c7c:	17 c0       	rjmp	.+46     	; 0x1cac <prvCopyDataToQueue+0x5e>
    1c7e:	50 e0       	ldi	r21, 0x00	; 0
    1c80:	8a 81       	ldd	r24, Y+2	; 0x02
    1c82:	9b 81       	ldd	r25, Y+3	; 0x03
    1c84:	0e 94 44 1a 	call	0x3488	; 0x3488 <memcpy>
    1c88:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c8c:	9b 81       	ldd	r25, Y+3	; 0x03
    1c8e:	82 0f       	add	r24, r18
    1c90:	91 1d       	adc	r25, r1
    1c92:	9b 83       	std	Y+3, r25	; 0x03
    1c94:	8a 83       	std	Y+2, r24	; 0x02
    1c96:	2c 81       	ldd	r18, Y+4	; 0x04
    1c98:	3d 81       	ldd	r19, Y+5	; 0x05
    1c9a:	82 17       	cp	r24, r18
    1c9c:	93 07       	cpc	r25, r19
    1c9e:	50 f1       	brcs	.+84     	; 0x1cf4 <prvCopyDataToQueue+0xa6>
    1ca0:	88 81       	ld	r24, Y
    1ca2:	99 81       	ldd	r25, Y+1	; 0x01
    1ca4:	9b 83       	std	Y+3, r25	; 0x03
    1ca6:	8a 83       	std	Y+2, r24	; 0x02
    1ca8:	80 e0       	ldi	r24, 0x00	; 0
    1caa:	29 c0       	rjmp	.+82     	; 0x1cfe <prvCopyDataToQueue+0xb0>
    1cac:	50 e0       	ldi	r21, 0x00	; 0
    1cae:	8e 81       	ldd	r24, Y+6	; 0x06
    1cb0:	9f 81       	ldd	r25, Y+7	; 0x07
    1cb2:	0e 94 44 1a 	call	0x3488	; 0x3488 <memcpy>
    1cb6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1cb8:	90 e0       	ldi	r25, 0x00	; 0
    1cba:	91 95       	neg	r25
    1cbc:	81 95       	neg	r24
    1cbe:	91 09       	sbc	r25, r1
    1cc0:	2e 81       	ldd	r18, Y+6	; 0x06
    1cc2:	3f 81       	ldd	r19, Y+7	; 0x07
    1cc4:	28 0f       	add	r18, r24
    1cc6:	39 1f       	adc	r19, r25
    1cc8:	3f 83       	std	Y+7, r19	; 0x07
    1cca:	2e 83       	std	Y+6, r18	; 0x06
    1ccc:	48 81       	ld	r20, Y
    1cce:	59 81       	ldd	r21, Y+1	; 0x01
    1cd0:	24 17       	cp	r18, r20
    1cd2:	35 07       	cpc	r19, r21
    1cd4:	30 f4       	brcc	.+12     	; 0x1ce2 <prvCopyDataToQueue+0x94>
    1cd6:	2c 81       	ldd	r18, Y+4	; 0x04
    1cd8:	3d 81       	ldd	r19, Y+5	; 0x05
    1cda:	82 0f       	add	r24, r18
    1cdc:	93 1f       	adc	r25, r19
    1cde:	9f 83       	std	Y+7, r25	; 0x07
    1ce0:	8e 83       	std	Y+6, r24	; 0x06
    1ce2:	02 30       	cpi	r16, 0x02	; 2
    1ce4:	49 f4       	brne	.+18     	; 0x1cf8 <prvCopyDataToQueue+0xaa>
    1ce6:	11 23       	and	r17, r17
    1ce8:	49 f0       	breq	.+18     	; 0x1cfc <prvCopyDataToQueue+0xae>
    1cea:	11 50       	subi	r17, 0x01	; 1
    1cec:	80 e0       	ldi	r24, 0x00	; 0
    1cee:	07 c0       	rjmp	.+14     	; 0x1cfe <prvCopyDataToQueue+0xb0>
    1cf0:	80 e0       	ldi	r24, 0x00	; 0
    1cf2:	05 c0       	rjmp	.+10     	; 0x1cfe <prvCopyDataToQueue+0xb0>
    1cf4:	80 e0       	ldi	r24, 0x00	; 0
    1cf6:	03 c0       	rjmp	.+6      	; 0x1cfe <prvCopyDataToQueue+0xb0>
    1cf8:	80 e0       	ldi	r24, 0x00	; 0
    1cfa:	01 c0       	rjmp	.+2      	; 0x1cfe <prvCopyDataToQueue+0xb0>
    1cfc:	80 e0       	ldi	r24, 0x00	; 0
    1cfe:	1f 5f       	subi	r17, 0xFF	; 255
    1d00:	1a 8f       	std	Y+26, r17	; 0x1a
    1d02:	df 91       	pop	r29
    1d04:	cf 91       	pop	r28
    1d06:	1f 91       	pop	r17
    1d08:	0f 91       	pop	r16
    1d0a:	08 95       	ret

00001d0c <prvCopyDataFromQueue>:
    1d0c:	fc 01       	movw	r30, r24
    1d0e:	44 8d       	ldd	r20, Z+28	; 0x1c
    1d10:	44 23       	and	r20, r20
    1d12:	a9 f0       	breq	.+42     	; 0x1d3e <prvCopyDataFromQueue+0x32>
    1d14:	50 e0       	ldi	r21, 0x00	; 0
    1d16:	26 81       	ldd	r18, Z+6	; 0x06
    1d18:	37 81       	ldd	r19, Z+7	; 0x07
    1d1a:	24 0f       	add	r18, r20
    1d1c:	35 1f       	adc	r19, r21
    1d1e:	37 83       	std	Z+7, r19	; 0x07
    1d20:	26 83       	std	Z+6, r18	; 0x06
    1d22:	84 81       	ldd	r24, Z+4	; 0x04
    1d24:	95 81       	ldd	r25, Z+5	; 0x05
    1d26:	28 17       	cp	r18, r24
    1d28:	39 07       	cpc	r19, r25
    1d2a:	20 f0       	brcs	.+8      	; 0x1d34 <prvCopyDataFromQueue+0x28>
    1d2c:	80 81       	ld	r24, Z
    1d2e:	91 81       	ldd	r25, Z+1	; 0x01
    1d30:	97 83       	std	Z+7, r25	; 0x07
    1d32:	86 83       	std	Z+6, r24	; 0x06
    1d34:	cb 01       	movw	r24, r22
    1d36:	66 81       	ldd	r22, Z+6	; 0x06
    1d38:	77 81       	ldd	r23, Z+7	; 0x07
    1d3a:	0c 94 44 1a 	jmp	0x3488	; 0x3488 <memcpy>
    1d3e:	08 95       	ret

00001d40 <prvUnlockQueue>:
    1d40:	ef 92       	push	r14
    1d42:	ff 92       	push	r15
    1d44:	0f 93       	push	r16
    1d46:	1f 93       	push	r17
    1d48:	cf 93       	push	r28
    1d4a:	8c 01       	movw	r16, r24
    1d4c:	0f b6       	in	r0, 0x3f	; 63
    1d4e:	f8 94       	cli
    1d50:	0f 92       	push	r0
    1d52:	fc 01       	movw	r30, r24
    1d54:	c6 8d       	ldd	r28, Z+30	; 0x1e
    1d56:	1c 16       	cp	r1, r28
    1d58:	9c f4       	brge	.+38     	; 0x1d80 <prvUnlockQueue+0x40>
    1d5a:	81 89       	ldd	r24, Z+17	; 0x11
    1d5c:	81 11       	cpse	r24, r1
    1d5e:	06 c0       	rjmp	.+12     	; 0x1d6c <prvUnlockQueue+0x2c>
    1d60:	0f c0       	rjmp	.+30     	; 0x1d80 <prvUnlockQueue+0x40>
    1d62:	f8 01       	movw	r30, r16
    1d64:	81 89       	ldd	r24, Z+17	; 0x11
    1d66:	81 11       	cpse	r24, r1
    1d68:	05 c0       	rjmp	.+10     	; 0x1d74 <prvUnlockQueue+0x34>
    1d6a:	0a c0       	rjmp	.+20     	; 0x1d80 <prvUnlockQueue+0x40>
    1d6c:	78 01       	movw	r14, r16
    1d6e:	f1 e1       	ldi	r31, 0x11	; 17
    1d70:	ef 0e       	add	r14, r31
    1d72:	f1 1c       	adc	r15, r1
    1d74:	c7 01       	movw	r24, r14
    1d76:	76 d7       	rcall	.+3820   	; 0x2c64 <xTaskRemoveFromEventList>
    1d78:	81 11       	cpse	r24, r1
    1d7a:	fc d7       	rcall	.+4088   	; 0x2d74 <vTaskMissedYield>
    1d7c:	c1 50       	subi	r28, 0x01	; 1
    1d7e:	89 f7       	brne	.-30     	; 0x1d62 <prvUnlockQueue+0x22>
    1d80:	8f ef       	ldi	r24, 0xFF	; 255
    1d82:	f8 01       	movw	r30, r16
    1d84:	86 8f       	std	Z+30, r24	; 0x1e
    1d86:	0f 90       	pop	r0
    1d88:	0f be       	out	0x3f, r0	; 63
    1d8a:	0f b6       	in	r0, 0x3f	; 63
    1d8c:	f8 94       	cli
    1d8e:	0f 92       	push	r0
    1d90:	c5 8d       	ldd	r28, Z+29	; 0x1d
    1d92:	1c 16       	cp	r1, r28
    1d94:	9c f4       	brge	.+38     	; 0x1dbc <prvUnlockQueue+0x7c>
    1d96:	80 85       	ldd	r24, Z+8	; 0x08
    1d98:	81 11       	cpse	r24, r1
    1d9a:	06 c0       	rjmp	.+12     	; 0x1da8 <prvUnlockQueue+0x68>
    1d9c:	0f c0       	rjmp	.+30     	; 0x1dbc <prvUnlockQueue+0x7c>
    1d9e:	f8 01       	movw	r30, r16
    1da0:	80 85       	ldd	r24, Z+8	; 0x08
    1da2:	81 11       	cpse	r24, r1
    1da4:	05 c0       	rjmp	.+10     	; 0x1db0 <prvUnlockQueue+0x70>
    1da6:	0a c0       	rjmp	.+20     	; 0x1dbc <prvUnlockQueue+0x7c>
    1da8:	78 01       	movw	r14, r16
    1daa:	f8 e0       	ldi	r31, 0x08	; 8
    1dac:	ef 0e       	add	r14, r31
    1dae:	f1 1c       	adc	r15, r1
    1db0:	c7 01       	movw	r24, r14
    1db2:	58 d7       	rcall	.+3760   	; 0x2c64 <xTaskRemoveFromEventList>
    1db4:	81 11       	cpse	r24, r1
    1db6:	de d7       	rcall	.+4028   	; 0x2d74 <vTaskMissedYield>
    1db8:	c1 50       	subi	r28, 0x01	; 1
    1dba:	89 f7       	brne	.-30     	; 0x1d9e <prvUnlockQueue+0x5e>
    1dbc:	8f ef       	ldi	r24, 0xFF	; 255
    1dbe:	f8 01       	movw	r30, r16
    1dc0:	85 8f       	std	Z+29, r24	; 0x1d
    1dc2:	0f 90       	pop	r0
    1dc4:	0f be       	out	0x3f, r0	; 63
    1dc6:	cf 91       	pop	r28
    1dc8:	1f 91       	pop	r17
    1dca:	0f 91       	pop	r16
    1dcc:	ff 90       	pop	r15
    1dce:	ef 90       	pop	r14
    1dd0:	08 95       	ret

00001dd2 <xQueueGenericReset>:
    1dd2:	cf 93       	push	r28
    1dd4:	df 93       	push	r29
    1dd6:	ec 01       	movw	r28, r24
    1dd8:	0f b6       	in	r0, 0x3f	; 63
    1dda:	f8 94       	cli
    1ddc:	0f 92       	push	r0
    1dde:	e8 81       	ld	r30, Y
    1de0:	f9 81       	ldd	r31, Y+1	; 0x01
    1de2:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1de4:	2c 8d       	ldd	r18, Y+28	; 0x1c
    1de6:	90 e0       	ldi	r25, 0x00	; 0
    1de8:	30 e0       	ldi	r19, 0x00	; 0
    1dea:	82 9f       	mul	r24, r18
    1dec:	a0 01       	movw	r20, r0
    1dee:	83 9f       	mul	r24, r19
    1df0:	50 0d       	add	r21, r0
    1df2:	92 9f       	mul	r25, r18
    1df4:	50 0d       	add	r21, r0
    1df6:	11 24       	eor	r1, r1
    1df8:	4e 0f       	add	r20, r30
    1dfa:	5f 1f       	adc	r21, r31
    1dfc:	5d 83       	std	Y+5, r21	; 0x05
    1dfe:	4c 83       	std	Y+4, r20	; 0x04
    1e00:	1a 8e       	std	Y+26, r1	; 0x1a
    1e02:	fb 83       	std	Y+3, r31	; 0x03
    1e04:	ea 83       	std	Y+2, r30	; 0x02
    1e06:	01 97       	sbiw	r24, 0x01	; 1
    1e08:	82 9f       	mul	r24, r18
    1e0a:	a0 01       	movw	r20, r0
    1e0c:	83 9f       	mul	r24, r19
    1e0e:	50 0d       	add	r21, r0
    1e10:	92 9f       	mul	r25, r18
    1e12:	50 0d       	add	r21, r0
    1e14:	11 24       	eor	r1, r1
    1e16:	cf 01       	movw	r24, r30
    1e18:	84 0f       	add	r24, r20
    1e1a:	95 1f       	adc	r25, r21
    1e1c:	9f 83       	std	Y+7, r25	; 0x07
    1e1e:	8e 83       	std	Y+6, r24	; 0x06
    1e20:	8f ef       	ldi	r24, 0xFF	; 255
    1e22:	8d 8f       	std	Y+29, r24	; 0x1d
    1e24:	8e 8f       	std	Y+30, r24	; 0x1e
    1e26:	61 11       	cpse	r22, r1
    1e28:	0a c0       	rjmp	.+20     	; 0x1e3e <xQueueGenericReset+0x6c>
    1e2a:	88 85       	ldd	r24, Y+8	; 0x08
    1e2c:	88 23       	and	r24, r24
    1e2e:	69 f0       	breq	.+26     	; 0x1e4a <xQueueGenericReset+0x78>
    1e30:	ce 01       	movw	r24, r28
    1e32:	08 96       	adiw	r24, 0x08	; 8
    1e34:	17 d7       	rcall	.+3630   	; 0x2c64 <xTaskRemoveFromEventList>
    1e36:	88 23       	and	r24, r24
    1e38:	41 f0       	breq	.+16     	; 0x1e4a <xQueueGenericReset+0x78>
    1e3a:	4a de       	rcall	.-876    	; 0x1ad0 <vPortYield>
    1e3c:	06 c0       	rjmp	.+12     	; 0x1e4a <xQueueGenericReset+0x78>
    1e3e:	ce 01       	movw	r24, r28
    1e40:	08 96       	adiw	r24, 0x08	; 8
    1e42:	1a dd       	rcall	.-1484   	; 0x1878 <vListInitialise>
    1e44:	ce 01       	movw	r24, r28
    1e46:	41 96       	adiw	r24, 0x11	; 17
    1e48:	17 dd       	rcall	.-1490   	; 0x1878 <vListInitialise>
    1e4a:	0f 90       	pop	r0
    1e4c:	0f be       	out	0x3f, r0	; 63
    1e4e:	81 e0       	ldi	r24, 0x01	; 1
    1e50:	df 91       	pop	r29
    1e52:	cf 91       	pop	r28
    1e54:	08 95       	ret

00001e56 <xQueueGenericCreate>:
    1e56:	0f 93       	push	r16
    1e58:	1f 93       	push	r17
    1e5a:	cf 93       	push	r28
    1e5c:	df 93       	push	r29
    1e5e:	08 2f       	mov	r16, r24
    1e60:	16 2f       	mov	r17, r22
    1e62:	66 23       	and	r22, r22
    1e64:	b1 f0       	breq	.+44     	; 0x1e92 <xQueueGenericCreate+0x3c>
    1e66:	86 9f       	mul	r24, r22
    1e68:	c0 01       	movw	r24, r0
    1e6a:	11 24       	eor	r1, r1
    1e6c:	4f 96       	adiw	r24, 0x1f	; 31
    1e6e:	19 dc       	rcall	.-1998   	; 0x16a2 <pvPortMalloc>
    1e70:	ec 01       	movw	r28, r24
    1e72:	00 97       	sbiw	r24, 0x00	; 0
    1e74:	39 f4       	brne	.+14     	; 0x1e84 <xQueueGenericCreate+0x2e>
    1e76:	13 c0       	rjmp	.+38     	; 0x1e9e <xQueueGenericCreate+0x48>
    1e78:	0b 8f       	std	Y+27, r16	; 0x1b
    1e7a:	1c 8f       	std	Y+28, r17	; 0x1c
    1e7c:	61 e0       	ldi	r22, 0x01	; 1
    1e7e:	ce 01       	movw	r24, r28
    1e80:	a8 df       	rcall	.-176    	; 0x1dd2 <xQueueGenericReset>
    1e82:	0d c0       	rjmp	.+26     	; 0x1e9e <xQueueGenericCreate+0x48>
    1e84:	4f 96       	adiw	r24, 0x1f	; 31
    1e86:	99 83       	std	Y+1, r25	; 0x01
    1e88:	88 83       	st	Y, r24
    1e8a:	f6 cf       	rjmp	.-20     	; 0x1e78 <xQueueGenericCreate+0x22>
    1e8c:	d9 83       	std	Y+1, r29	; 0x01
    1e8e:	c8 83       	st	Y, r28
    1e90:	f3 cf       	rjmp	.-26     	; 0x1e78 <xQueueGenericCreate+0x22>
    1e92:	8f e1       	ldi	r24, 0x1F	; 31
    1e94:	90 e0       	ldi	r25, 0x00	; 0
    1e96:	05 dc       	rcall	.-2038   	; 0x16a2 <pvPortMalloc>
    1e98:	ec 01       	movw	r28, r24
    1e9a:	89 2b       	or	r24, r25
    1e9c:	b9 f7       	brne	.-18     	; 0x1e8c <xQueueGenericCreate+0x36>
    1e9e:	ce 01       	movw	r24, r28
    1ea0:	df 91       	pop	r29
    1ea2:	cf 91       	pop	r28
    1ea4:	1f 91       	pop	r17
    1ea6:	0f 91       	pop	r16
    1ea8:	08 95       	ret

00001eaa <xQueueGenericSend>:
    1eaa:	9f 92       	push	r9
    1eac:	af 92       	push	r10
    1eae:	bf 92       	push	r11
    1eb0:	cf 92       	push	r12
    1eb2:	df 92       	push	r13
    1eb4:	ef 92       	push	r14
    1eb6:	ff 92       	push	r15
    1eb8:	0f 93       	push	r16
    1eba:	1f 93       	push	r17
    1ebc:	cf 93       	push	r28
    1ebe:	df 93       	push	r29
    1ec0:	00 d0       	rcall	.+0      	; 0x1ec2 <xQueueGenericSend+0x18>
    1ec2:	00 d0       	rcall	.+0      	; 0x1ec4 <xQueueGenericSend+0x1a>
    1ec4:	1f 92       	push	r1
    1ec6:	cd b7       	in	r28, 0x3d	; 61
    1ec8:	de b7       	in	r29, 0x3e	; 62
    1eca:	8c 01       	movw	r16, r24
    1ecc:	6b 01       	movw	r12, r22
    1ece:	5d 83       	std	Y+5, r21	; 0x05
    1ed0:	4c 83       	std	Y+4, r20	; 0x04
    1ed2:	a2 2e       	mov	r10, r18
    1ed4:	b1 2c       	mov	r11, r1
    1ed6:	99 24       	eor	r9, r9
    1ed8:	93 94       	inc	r9
    1eda:	7c 01       	movw	r14, r24
    1edc:	88 e0       	ldi	r24, 0x08	; 8
    1ede:	e8 0e       	add	r14, r24
    1ee0:	f1 1c       	adc	r15, r1
    1ee2:	0f b6       	in	r0, 0x3f	; 63
    1ee4:	f8 94       	cli
    1ee6:	0f 92       	push	r0
    1ee8:	f8 01       	movw	r30, r16
    1eea:	92 8d       	ldd	r25, Z+26	; 0x1a
    1eec:	83 8d       	ldd	r24, Z+27	; 0x1b
    1eee:	98 17       	cp	r25, r24
    1ef0:	18 f0       	brcs	.+6      	; 0x1ef8 <xQueueGenericSend+0x4e>
    1ef2:	f2 e0       	ldi	r31, 0x02	; 2
    1ef4:	af 12       	cpse	r10, r31
    1ef6:	15 c0       	rjmp	.+42     	; 0x1f22 <xQueueGenericSend+0x78>
    1ef8:	4a 2d       	mov	r20, r10
    1efa:	b6 01       	movw	r22, r12
    1efc:	c8 01       	movw	r24, r16
    1efe:	a7 de       	rcall	.-690    	; 0x1c4e <prvCopyDataToQueue>
    1f00:	f8 01       	movw	r30, r16
    1f02:	91 89       	ldd	r25, Z+17	; 0x11
    1f04:	99 23       	and	r25, r25
    1f06:	39 f0       	breq	.+14     	; 0x1f16 <xQueueGenericSend+0x6c>
    1f08:	c8 01       	movw	r24, r16
    1f0a:	41 96       	adiw	r24, 0x11	; 17
    1f0c:	ab d6       	rcall	.+3414   	; 0x2c64 <xTaskRemoveFromEventList>
    1f0e:	88 23       	and	r24, r24
    1f10:	21 f0       	breq	.+8      	; 0x1f1a <xQueueGenericSend+0x70>
    1f12:	de dd       	rcall	.-1092   	; 0x1ad0 <vPortYield>
    1f14:	02 c0       	rjmp	.+4      	; 0x1f1a <xQueueGenericSend+0x70>
    1f16:	81 11       	cpse	r24, r1
    1f18:	db dd       	rcall	.-1098   	; 0x1ad0 <vPortYield>
    1f1a:	0f 90       	pop	r0
    1f1c:	0f be       	out	0x3f, r0	; 63
    1f1e:	81 e0       	ldi	r24, 0x01	; 1
    1f20:	45 c0       	rjmp	.+138    	; 0x1fac <xQueueGenericSend+0x102>
    1f22:	8c 81       	ldd	r24, Y+4	; 0x04
    1f24:	9d 81       	ldd	r25, Y+5	; 0x05
    1f26:	89 2b       	or	r24, r25
    1f28:	21 f4       	brne	.+8      	; 0x1f32 <xQueueGenericSend+0x88>
    1f2a:	0f 90       	pop	r0
    1f2c:	0f be       	out	0x3f, r0	; 63
    1f2e:	80 e0       	ldi	r24, 0x00	; 0
    1f30:	3d c0       	rjmp	.+122    	; 0x1fac <xQueueGenericSend+0x102>
    1f32:	b1 10       	cpse	r11, r1
    1f34:	04 c0       	rjmp	.+8      	; 0x1f3e <xQueueGenericSend+0x94>
    1f36:	ce 01       	movw	r24, r28
    1f38:	01 96       	adiw	r24, 0x01	; 1
    1f3a:	dc d6       	rcall	.+3512   	; 0x2cf4 <vTaskInternalSetTimeOutState>
    1f3c:	b9 2c       	mov	r11, r9
    1f3e:	0f 90       	pop	r0
    1f40:	0f be       	out	0x3f, r0	; 63
    1f42:	5d d4       	rcall	.+2234   	; 0x27fe <vTaskSuspendAll>
    1f44:	0f b6       	in	r0, 0x3f	; 63
    1f46:	f8 94       	cli
    1f48:	0f 92       	push	r0
    1f4a:	f8 01       	movw	r30, r16
    1f4c:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f4e:	8f 3f       	cpi	r24, 0xFF	; 255
    1f50:	09 f4       	brne	.+2      	; 0x1f54 <xQueueGenericSend+0xaa>
    1f52:	15 8e       	std	Z+29, r1	; 0x1d
    1f54:	f8 01       	movw	r30, r16
    1f56:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f58:	8f 3f       	cpi	r24, 0xFF	; 255
    1f5a:	09 f4       	brne	.+2      	; 0x1f5e <xQueueGenericSend+0xb4>
    1f5c:	16 8e       	std	Z+30, r1	; 0x1e
    1f5e:	0f 90       	pop	r0
    1f60:	0f be       	out	0x3f, r0	; 63
    1f62:	be 01       	movw	r22, r28
    1f64:	6c 5f       	subi	r22, 0xFC	; 252
    1f66:	7f 4f       	sbci	r23, 0xFF	; 255
    1f68:	ce 01       	movw	r24, r28
    1f6a:	01 96       	adiw	r24, 0x01	; 1
    1f6c:	ce d6       	rcall	.+3484   	; 0x2d0a <xTaskCheckForTimeOut>
    1f6e:	81 11       	cpse	r24, r1
    1f70:	19 c0       	rjmp	.+50     	; 0x1fa4 <xQueueGenericSend+0xfa>
    1f72:	0f b6       	in	r0, 0x3f	; 63
    1f74:	f8 94       	cli
    1f76:	0f 92       	push	r0
    1f78:	f8 01       	movw	r30, r16
    1f7a:	92 8d       	ldd	r25, Z+26	; 0x1a
    1f7c:	0f 90       	pop	r0
    1f7e:	0f be       	out	0x3f, r0	; 63
    1f80:	83 8d       	ldd	r24, Z+27	; 0x1b
    1f82:	98 13       	cpse	r25, r24
    1f84:	0b c0       	rjmp	.+22     	; 0x1f9c <xQueueGenericSend+0xf2>
    1f86:	6c 81       	ldd	r22, Y+4	; 0x04
    1f88:	7d 81       	ldd	r23, Y+5	; 0x05
    1f8a:	c7 01       	movw	r24, r14
    1f8c:	42 d6       	rcall	.+3204   	; 0x2c12 <vTaskPlaceOnEventList>
    1f8e:	c8 01       	movw	r24, r16
    1f90:	d7 de       	rcall	.-594    	; 0x1d40 <prvUnlockQueue>
    1f92:	fd d4       	rcall	.+2554   	; 0x298e <xTaskResumeAll>
    1f94:	81 11       	cpse	r24, r1
    1f96:	a5 cf       	rjmp	.-182    	; 0x1ee2 <xQueueGenericSend+0x38>
    1f98:	9b dd       	rcall	.-1226   	; 0x1ad0 <vPortYield>
    1f9a:	a3 cf       	rjmp	.-186    	; 0x1ee2 <xQueueGenericSend+0x38>
    1f9c:	c8 01       	movw	r24, r16
    1f9e:	d0 de       	rcall	.-608    	; 0x1d40 <prvUnlockQueue>
    1fa0:	f6 d4       	rcall	.+2540   	; 0x298e <xTaskResumeAll>
    1fa2:	9f cf       	rjmp	.-194    	; 0x1ee2 <xQueueGenericSend+0x38>
    1fa4:	c8 01       	movw	r24, r16
    1fa6:	cc de       	rcall	.-616    	; 0x1d40 <prvUnlockQueue>
    1fa8:	f2 d4       	rcall	.+2532   	; 0x298e <xTaskResumeAll>
    1faa:	80 e0       	ldi	r24, 0x00	; 0
    1fac:	0f 90       	pop	r0
    1fae:	0f 90       	pop	r0
    1fb0:	0f 90       	pop	r0
    1fb2:	0f 90       	pop	r0
    1fb4:	0f 90       	pop	r0
    1fb6:	df 91       	pop	r29
    1fb8:	cf 91       	pop	r28
    1fba:	1f 91       	pop	r17
    1fbc:	0f 91       	pop	r16
    1fbe:	ff 90       	pop	r15
    1fc0:	ef 90       	pop	r14
    1fc2:	df 90       	pop	r13
    1fc4:	cf 90       	pop	r12
    1fc6:	bf 90       	pop	r11
    1fc8:	af 90       	pop	r10
    1fca:	9f 90       	pop	r9
    1fcc:	08 95       	ret

00001fce <xQueueCreateMutex>:
    1fce:	cf 93       	push	r28
    1fd0:	df 93       	push	r29
    1fd2:	48 2f       	mov	r20, r24
    1fd4:	60 e0       	ldi	r22, 0x00	; 0
    1fd6:	81 e0       	ldi	r24, 0x01	; 1
    1fd8:	3e df       	rcall	.-388    	; 0x1e56 <xQueueGenericCreate>
    1fda:	ec 01       	movw	r28, r24
    1fdc:	00 97       	sbiw	r24, 0x00	; 0
    1fde:	59 f0       	breq	.+22     	; 0x1ff6 <xQueueCreateMutex+0x28>
    1fe0:	1d 82       	std	Y+5, r1	; 0x05
    1fe2:	1c 82       	std	Y+4, r1	; 0x04
    1fe4:	19 82       	std	Y+1, r1	; 0x01
    1fe6:	18 82       	st	Y, r1
    1fe8:	1e 82       	std	Y+6, r1	; 0x06
    1fea:	20 e0       	ldi	r18, 0x00	; 0
    1fec:	40 e0       	ldi	r20, 0x00	; 0
    1fee:	50 e0       	ldi	r21, 0x00	; 0
    1ff0:	60 e0       	ldi	r22, 0x00	; 0
    1ff2:	70 e0       	ldi	r23, 0x00	; 0
    1ff4:	5a df       	rcall	.-332    	; 0x1eaa <xQueueGenericSend>
    1ff6:	ce 01       	movw	r24, r28
    1ff8:	df 91       	pop	r29
    1ffa:	cf 91       	pop	r28
    1ffc:	08 95       	ret

00001ffe <xQueueGenericSendFromISR>:
    1ffe:	ef 92       	push	r14
    2000:	ff 92       	push	r15
    2002:	0f 93       	push	r16
    2004:	1f 93       	push	r17
    2006:	cf 93       	push	r28
    2008:	df 93       	push	r29
    200a:	8a 01       	movw	r16, r20
    200c:	fc 01       	movw	r30, r24
    200e:	52 8d       	ldd	r21, Z+26	; 0x1a
    2010:	33 8d       	ldd	r19, Z+27	; 0x1b
    2012:	53 17       	cp	r21, r19
    2014:	10 f0       	brcs	.+4      	; 0x201a <xQueueGenericSendFromISR+0x1c>
    2016:	22 30       	cpi	r18, 0x02	; 2
    2018:	e1 f4       	brne	.+56     	; 0x2052 <xQueueGenericSendFromISR+0x54>
    201a:	42 2f       	mov	r20, r18
    201c:	78 01       	movw	r14, r16
    201e:	ec 01       	movw	r28, r24
    2020:	1e 8d       	ldd	r17, Y+30	; 0x1e
    2022:	15 de       	rcall	.-982    	; 0x1c4e <prvCopyDataToQueue>
    2024:	1f 3f       	cpi	r17, 0xFF	; 255
    2026:	79 f4       	brne	.+30     	; 0x2046 <xQueueGenericSendFromISR+0x48>
    2028:	89 89       	ldd	r24, Y+17	; 0x11
    202a:	88 23       	and	r24, r24
    202c:	a1 f0       	breq	.+40     	; 0x2056 <xQueueGenericSendFromISR+0x58>
    202e:	ce 01       	movw	r24, r28
    2030:	41 96       	adiw	r24, 0x11	; 17
    2032:	18 d6       	rcall	.+3120   	; 0x2c64 <xTaskRemoveFromEventList>
    2034:	88 23       	and	r24, r24
    2036:	89 f0       	breq	.+34     	; 0x205a <xQueueGenericSendFromISR+0x5c>
    2038:	e1 14       	cp	r14, r1
    203a:	f1 04       	cpc	r15, r1
    203c:	81 f0       	breq	.+32     	; 0x205e <xQueueGenericSendFromISR+0x60>
    203e:	81 e0       	ldi	r24, 0x01	; 1
    2040:	f7 01       	movw	r30, r14
    2042:	80 83       	st	Z, r24
    2044:	0d c0       	rjmp	.+26     	; 0x2060 <xQueueGenericSendFromISR+0x62>
    2046:	ff 24       	eor	r15, r15
    2048:	f3 94       	inc	r15
    204a:	f1 0e       	add	r15, r17
    204c:	fe 8e       	std	Y+30, r15	; 0x1e
    204e:	81 e0       	ldi	r24, 0x01	; 1
    2050:	07 c0       	rjmp	.+14     	; 0x2060 <xQueueGenericSendFromISR+0x62>
    2052:	80 e0       	ldi	r24, 0x00	; 0
    2054:	05 c0       	rjmp	.+10     	; 0x2060 <xQueueGenericSendFromISR+0x62>
    2056:	81 e0       	ldi	r24, 0x01	; 1
    2058:	03 c0       	rjmp	.+6      	; 0x2060 <xQueueGenericSendFromISR+0x62>
    205a:	81 e0       	ldi	r24, 0x01	; 1
    205c:	01 c0       	rjmp	.+2      	; 0x2060 <xQueueGenericSendFromISR+0x62>
    205e:	81 e0       	ldi	r24, 0x01	; 1
    2060:	df 91       	pop	r29
    2062:	cf 91       	pop	r28
    2064:	1f 91       	pop	r17
    2066:	0f 91       	pop	r16
    2068:	ff 90       	pop	r15
    206a:	ef 90       	pop	r14
    206c:	08 95       	ret

0000206e <xQueueReceive>:
    206e:	9f 92       	push	r9
    2070:	af 92       	push	r10
    2072:	bf 92       	push	r11
    2074:	cf 92       	push	r12
    2076:	df 92       	push	r13
    2078:	ef 92       	push	r14
    207a:	ff 92       	push	r15
    207c:	0f 93       	push	r16
    207e:	1f 93       	push	r17
    2080:	cf 93       	push	r28
    2082:	df 93       	push	r29
    2084:	00 d0       	rcall	.+0      	; 0x2086 <xQueueReceive+0x18>
    2086:	00 d0       	rcall	.+0      	; 0x2088 <xQueueReceive+0x1a>
    2088:	1f 92       	push	r1
    208a:	cd b7       	in	r28, 0x3d	; 61
    208c:	de b7       	in	r29, 0x3e	; 62
    208e:	8c 01       	movw	r16, r24
    2090:	5b 01       	movw	r10, r22
    2092:	5d 83       	std	Y+5, r21	; 0x05
    2094:	4c 83       	std	Y+4, r20	; 0x04
    2096:	e1 2c       	mov	r14, r1
    2098:	99 24       	eor	r9, r9
    209a:	93 94       	inc	r9
    209c:	6c 01       	movw	r12, r24
    209e:	81 e1       	ldi	r24, 0x11	; 17
    20a0:	c8 0e       	add	r12, r24
    20a2:	d1 1c       	adc	r13, r1
    20a4:	0f b6       	in	r0, 0x3f	; 63
    20a6:	f8 94       	cli
    20a8:	0f 92       	push	r0
    20aa:	f8 01       	movw	r30, r16
    20ac:	f2 8c       	ldd	r15, Z+26	; 0x1a
    20ae:	ff 20       	and	r15, r15
    20b0:	91 f0       	breq	.+36     	; 0x20d6 <xQueueReceive+0x68>
    20b2:	b5 01       	movw	r22, r10
    20b4:	c8 01       	movw	r24, r16
    20b6:	2a de       	rcall	.-940    	; 0x1d0c <prvCopyDataFromQueue>
    20b8:	fa 94       	dec	r15
    20ba:	f8 01       	movw	r30, r16
    20bc:	f2 8e       	std	Z+26, r15	; 0x1a
    20be:	80 85       	ldd	r24, Z+8	; 0x08
    20c0:	88 23       	and	r24, r24
    20c2:	29 f0       	breq	.+10     	; 0x20ce <xQueueReceive+0x60>
    20c4:	c8 01       	movw	r24, r16
    20c6:	08 96       	adiw	r24, 0x08	; 8
    20c8:	cd d5       	rcall	.+2970   	; 0x2c64 <xTaskRemoveFromEventList>
    20ca:	81 11       	cpse	r24, r1
    20cc:	01 dd       	rcall	.-1534   	; 0x1ad0 <vPortYield>
    20ce:	0f 90       	pop	r0
    20d0:	0f be       	out	0x3f, r0	; 63
    20d2:	81 e0       	ldi	r24, 0x01	; 1
    20d4:	44 c0       	rjmp	.+136    	; 0x215e <xQueueReceive+0xf0>
    20d6:	8c 81       	ldd	r24, Y+4	; 0x04
    20d8:	9d 81       	ldd	r25, Y+5	; 0x05
    20da:	89 2b       	or	r24, r25
    20dc:	21 f4       	brne	.+8      	; 0x20e6 <xQueueReceive+0x78>
    20de:	0f 90       	pop	r0
    20e0:	0f be       	out	0x3f, r0	; 63
    20e2:	80 e0       	ldi	r24, 0x00	; 0
    20e4:	3c c0       	rjmp	.+120    	; 0x215e <xQueueReceive+0xf0>
    20e6:	e1 10       	cpse	r14, r1
    20e8:	04 c0       	rjmp	.+8      	; 0x20f2 <xQueueReceive+0x84>
    20ea:	ce 01       	movw	r24, r28
    20ec:	01 96       	adiw	r24, 0x01	; 1
    20ee:	02 d6       	rcall	.+3076   	; 0x2cf4 <vTaskInternalSetTimeOutState>
    20f0:	e9 2c       	mov	r14, r9
    20f2:	0f 90       	pop	r0
    20f4:	0f be       	out	0x3f, r0	; 63
    20f6:	83 d3       	rcall	.+1798   	; 0x27fe <vTaskSuspendAll>
    20f8:	0f b6       	in	r0, 0x3f	; 63
    20fa:	f8 94       	cli
    20fc:	0f 92       	push	r0
    20fe:	f8 01       	movw	r30, r16
    2100:	85 8d       	ldd	r24, Z+29	; 0x1d
    2102:	8f 3f       	cpi	r24, 0xFF	; 255
    2104:	09 f4       	brne	.+2      	; 0x2108 <xQueueReceive+0x9a>
    2106:	15 8e       	std	Z+29, r1	; 0x1d
    2108:	f8 01       	movw	r30, r16
    210a:	86 8d       	ldd	r24, Z+30	; 0x1e
    210c:	8f 3f       	cpi	r24, 0xFF	; 255
    210e:	09 f4       	brne	.+2      	; 0x2112 <xQueueReceive+0xa4>
    2110:	16 8e       	std	Z+30, r1	; 0x1e
    2112:	0f 90       	pop	r0
    2114:	0f be       	out	0x3f, r0	; 63
    2116:	be 01       	movw	r22, r28
    2118:	6c 5f       	subi	r22, 0xFC	; 252
    211a:	7f 4f       	sbci	r23, 0xFF	; 255
    211c:	ce 01       	movw	r24, r28
    211e:	01 96       	adiw	r24, 0x01	; 1
    2120:	f4 d5       	rcall	.+3048   	; 0x2d0a <xTaskCheckForTimeOut>
    2122:	81 11       	cpse	r24, r1
    2124:	13 c0       	rjmp	.+38     	; 0x214c <xQueueReceive+0xde>
    2126:	c8 01       	movw	r24, r16
    2128:	87 dd       	rcall	.-1266   	; 0x1c38 <prvIsQueueEmpty>
    212a:	88 23       	and	r24, r24
    212c:	59 f0       	breq	.+22     	; 0x2144 <xQueueReceive+0xd6>
    212e:	6c 81       	ldd	r22, Y+4	; 0x04
    2130:	7d 81       	ldd	r23, Y+5	; 0x05
    2132:	c6 01       	movw	r24, r12
    2134:	6e d5       	rcall	.+2780   	; 0x2c12 <vTaskPlaceOnEventList>
    2136:	c8 01       	movw	r24, r16
    2138:	03 de       	rcall	.-1018   	; 0x1d40 <prvUnlockQueue>
    213a:	29 d4       	rcall	.+2130   	; 0x298e <xTaskResumeAll>
    213c:	81 11       	cpse	r24, r1
    213e:	b2 cf       	rjmp	.-156    	; 0x20a4 <xQueueReceive+0x36>
    2140:	c7 dc       	rcall	.-1650   	; 0x1ad0 <vPortYield>
    2142:	b0 cf       	rjmp	.-160    	; 0x20a4 <xQueueReceive+0x36>
    2144:	c8 01       	movw	r24, r16
    2146:	fc dd       	rcall	.-1032   	; 0x1d40 <prvUnlockQueue>
    2148:	22 d4       	rcall	.+2116   	; 0x298e <xTaskResumeAll>
    214a:	ac cf       	rjmp	.-168    	; 0x20a4 <xQueueReceive+0x36>
    214c:	c8 01       	movw	r24, r16
    214e:	f8 dd       	rcall	.-1040   	; 0x1d40 <prvUnlockQueue>
    2150:	1e d4       	rcall	.+2108   	; 0x298e <xTaskResumeAll>
    2152:	c8 01       	movw	r24, r16
    2154:	71 dd       	rcall	.-1310   	; 0x1c38 <prvIsQueueEmpty>
    2156:	88 23       	and	r24, r24
    2158:	09 f4       	brne	.+2      	; 0x215c <xQueueReceive+0xee>
    215a:	a4 cf       	rjmp	.-184    	; 0x20a4 <xQueueReceive+0x36>
    215c:	80 e0       	ldi	r24, 0x00	; 0
    215e:	0f 90       	pop	r0
    2160:	0f 90       	pop	r0
    2162:	0f 90       	pop	r0
    2164:	0f 90       	pop	r0
    2166:	0f 90       	pop	r0
    2168:	df 91       	pop	r29
    216a:	cf 91       	pop	r28
    216c:	1f 91       	pop	r17
    216e:	0f 91       	pop	r16
    2170:	ff 90       	pop	r15
    2172:	ef 90       	pop	r14
    2174:	df 90       	pop	r13
    2176:	cf 90       	pop	r12
    2178:	bf 90       	pop	r11
    217a:	af 90       	pop	r10
    217c:	9f 90       	pop	r9
    217e:	08 95       	ret

00002180 <xQueueSemaphoreTake>:
    2180:	bf 92       	push	r11
    2182:	cf 92       	push	r12
    2184:	df 92       	push	r13
    2186:	ef 92       	push	r14
    2188:	ff 92       	push	r15
    218a:	0f 93       	push	r16
    218c:	1f 93       	push	r17
    218e:	cf 93       	push	r28
    2190:	df 93       	push	r29
    2192:	00 d0       	rcall	.+0      	; 0x2194 <xQueueSemaphoreTake+0x14>
    2194:	00 d0       	rcall	.+0      	; 0x2196 <xQueueSemaphoreTake+0x16>
    2196:	1f 92       	push	r1
    2198:	cd b7       	in	r28, 0x3d	; 61
    219a:	de b7       	in	r29, 0x3e	; 62
    219c:	8c 01       	movw	r16, r24
    219e:	7d 83       	std	Y+5, r23	; 0x05
    21a0:	6c 83       	std	Y+4, r22	; 0x04
    21a2:	b1 2c       	mov	r11, r1
    21a4:	d1 2c       	mov	r13, r1
    21a6:	cc 24       	eor	r12, r12
    21a8:	c3 94       	inc	r12
    21aa:	7c 01       	movw	r14, r24
    21ac:	81 e1       	ldi	r24, 0x11	; 17
    21ae:	e8 0e       	add	r14, r24
    21b0:	f1 1c       	adc	r15, r1
    21b2:	0f b6       	in	r0, 0x3f	; 63
    21b4:	f8 94       	cli
    21b6:	0f 92       	push	r0
    21b8:	d8 01       	movw	r26, r16
    21ba:	5a 96       	adiw	r26, 0x1a	; 26
    21bc:	8c 91       	ld	r24, X
    21be:	5a 97       	sbiw	r26, 0x1a	; 26
    21c0:	88 23       	and	r24, r24
    21c2:	d1 f0       	breq	.+52     	; 0x21f8 <xQueueSemaphoreTake+0x78>
    21c4:	81 50       	subi	r24, 0x01	; 1
    21c6:	5a 96       	adiw	r26, 0x1a	; 26
    21c8:	8c 93       	st	X, r24
    21ca:	5a 97       	sbiw	r26, 0x1a	; 26
    21cc:	8d 91       	ld	r24, X+
    21ce:	9c 91       	ld	r25, X
    21d0:	89 2b       	or	r24, r25
    21d2:	21 f4       	brne	.+8      	; 0x21dc <xQueueSemaphoreTake+0x5c>
    21d4:	e3 d6       	rcall	.+3526   	; 0x2f9c <pvTaskIncrementMutexHeldCount>
    21d6:	f8 01       	movw	r30, r16
    21d8:	95 83       	std	Z+5, r25	; 0x05
    21da:	84 83       	std	Z+4, r24	; 0x04
    21dc:	d8 01       	movw	r26, r16
    21de:	18 96       	adiw	r26, 0x08	; 8
    21e0:	8c 91       	ld	r24, X
    21e2:	88 23       	and	r24, r24
    21e4:	29 f0       	breq	.+10     	; 0x21f0 <xQueueSemaphoreTake+0x70>
    21e6:	c8 01       	movw	r24, r16
    21e8:	08 96       	adiw	r24, 0x08	; 8
    21ea:	3c d5       	rcall	.+2680   	; 0x2c64 <xTaskRemoveFromEventList>
    21ec:	81 11       	cpse	r24, r1
    21ee:	70 dc       	rcall	.-1824   	; 0x1ad0 <vPortYield>
    21f0:	0f 90       	pop	r0
    21f2:	0f be       	out	0x3f, r0	; 63
    21f4:	81 e0       	ldi	r24, 0x01	; 1
    21f6:	70 c0       	rjmp	.+224    	; 0x22d8 <xQueueSemaphoreTake+0x158>
    21f8:	8c 81       	ldd	r24, Y+4	; 0x04
    21fa:	9d 81       	ldd	r25, Y+5	; 0x05
    21fc:	89 2b       	or	r24, r25
    21fe:	21 f4       	brne	.+8      	; 0x2208 <xQueueSemaphoreTake+0x88>
    2200:	0f 90       	pop	r0
    2202:	0f be       	out	0x3f, r0	; 63
    2204:	80 e0       	ldi	r24, 0x00	; 0
    2206:	68 c0       	rjmp	.+208    	; 0x22d8 <xQueueSemaphoreTake+0x158>
    2208:	d1 10       	cpse	r13, r1
    220a:	04 c0       	rjmp	.+8      	; 0x2214 <xQueueSemaphoreTake+0x94>
    220c:	ce 01       	movw	r24, r28
    220e:	01 96       	adiw	r24, 0x01	; 1
    2210:	71 d5       	rcall	.+2786   	; 0x2cf4 <vTaskInternalSetTimeOutState>
    2212:	dc 2c       	mov	r13, r12
    2214:	0f 90       	pop	r0
    2216:	0f be       	out	0x3f, r0	; 63
    2218:	f2 d2       	rcall	.+1508   	; 0x27fe <vTaskSuspendAll>
    221a:	0f b6       	in	r0, 0x3f	; 63
    221c:	f8 94       	cli
    221e:	0f 92       	push	r0
    2220:	f8 01       	movw	r30, r16
    2222:	85 8d       	ldd	r24, Z+29	; 0x1d
    2224:	8f 3f       	cpi	r24, 0xFF	; 255
    2226:	09 f4       	brne	.+2      	; 0x222a <xQueueSemaphoreTake+0xaa>
    2228:	15 8e       	std	Z+29, r1	; 0x1d
    222a:	d8 01       	movw	r26, r16
    222c:	5e 96       	adiw	r26, 0x1e	; 30
    222e:	8c 91       	ld	r24, X
    2230:	5e 97       	sbiw	r26, 0x1e	; 30
    2232:	8f 3f       	cpi	r24, 0xFF	; 255
    2234:	11 f4       	brne	.+4      	; 0x223a <xQueueSemaphoreTake+0xba>
    2236:	5e 96       	adiw	r26, 0x1e	; 30
    2238:	1c 92       	st	X, r1
    223a:	0f 90       	pop	r0
    223c:	0f be       	out	0x3f, r0	; 63
    223e:	be 01       	movw	r22, r28
    2240:	6c 5f       	subi	r22, 0xFC	; 252
    2242:	7f 4f       	sbci	r23, 0xFF	; 255
    2244:	ce 01       	movw	r24, r28
    2246:	01 96       	adiw	r24, 0x01	; 1
    2248:	60 d5       	rcall	.+2752   	; 0x2d0a <xTaskCheckForTimeOut>
    224a:	81 11       	cpse	r24, r1
    224c:	21 c0       	rjmp	.+66     	; 0x2290 <xQueueSemaphoreTake+0x110>
    224e:	c8 01       	movw	r24, r16
    2250:	f3 dc       	rcall	.-1562   	; 0x1c38 <prvIsQueueEmpty>
    2252:	88 23       	and	r24, r24
    2254:	c9 f0       	breq	.+50     	; 0x2288 <xQueueSemaphoreTake+0x108>
    2256:	f8 01       	movw	r30, r16
    2258:	80 81       	ld	r24, Z
    225a:	91 81       	ldd	r25, Z+1	; 0x01
    225c:	89 2b       	or	r24, r25
    225e:	49 f4       	brne	.+18     	; 0x2272 <xQueueSemaphoreTake+0xf2>
    2260:	0f b6       	in	r0, 0x3f	; 63
    2262:	f8 94       	cli
    2264:	0f 92       	push	r0
    2266:	84 81       	ldd	r24, Z+4	; 0x04
    2268:	95 81       	ldd	r25, Z+5	; 0x05
    226a:	96 d5       	rcall	.+2860   	; 0x2d98 <xTaskPriorityInherit>
    226c:	b8 2e       	mov	r11, r24
    226e:	0f 90       	pop	r0
    2270:	0f be       	out	0x3f, r0	; 63
    2272:	6c 81       	ldd	r22, Y+4	; 0x04
    2274:	7d 81       	ldd	r23, Y+5	; 0x05
    2276:	c7 01       	movw	r24, r14
    2278:	cc d4       	rcall	.+2456   	; 0x2c12 <vTaskPlaceOnEventList>
    227a:	c8 01       	movw	r24, r16
    227c:	61 dd       	rcall	.-1342   	; 0x1d40 <prvUnlockQueue>
    227e:	87 d3       	rcall	.+1806   	; 0x298e <xTaskResumeAll>
    2280:	81 11       	cpse	r24, r1
    2282:	97 cf       	rjmp	.-210    	; 0x21b2 <xQueueSemaphoreTake+0x32>
    2284:	25 dc       	rcall	.-1974   	; 0x1ad0 <vPortYield>
    2286:	95 cf       	rjmp	.-214    	; 0x21b2 <xQueueSemaphoreTake+0x32>
    2288:	c8 01       	movw	r24, r16
    228a:	5a dd       	rcall	.-1356   	; 0x1d40 <prvUnlockQueue>
    228c:	80 d3       	rcall	.+1792   	; 0x298e <xTaskResumeAll>
    228e:	91 cf       	rjmp	.-222    	; 0x21b2 <xQueueSemaphoreTake+0x32>
    2290:	c8 01       	movw	r24, r16
    2292:	56 dd       	rcall	.-1364   	; 0x1d40 <prvUnlockQueue>
    2294:	7c d3       	rcall	.+1784   	; 0x298e <xTaskResumeAll>
    2296:	c8 01       	movw	r24, r16
    2298:	cf dc       	rcall	.-1634   	; 0x1c38 <prvIsQueueEmpty>
    229a:	88 23       	and	r24, r24
    229c:	09 f4       	brne	.+2      	; 0x22a0 <xQueueSemaphoreTake+0x120>
    229e:	89 cf       	rjmp	.-238    	; 0x21b2 <xQueueSemaphoreTake+0x32>
    22a0:	bb 20       	and	r11, r11
    22a2:	c9 f0       	breq	.+50     	; 0x22d6 <xQueueSemaphoreTake+0x156>
    22a4:	0f b6       	in	r0, 0x3f	; 63
    22a6:	f8 94       	cli
    22a8:	0f 92       	push	r0
    22aa:	f8 01       	movw	r30, r16
    22ac:	81 89       	ldd	r24, Z+17	; 0x11
    22ae:	88 23       	and	r24, r24
    22b0:	39 f0       	breq	.+14     	; 0x22c0 <xQueueSemaphoreTake+0x140>
    22b2:	06 88       	ldd	r0, Z+22	; 0x16
    22b4:	f7 89       	ldd	r31, Z+23	; 0x17
    22b6:	e0 2d       	mov	r30, r0
    22b8:	80 81       	ld	r24, Z
    22ba:	65 e0       	ldi	r22, 0x05	; 5
    22bc:	68 1b       	sub	r22, r24
    22be:	01 c0       	rjmp	.+2      	; 0x22c2 <xQueueSemaphoreTake+0x142>
    22c0:	60 e0       	ldi	r22, 0x00	; 0
    22c2:	d8 01       	movw	r26, r16
    22c4:	14 96       	adiw	r26, 0x04	; 4
    22c6:	8d 91       	ld	r24, X+
    22c8:	9c 91       	ld	r25, X
    22ca:	15 97       	sbiw	r26, 0x05	; 5
    22cc:	17 d6       	rcall	.+3118   	; 0x2efc <vTaskPriorityDisinheritAfterTimeout>
    22ce:	0f 90       	pop	r0
    22d0:	0f be       	out	0x3f, r0	; 63
    22d2:	80 e0       	ldi	r24, 0x00	; 0
    22d4:	01 c0       	rjmp	.+2      	; 0x22d8 <xQueueSemaphoreTake+0x158>
    22d6:	80 e0       	ldi	r24, 0x00	; 0
    22d8:	0f 90       	pop	r0
    22da:	0f 90       	pop	r0
    22dc:	0f 90       	pop	r0
    22de:	0f 90       	pop	r0
    22e0:	0f 90       	pop	r0
    22e2:	df 91       	pop	r29
    22e4:	cf 91       	pop	r28
    22e6:	1f 91       	pop	r17
    22e8:	0f 91       	pop	r16
    22ea:	ff 90       	pop	r15
    22ec:	ef 90       	pop	r14
    22ee:	df 90       	pop	r13
    22f0:	cf 90       	pop	r12
    22f2:	bf 90       	pop	r11
    22f4:	08 95       	ret

000022f6 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if ( configUSE_TIMERS == 1 )

	void vQueueWaitForMessageRestricted( QueueHandle_t xQueue, TickType_t xTicksToWait, const BaseType_t xWaitIndefinitely )
	{
    22f6:	cf 93       	push	r28
    22f8:	df 93       	push	r29
    22fa:	ec 01       	movw	r28, r24
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    22fc:	0f b6       	in	r0, 0x3f	; 63
    22fe:	f8 94       	cli
    2300:	0f 92       	push	r0
    2302:	8d 8d       	ldd	r24, Y+29	; 0x1d
    2304:	8f 3f       	cpi	r24, 0xFF	; 255
    2306:	09 f4       	brne	.+2      	; 0x230a <vQueueWaitForMessageRestricted+0x14>
    2308:	1d 8e       	std	Y+29, r1	; 0x1d
    230a:	8e 8d       	ldd	r24, Y+30	; 0x1e
    230c:	8f 3f       	cpi	r24, 0xFF	; 255
    230e:	09 f4       	brne	.+2      	; 0x2312 <vQueueWaitForMessageRestricted+0x1c>
    2310:	1e 8e       	std	Y+30, r1	; 0x1e
    2312:	0f 90       	pop	r0
    2314:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( UBaseType_t ) 0U )
    2316:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2318:	81 11       	cpse	r24, r1
    231a:	03 c0       	rjmp	.+6      	; 0x2322 <vQueueWaitForMessageRestricted+0x2c>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait, xWaitIndefinitely );
    231c:	ce 01       	movw	r24, r28
    231e:	41 96       	adiw	r24, 0x11	; 17
    2320:	89 d4       	rcall	.+2322   	; 0x2c34 <vTaskPlaceOnEventListRestricted>
		}
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
		prvUnlockQueue( pxQueue );
    2322:	ce 01       	movw	r24, r28
    2324:	0d dd       	rcall	.-1510   	; 0x1d40 <prvUnlockQueue>
	}
    2326:	df 91       	pop	r29
    2328:	cf 91       	pop	r28
    232a:	08 95       	ret

0000232c <prvResetNextTaskUnblockTime>:
	/* Reset the event list item to its normal value - so it can be used with
	queues and semaphores. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */

	return uxReturn;
}
    232c:	e0 91 bb 07 	lds	r30, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    2330:	f0 91 bc 07 	lds	r31, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    2334:	80 81       	ld	r24, Z
    2336:	81 11       	cpse	r24, r1
    2338:	07 c0       	rjmp	.+14     	; 0x2348 <prvResetNextTaskUnblockTime+0x1c>
    233a:	8f ef       	ldi	r24, 0xFF	; 255
    233c:	9f ef       	ldi	r25, 0xFF	; 255
    233e:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    2342:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    2346:	08 95       	ret
    2348:	e0 91 bb 07 	lds	r30, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    234c:	f0 91 bc 07 	lds	r31, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    2350:	05 80       	ldd	r0, Z+5	; 0x05
    2352:	f6 81       	ldd	r31, Z+6	; 0x06
    2354:	e0 2d       	mov	r30, r0
    2356:	06 80       	ldd	r0, Z+6	; 0x06
    2358:	f7 81       	ldd	r31, Z+7	; 0x07
    235a:	e0 2d       	mov	r30, r0
    235c:	82 81       	ldd	r24, Z+2	; 0x02
    235e:	93 81       	ldd	r25, Z+3	; 0x03
    2360:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    2364:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    2368:	08 95       	ret

0000236a <prvIdleTask>:
    236a:	07 ea       	ldi	r16, 0xA7	; 167
    236c:	17 e0       	ldi	r17, 0x07	; 7
    236e:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <uxDeletedTasksWaitingCleanUp>
    2372:	88 23       	and	r24, r24
    2374:	e1 f3       	breq	.-8      	; 0x236e <prvIdleTask+0x4>
    2376:	0f b6       	in	r0, 0x3f	; 63
    2378:	f8 94       	cli
    237a:	0f 92       	push	r0
    237c:	d8 01       	movw	r26, r16
    237e:	15 96       	adiw	r26, 0x05	; 5
    2380:	ed 91       	ld	r30, X+
    2382:	fc 91       	ld	r31, X
    2384:	16 97       	sbiw	r26, 0x06	; 6
    2386:	c6 81       	ldd	r28, Z+6	; 0x06
    2388:	d7 81       	ldd	r29, Z+7	; 0x07
    238a:	ce 01       	movw	r24, r28
    238c:	02 96       	adiw	r24, 0x02	; 2
    238e:	d8 da       	rcall	.-2640   	; 0x1940 <uxListRemove>
    2390:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    2394:	81 50       	subi	r24, 0x01	; 1
    2396:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxCurrentNumberOfTasks>
    239a:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <uxDeletedTasksWaitingCleanUp>
    239e:	81 50       	subi	r24, 0x01	; 1
    23a0:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <uxDeletedTasksWaitingCleanUp>
    23a4:	0f 90       	pop	r0
    23a6:	0f be       	out	0x3f, r0	; 63
    23a8:	8f 89       	ldd	r24, Y+23	; 0x17
    23aa:	98 8d       	ldd	r25, Y+24	; 0x18
    23ac:	35 da       	rcall	.-2966   	; 0x1818 <vPortFree>
    23ae:	ce 01       	movw	r24, r28
    23b0:	33 da       	rcall	.-2970   	; 0x1818 <vPortFree>
    23b2:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <uxDeletedTasksWaitingCleanUp>
    23b6:	81 11       	cpse	r24, r1
    23b8:	de cf       	rjmp	.-68     	; 0x2376 <prvIdleTask+0xc>
    23ba:	d9 cf       	rjmp	.-78     	; 0x236e <prvIdleTask+0x4>

000023bc <prvAddCurrentTaskToDelayedList>:
    23bc:	ff 92       	push	r15
    23be:	0f 93       	push	r16
    23c0:	1f 93       	push	r17
    23c2:	cf 93       	push	r28
    23c4:	df 93       	push	r29
    23c6:	ec 01       	movw	r28, r24
    23c8:	f6 2e       	mov	r15, r22
    23ca:	00 91 9a 07 	lds	r16, 0x079A	; 0x80079a <xTickCount>
    23ce:	10 91 9b 07 	lds	r17, 0x079B	; 0x80079b <xTickCount+0x1>
    23d2:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTCB>
    23d6:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    23da:	02 96       	adiw	r24, 0x02	; 2
    23dc:	b1 da       	rcall	.-2718   	; 0x1940 <uxListRemove>
    23de:	cf 3f       	cpi	r28, 0xFF	; 255
    23e0:	8f ef       	ldi	r24, 0xFF	; 255
    23e2:	d8 07       	cpc	r29, r24
    23e4:	61 f4       	brne	.+24     	; 0x23fe <prvAddCurrentTaskToDelayedList+0x42>
    23e6:	ff 20       	and	r15, r15
    23e8:	51 f0       	breq	.+20     	; 0x23fe <prvAddCurrentTaskToDelayedList+0x42>
    23ea:	60 91 fc 07 	lds	r22, 0x07FC	; 0x8007fc <pxCurrentTCB>
    23ee:	70 91 fd 07 	lds	r23, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    23f2:	6e 5f       	subi	r22, 0xFE	; 254
    23f4:	7f 4f       	sbci	r23, 0xFF	; 255
    23f6:	8d e9       	ldi	r24, 0x9D	; 157
    23f8:	97 e0       	ldi	r25, 0x07	; 7
    23fa:	50 da       	rcall	.-2912   	; 0x189c <vListInsertEnd>
    23fc:	2d c0       	rjmp	.+90     	; 0x2458 <prvAddCurrentTaskToDelayedList+0x9c>
    23fe:	c0 0f       	add	r28, r16
    2400:	d1 1f       	adc	r29, r17
    2402:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2406:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    240a:	d3 83       	std	Z+3, r29	; 0x03
    240c:	c2 83       	std	Z+2, r28	; 0x02
    240e:	c0 17       	cp	r28, r16
    2410:	d1 07       	cpc	r29, r17
    2412:	60 f4       	brcc	.+24     	; 0x242c <prvAddCurrentTaskToDelayedList+0x70>
    2414:	60 91 fc 07 	lds	r22, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2418:	70 91 fd 07 	lds	r23, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    241c:	80 91 b9 07 	lds	r24, 0x07B9	; 0x8007b9 <pxOverflowDelayedTaskList>
    2420:	90 91 ba 07 	lds	r25, 0x07BA	; 0x8007ba <pxOverflowDelayedTaskList+0x1>
    2424:	6e 5f       	subi	r22, 0xFE	; 254
    2426:	7f 4f       	sbci	r23, 0xFF	; 255
    2428:	5a da       	rcall	.-2892   	; 0x18de <vListInsert>
    242a:	16 c0       	rjmp	.+44     	; 0x2458 <prvAddCurrentTaskToDelayedList+0x9c>
    242c:	60 91 fc 07 	lds	r22, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2430:	70 91 fd 07 	lds	r23, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2434:	80 91 bb 07 	lds	r24, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    2438:	90 91 bc 07 	lds	r25, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    243c:	6e 5f       	subi	r22, 0xFE	; 254
    243e:	7f 4f       	sbci	r23, 0xFF	; 255
    2440:	4e da       	rcall	.-2916   	; 0x18de <vListInsert>
    2442:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <xNextTaskUnblockTime>
    2446:	90 91 93 07 	lds	r25, 0x0793	; 0x800793 <xNextTaskUnblockTime+0x1>
    244a:	c8 17       	cp	r28, r24
    244c:	d9 07       	cpc	r29, r25
    244e:	20 f4       	brcc	.+8      	; 0x2458 <prvAddCurrentTaskToDelayedList+0x9c>
    2450:	d0 93 93 07 	sts	0x0793, r29	; 0x800793 <xNextTaskUnblockTime+0x1>
    2454:	c0 93 92 07 	sts	0x0792, r28	; 0x800792 <xNextTaskUnblockTime>
    2458:	df 91       	pop	r29
    245a:	cf 91       	pop	r28
    245c:	1f 91       	pop	r17
    245e:	0f 91       	pop	r16
    2460:	ff 90       	pop	r15
    2462:	08 95       	ret

00002464 <xTaskCreate>:
    2464:	4f 92       	push	r4
    2466:	5f 92       	push	r5
    2468:	6f 92       	push	r6
    246a:	7f 92       	push	r7
    246c:	8f 92       	push	r8
    246e:	9f 92       	push	r9
    2470:	af 92       	push	r10
    2472:	bf 92       	push	r11
    2474:	cf 92       	push	r12
    2476:	df 92       	push	r13
    2478:	ef 92       	push	r14
    247a:	ff 92       	push	r15
    247c:	0f 93       	push	r16
    247e:	1f 93       	push	r17
    2480:	cf 93       	push	r28
    2482:	df 93       	push	r29
    2484:	4c 01       	movw	r8, r24
    2486:	6b 01       	movw	r12, r22
    2488:	5a 01       	movw	r10, r20
    248a:	29 01       	movw	r4, r18
    248c:	ca 01       	movw	r24, r20
    248e:	09 d9       	rcall	.-3566   	; 0x16a2 <pvPortMalloc>
    2490:	3c 01       	movw	r6, r24
    2492:	89 2b       	or	r24, r25
    2494:	09 f4       	brne	.+2      	; 0x2498 <xTaskCreate+0x34>
    2496:	dc c0       	rjmp	.+440    	; 0x2650 <xTaskCreate+0x1ec>
    2498:	88 e2       	ldi	r24, 0x28	; 40
    249a:	90 e0       	ldi	r25, 0x00	; 0
    249c:	02 d9       	rcall	.-3580   	; 0x16a2 <pvPortMalloc>
    249e:	ec 01       	movw	r28, r24
    24a0:	89 2b       	or	r24, r25
    24a2:	59 f0       	breq	.+22     	; 0x24ba <xTaskCreate+0x56>
    24a4:	78 8e       	std	Y+24, r7	; 0x18
    24a6:	6f 8a       	std	Y+23, r6	; 0x17
    24a8:	81 e0       	ldi	r24, 0x01	; 1
    24aa:	a8 1a       	sub	r10, r24
    24ac:	b1 08       	sbc	r11, r1
    24ae:	6a 0c       	add	r6, r10
    24b0:	7b 1c       	adc	r7, r11
    24b2:	c1 14       	cp	r12, r1
    24b4:	d1 04       	cpc	r13, r1
    24b6:	21 f4       	brne	.+8      	; 0x24c0 <xTaskCreate+0x5c>
    24b8:	1f c0       	rjmp	.+62     	; 0x24f8 <xTaskCreate+0x94>
    24ba:	c3 01       	movw	r24, r6
    24bc:	ad d9       	rcall	.-3238   	; 0x1818 <vPortFree>
    24be:	c8 c0       	rjmp	.+400    	; 0x2650 <xTaskCreate+0x1ec>
    24c0:	d6 01       	movw	r26, r12
    24c2:	8c 91       	ld	r24, X
    24c4:	89 8f       	std	Y+25, r24	; 0x19
    24c6:	8c 91       	ld	r24, X
    24c8:	88 23       	and	r24, r24
    24ca:	a1 f0       	breq	.+40     	; 0x24f4 <xTaskCreate+0x90>
    24cc:	ae 01       	movw	r20, r28
    24ce:	46 5e       	subi	r20, 0xE6	; 230
    24d0:	5f 4f       	sbci	r21, 0xFF	; 255
    24d2:	f6 01       	movw	r30, r12
    24d4:	31 96       	adiw	r30, 0x01	; 1
    24d6:	b8 e0       	ldi	r27, 0x08	; 8
    24d8:	cb 0e       	add	r12, r27
    24da:	d1 1c       	adc	r13, r1
    24dc:	cf 01       	movw	r24, r30
    24de:	21 91       	ld	r18, Z+
    24e0:	da 01       	movw	r26, r20
    24e2:	2d 93       	st	X+, r18
    24e4:	ad 01       	movw	r20, r26
    24e6:	dc 01       	movw	r26, r24
    24e8:	8c 91       	ld	r24, X
    24ea:	88 23       	and	r24, r24
    24ec:	19 f0       	breq	.+6      	; 0x24f4 <xTaskCreate+0x90>
    24ee:	ce 16       	cp	r12, r30
    24f0:	df 06       	cpc	r13, r31
    24f2:	a1 f7       	brne	.-24     	; 0x24dc <xTaskCreate+0x78>
    24f4:	18 a2       	std	Y+32, r1	; 0x20
    24f6:	01 c0       	rjmp	.+2      	; 0x24fa <xTaskCreate+0x96>
    24f8:	19 8e       	std	Y+25, r1	; 0x19
    24fa:	05 30       	cpi	r16, 0x05	; 5
    24fc:	08 f0       	brcs	.+2      	; 0x2500 <xTaskCreate+0x9c>
    24fe:	04 e0       	ldi	r16, 0x04	; 4
    2500:	0e 8b       	std	Y+22, r16	; 0x16
    2502:	09 a3       	std	Y+33, r16	; 0x21
    2504:	1a a2       	std	Y+34, r1	; 0x22
    2506:	6e 01       	movw	r12, r28
    2508:	b2 e0       	ldi	r27, 0x02	; 2
    250a:	cb 0e       	add	r12, r27
    250c:	d1 1c       	adc	r13, r1
    250e:	c6 01       	movw	r24, r12
    2510:	c1 d9       	rcall	.-3198   	; 0x1894 <vListInitialiseItem>
    2512:	ce 01       	movw	r24, r28
    2514:	0c 96       	adiw	r24, 0x0c	; 12
    2516:	be d9       	rcall	.-3204   	; 0x1894 <vListInitialiseItem>
    2518:	d9 87       	std	Y+9, r29	; 0x09
    251a:	c8 87       	std	Y+8, r28	; 0x08
    251c:	85 e0       	ldi	r24, 0x05	; 5
    251e:	90 e0       	ldi	r25, 0x00	; 0
    2520:	80 1b       	sub	r24, r16
    2522:	91 09       	sbc	r25, r1
    2524:	9d 87       	std	Y+13, r25	; 0x0d
    2526:	8c 87       	std	Y+12, r24	; 0x0c
    2528:	db 8b       	std	Y+19, r29	; 0x13
    252a:	ca 8b       	std	Y+18, r28	; 0x12
    252c:	1b a2       	std	Y+35, r1	; 0x23
    252e:	1c a2       	std	Y+36, r1	; 0x24
    2530:	1d a2       	std	Y+37, r1	; 0x25
    2532:	1e a2       	std	Y+38, r1	; 0x26
    2534:	1f a2       	std	Y+39, r1	; 0x27
    2536:	a2 01       	movw	r20, r4
    2538:	b4 01       	movw	r22, r8
    253a:	c3 01       	movw	r24, r6
    253c:	28 da       	rcall	.-2992   	; 0x198e <pxPortInitialiseStack>
    253e:	99 83       	std	Y+1, r25	; 0x01
    2540:	88 83       	st	Y, r24
    2542:	e1 14       	cp	r14, r1
    2544:	f1 04       	cpc	r15, r1
    2546:	19 f0       	breq	.+6      	; 0x254e <xTaskCreate+0xea>
    2548:	f7 01       	movw	r30, r14
    254a:	d1 83       	std	Z+1, r29	; 0x01
    254c:	c0 83       	st	Z, r28
    254e:	0f b6       	in	r0, 0x3f	; 63
    2550:	f8 94       	cli
    2552:	0f 92       	push	r0
    2554:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    2558:	8f 5f       	subi	r24, 0xFF	; 255
    255a:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxCurrentNumberOfTasks>
    255e:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2562:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2566:	89 2b       	or	r24, r25
    2568:	a1 f5       	brne	.+104    	; 0x25d2 <xTaskCreate+0x16e>
    256a:	d0 93 fd 07 	sts	0x07FD, r29	; 0x8007fd <pxCurrentTCB+0x1>
    256e:	c0 93 fc 07 	sts	0x07FC, r28	; 0x8007fc <pxCurrentTCB>
    2572:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    2576:	81 30       	cpi	r24, 0x01	; 1
    2578:	09 f0       	breq	.+2      	; 0x257c <xTaskCreate+0x118>
    257a:	3b c0       	rjmp	.+118    	; 0x25f2 <xTaskCreate+0x18e>
    257c:	0f ec       	ldi	r16, 0xCF	; 207
    257e:	17 e0       	ldi	r17, 0x07	; 7
    2580:	0f 2e       	mov	r0, r31
    2582:	fc ef       	ldi	r31, 0xFC	; 252
    2584:	ef 2e       	mov	r14, r31
    2586:	f7 e0       	ldi	r31, 0x07	; 7
    2588:	ff 2e       	mov	r15, r31
    258a:	f0 2d       	mov	r31, r0
    258c:	c8 01       	movw	r24, r16
    258e:	74 d9       	rcall	.-3352   	; 0x1878 <vListInitialise>
    2590:	07 5f       	subi	r16, 0xF7	; 247
    2592:	1f 4f       	sbci	r17, 0xFF	; 255
    2594:	0e 15       	cp	r16, r14
    2596:	1f 05       	cpc	r17, r15
    2598:	c9 f7       	brne	.-14     	; 0x258c <xTaskCreate+0x128>
    259a:	86 ec       	ldi	r24, 0xC6	; 198
    259c:	97 e0       	ldi	r25, 0x07	; 7
    259e:	6c d9       	rcall	.-3368   	; 0x1878 <vListInitialise>
    25a0:	8d eb       	ldi	r24, 0xBD	; 189
    25a2:	97 e0       	ldi	r25, 0x07	; 7
    25a4:	69 d9       	rcall	.-3374   	; 0x1878 <vListInitialise>
    25a6:	80 eb       	ldi	r24, 0xB0	; 176
    25a8:	97 e0       	ldi	r25, 0x07	; 7
    25aa:	66 d9       	rcall	.-3380   	; 0x1878 <vListInitialise>
    25ac:	87 ea       	ldi	r24, 0xA7	; 167
    25ae:	97 e0       	ldi	r25, 0x07	; 7
    25b0:	63 d9       	rcall	.-3386   	; 0x1878 <vListInitialise>
    25b2:	8d e9       	ldi	r24, 0x9D	; 157
    25b4:	97 e0       	ldi	r25, 0x07	; 7
    25b6:	60 d9       	rcall	.-3392   	; 0x1878 <vListInitialise>
    25b8:	86 ec       	ldi	r24, 0xC6	; 198
    25ba:	97 e0       	ldi	r25, 0x07	; 7
    25bc:	90 93 bc 07 	sts	0x07BC, r25	; 0x8007bc <pxDelayedTaskList+0x1>
    25c0:	80 93 bb 07 	sts	0x07BB, r24	; 0x8007bb <pxDelayedTaskList>
    25c4:	8d eb       	ldi	r24, 0xBD	; 189
    25c6:	97 e0       	ldi	r25, 0x07	; 7
    25c8:	90 93 ba 07 	sts	0x07BA, r25	; 0x8007ba <pxOverflowDelayedTaskList+0x1>
    25cc:	80 93 b9 07 	sts	0x07B9, r24	; 0x8007b9 <pxOverflowDelayedTaskList>
    25d0:	10 c0       	rjmp	.+32     	; 0x25f2 <xTaskCreate+0x18e>
    25d2:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xSchedulerRunning>
    25d6:	81 11       	cpse	r24, r1
    25d8:	0c c0       	rjmp	.+24     	; 0x25f2 <xTaskCreate+0x18e>
    25da:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    25de:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    25e2:	96 89       	ldd	r25, Z+22	; 0x16
    25e4:	8e 89       	ldd	r24, Y+22	; 0x16
    25e6:	89 17       	cp	r24, r25
    25e8:	20 f0       	brcs	.+8      	; 0x25f2 <xTaskCreate+0x18e>
    25ea:	d0 93 fd 07 	sts	0x07FD, r29	; 0x8007fd <pxCurrentTCB+0x1>
    25ee:	c0 93 fc 07 	sts	0x07FC, r28	; 0x8007fc <pxCurrentTCB>
    25f2:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <uxTaskNumber>
    25f6:	8f 5f       	subi	r24, 0xFF	; 255
    25f8:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <uxTaskNumber>
    25fc:	8e 89       	ldd	r24, Y+22	; 0x16
    25fe:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    2602:	98 17       	cp	r25, r24
    2604:	10 f4       	brcc	.+4      	; 0x260a <xTaskCreate+0x1a6>
    2606:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    260a:	90 e0       	ldi	r25, 0x00	; 0
    260c:	9c 01       	movw	r18, r24
    260e:	22 0f       	add	r18, r18
    2610:	33 1f       	adc	r19, r19
    2612:	22 0f       	add	r18, r18
    2614:	33 1f       	adc	r19, r19
    2616:	22 0f       	add	r18, r18
    2618:	33 1f       	adc	r19, r19
    261a:	82 0f       	add	r24, r18
    261c:	93 1f       	adc	r25, r19
    261e:	b6 01       	movw	r22, r12
    2620:	81 53       	subi	r24, 0x31	; 49
    2622:	98 4f       	sbci	r25, 0xF8	; 248
    2624:	3b d9       	rcall	.-3466   	; 0x189c <vListInsertEnd>
    2626:	0f 90       	pop	r0
    2628:	0f be       	out	0x3f, r0	; 63
    262a:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xSchedulerRunning>
    262e:	88 23       	and	r24, r24
    2630:	59 f0       	breq	.+22     	; 0x2648 <xTaskCreate+0x1e4>
    2632:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2636:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    263a:	96 89       	ldd	r25, Z+22	; 0x16
    263c:	8e 89       	ldd	r24, Y+22	; 0x16
    263e:	98 17       	cp	r25, r24
    2640:	28 f4       	brcc	.+10     	; 0x264c <xTaskCreate+0x1e8>
    2642:	46 da       	rcall	.-2932   	; 0x1ad0 <vPortYield>
    2644:	81 e0       	ldi	r24, 0x01	; 1
    2646:	05 c0       	rjmp	.+10     	; 0x2652 <xTaskCreate+0x1ee>
    2648:	81 e0       	ldi	r24, 0x01	; 1
    264a:	03 c0       	rjmp	.+6      	; 0x2652 <xTaskCreate+0x1ee>
    264c:	81 e0       	ldi	r24, 0x01	; 1
    264e:	01 c0       	rjmp	.+2      	; 0x2652 <xTaskCreate+0x1ee>
    2650:	8f ef       	ldi	r24, 0xFF	; 255
    2652:	df 91       	pop	r29
    2654:	cf 91       	pop	r28
    2656:	1f 91       	pop	r17
    2658:	0f 91       	pop	r16
    265a:	ff 90       	pop	r15
    265c:	ef 90       	pop	r14
    265e:	df 90       	pop	r13
    2660:	cf 90       	pop	r12
    2662:	bf 90       	pop	r11
    2664:	af 90       	pop	r10
    2666:	9f 90       	pop	r9
    2668:	8f 90       	pop	r8
    266a:	7f 90       	pop	r7
    266c:	6f 90       	pop	r6
    266e:	5f 90       	pop	r5
    2670:	4f 90       	pop	r4
    2672:	08 95       	ret

00002674 <vTaskDelete>:
    2674:	0f 93       	push	r16
    2676:	1f 93       	push	r17
    2678:	cf 93       	push	r28
    267a:	df 93       	push	r29
    267c:	ec 01       	movw	r28, r24
    267e:	0f b6       	in	r0, 0x3f	; 63
    2680:	f8 94       	cli
    2682:	0f 92       	push	r0
    2684:	89 2b       	or	r24, r25
    2686:	21 f4       	brne	.+8      	; 0x2690 <vTaskDelete+0x1c>
    2688:	c0 91 fc 07 	lds	r28, 0x07FC	; 0x8007fc <pxCurrentTCB>
    268c:	d0 91 fd 07 	lds	r29, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2690:	8e 01       	movw	r16, r28
    2692:	0e 5f       	subi	r16, 0xFE	; 254
    2694:	1f 4f       	sbci	r17, 0xFF	; 255
    2696:	c8 01       	movw	r24, r16
    2698:	53 d9       	rcall	.-3418   	; 0x1940 <uxListRemove>
    269a:	8c 89       	ldd	r24, Y+20	; 0x14
    269c:	9d 89       	ldd	r25, Y+21	; 0x15
    269e:	89 2b       	or	r24, r25
    26a0:	19 f0       	breq	.+6      	; 0x26a8 <vTaskDelete+0x34>
    26a2:	ce 01       	movw	r24, r28
    26a4:	0c 96       	adiw	r24, 0x0c	; 12
    26a6:	4c d9       	rcall	.-3432   	; 0x1940 <uxListRemove>
    26a8:	80 91 94 07 	lds	r24, 0x0794	; 0x800794 <uxTaskNumber>
    26ac:	8f 5f       	subi	r24, 0xFF	; 255
    26ae:	80 93 94 07 	sts	0x0794, r24	; 0x800794 <uxTaskNumber>
    26b2:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTCB>
    26b6:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    26ba:	c8 17       	cp	r28, r24
    26bc:	d9 07       	cpc	r29, r25
    26be:	51 f4       	brne	.+20     	; 0x26d4 <vTaskDelete+0x60>
    26c0:	b8 01       	movw	r22, r16
    26c2:	87 ea       	ldi	r24, 0xA7	; 167
    26c4:	97 e0       	ldi	r25, 0x07	; 7
    26c6:	ea d8       	rcall	.-3628   	; 0x189c <vListInsertEnd>
    26c8:	80 91 a6 07 	lds	r24, 0x07A6	; 0x8007a6 <uxDeletedTasksWaitingCleanUp>
    26cc:	8f 5f       	subi	r24, 0xFF	; 255
    26ce:	80 93 a6 07 	sts	0x07A6, r24	; 0x8007a6 <uxDeletedTasksWaitingCleanUp>
    26d2:	0b c0       	rjmp	.+22     	; 0x26ea <vTaskDelete+0x76>
    26d4:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    26d8:	81 50       	subi	r24, 0x01	; 1
    26da:	80 93 9c 07 	sts	0x079C, r24	; 0x80079c <uxCurrentNumberOfTasks>
    26de:	8f 89       	ldd	r24, Y+23	; 0x17
    26e0:	98 8d       	ldd	r25, Y+24	; 0x18
    26e2:	9a d8       	rcall	.-3788   	; 0x1818 <vPortFree>
    26e4:	ce 01       	movw	r24, r28
    26e6:	98 d8       	rcall	.-3792   	; 0x1818 <vPortFree>
    26e8:	21 de       	rcall	.-958    	; 0x232c <prvResetNextTaskUnblockTime>
    26ea:	0f 90       	pop	r0
    26ec:	0f be       	out	0x3f, r0	; 63
    26ee:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xSchedulerRunning>
    26f2:	88 23       	and	r24, r24
    26f4:	41 f0       	breq	.+16     	; 0x2706 <vTaskDelete+0x92>
    26f6:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTCB>
    26fa:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    26fe:	c8 17       	cp	r28, r24
    2700:	d9 07       	cpc	r29, r25
    2702:	09 f4       	brne	.+2      	; 0x2706 <vTaskDelete+0x92>
    2704:	e5 d9       	rcall	.-3126   	; 0x1ad0 <vPortYield>
    2706:	df 91       	pop	r29
    2708:	cf 91       	pop	r28
    270a:	1f 91       	pop	r17
    270c:	0f 91       	pop	r16
    270e:	08 95       	ret

00002710 <vTaskResume>:
    2710:	0f 93       	push	r16
    2712:	1f 93       	push	r17
    2714:	cf 93       	push	r28
    2716:	df 93       	push	r29
    2718:	20 91 fc 07 	lds	r18, 0x07FC	; 0x8007fc <pxCurrentTCB>
    271c:	30 91 fd 07 	lds	r19, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2720:	82 17       	cp	r24, r18
    2722:	93 07       	cpc	r25, r19
    2724:	09 f4       	brne	.+2      	; 0x2728 <vTaskResume+0x18>
    2726:	3b c0       	rjmp	.+118    	; 0x279e <vTaskResume+0x8e>
    2728:	00 97       	sbiw	r24, 0x00	; 0
    272a:	09 f4       	brne	.+2      	; 0x272e <vTaskResume+0x1e>
    272c:	38 c0       	rjmp	.+112    	; 0x279e <vTaskResume+0x8e>
    272e:	0f b6       	in	r0, 0x3f	; 63
    2730:	f8 94       	cli
    2732:	0f 92       	push	r0
    2734:	fc 01       	movw	r30, r24
    2736:	22 85       	ldd	r18, Z+10	; 0x0a
    2738:	33 85       	ldd	r19, Z+11	; 0x0b
    273a:	2d 59       	subi	r18, 0x9D	; 157
    273c:	37 40       	sbci	r19, 0x07	; 7
    273e:	69 f5       	brne	.+90     	; 0x279a <vTaskResume+0x8a>
    2740:	fc 01       	movw	r30, r24
    2742:	24 89       	ldd	r18, Z+20	; 0x14
    2744:	35 89       	ldd	r19, Z+21	; 0x15
    2746:	f7 e0       	ldi	r31, 0x07	; 7
    2748:	20 3b       	cpi	r18, 0xB0	; 176
    274a:	3f 07       	cpc	r19, r31
    274c:	31 f1       	breq	.+76     	; 0x279a <vTaskResume+0x8a>
    274e:	23 2b       	or	r18, r19
    2750:	21 f5       	brne	.+72     	; 0x279a <vTaskResume+0x8a>
    2752:	ec 01       	movw	r28, r24
    2754:	8c 01       	movw	r16, r24
    2756:	0e 5f       	subi	r16, 0xFE	; 254
    2758:	1f 4f       	sbci	r17, 0xFF	; 255
    275a:	c8 01       	movw	r24, r16
    275c:	f1 d8       	rcall	.-3614   	; 0x1940 <uxListRemove>
    275e:	8e 89       	ldd	r24, Y+22	; 0x16
    2760:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    2764:	98 17       	cp	r25, r24
    2766:	10 f4       	brcc	.+4      	; 0x276c <vTaskResume+0x5c>
    2768:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    276c:	90 e0       	ldi	r25, 0x00	; 0
    276e:	9c 01       	movw	r18, r24
    2770:	22 0f       	add	r18, r18
    2772:	33 1f       	adc	r19, r19
    2774:	22 0f       	add	r18, r18
    2776:	33 1f       	adc	r19, r19
    2778:	22 0f       	add	r18, r18
    277a:	33 1f       	adc	r19, r19
    277c:	82 0f       	add	r24, r18
    277e:	93 1f       	adc	r25, r19
    2780:	b8 01       	movw	r22, r16
    2782:	81 53       	subi	r24, 0x31	; 49
    2784:	98 4f       	sbci	r25, 0xF8	; 248
    2786:	8a d8       	rcall	.-3820   	; 0x189c <vListInsertEnd>
    2788:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    278c:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2790:	9e 89       	ldd	r25, Y+22	; 0x16
    2792:	86 89       	ldd	r24, Z+22	; 0x16
    2794:	98 17       	cp	r25, r24
    2796:	08 f0       	brcs	.+2      	; 0x279a <vTaskResume+0x8a>
    2798:	9b d9       	rcall	.-3274   	; 0x1ad0 <vPortYield>
    279a:	0f 90       	pop	r0
    279c:	0f be       	out	0x3f, r0	; 63
    279e:	df 91       	pop	r29
    27a0:	cf 91       	pop	r28
    27a2:	1f 91       	pop	r17
    27a4:	0f 91       	pop	r16
    27a6:	08 95       	ret

000027a8 <vTaskStartScheduler>:
    27a8:	ef 92       	push	r14
    27aa:	ff 92       	push	r15
    27ac:	0f 93       	push	r16
    27ae:	0f 2e       	mov	r0, r31
    27b0:	f0 e9       	ldi	r31, 0x90	; 144
    27b2:	ef 2e       	mov	r14, r31
    27b4:	f7 e0       	ldi	r31, 0x07	; 7
    27b6:	ff 2e       	mov	r15, r31
    27b8:	f0 2d       	mov	r31, r0
    27ba:	00 e0       	ldi	r16, 0x00	; 0
    27bc:	20 e0       	ldi	r18, 0x00	; 0
    27be:	30 e0       	ldi	r19, 0x00	; 0
    27c0:	45 e5       	ldi	r20, 0x55	; 85
    27c2:	50 e0       	ldi	r21, 0x00	; 0
    27c4:	6a e3       	ldi	r22, 0x3A	; 58
    27c6:	71 e0       	ldi	r23, 0x01	; 1
    27c8:	85 eb       	ldi	r24, 0xB5	; 181
    27ca:	91 e1       	ldi	r25, 0x11	; 17
    27cc:	4b de       	rcall	.-874    	; 0x2464 <xTaskCreate>
    27ce:	81 30       	cpi	r24, 0x01	; 1
    27d0:	91 f4       	brne	.+36     	; 0x27f6 <vTaskStartScheduler+0x4e>
    27d2:	4e d4       	rcall	.+2204   	; 0x3070 <xTimerCreateTimerTask>
    27d4:	81 30       	cpi	r24, 0x01	; 1
    27d6:	79 f4       	brne	.+30     	; 0x27f6 <vTaskStartScheduler+0x4e>
    27d8:	f8 94       	cli
    27da:	8f ef       	ldi	r24, 0xFF	; 255
    27dc:	9f ef       	ldi	r25, 0xFF	; 255
    27de:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    27e2:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    27e6:	81 e0       	ldi	r24, 0x01	; 1
    27e8:	80 93 98 07 	sts	0x0798, r24	; 0x800798 <xSchedulerRunning>
    27ec:	10 92 9b 07 	sts	0x079B, r1	; 0x80079b <xTickCount+0x1>
    27f0:	10 92 9a 07 	sts	0x079A, r1	; 0x80079a <xTickCount>
    27f4:	38 d9       	rcall	.-3472   	; 0x1a66 <xPortStartScheduler>
    27f6:	0f 91       	pop	r16
    27f8:	ff 90       	pop	r15
    27fa:	ef 90       	pop	r14
    27fc:	08 95       	ret

000027fe <vTaskSuspendAll>:
    27fe:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    2802:	8f 5f       	subi	r24, 0xFF	; 255
    2804:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxSchedulerSuspended>
    2808:	08 95       	ret

0000280a <xTaskGetTickCount>:
    280a:	0f b6       	in	r0, 0x3f	; 63
    280c:	f8 94       	cli
    280e:	0f 92       	push	r0
    2810:	80 91 9a 07 	lds	r24, 0x079A	; 0x80079a <xTickCount>
    2814:	90 91 9b 07 	lds	r25, 0x079B	; 0x80079b <xTickCount+0x1>
    2818:	0f 90       	pop	r0
    281a:	0f be       	out	0x3f, r0	; 63
    281c:	08 95       	ret

0000281e <xTaskIncrementTick>:
    281e:	cf 92       	push	r12
    2820:	df 92       	push	r13
    2822:	ef 92       	push	r14
    2824:	ff 92       	push	r15
    2826:	0f 93       	push	r16
    2828:	1f 93       	push	r17
    282a:	cf 93       	push	r28
    282c:	df 93       	push	r29
    282e:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    2832:	81 11       	cpse	r24, r1
    2834:	96 c0       	rjmp	.+300    	; 0x2962 <xTaskIncrementTick+0x144>
    2836:	e0 90 9a 07 	lds	r14, 0x079A	; 0x80079a <xTickCount>
    283a:	f0 90 9b 07 	lds	r15, 0x079B	; 0x80079b <xTickCount+0x1>
    283e:	8f ef       	ldi	r24, 0xFF	; 255
    2840:	e8 1a       	sub	r14, r24
    2842:	f8 0a       	sbc	r15, r24
    2844:	f0 92 9b 07 	sts	0x079B, r15	; 0x80079b <xTickCount+0x1>
    2848:	e0 92 9a 07 	sts	0x079A, r14	; 0x80079a <xTickCount>
    284c:	e1 14       	cp	r14, r1
    284e:	f1 04       	cpc	r15, r1
    2850:	b1 f4       	brne	.+44     	; 0x287e <xTaskIncrementTick+0x60>
    2852:	80 91 bb 07 	lds	r24, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    2856:	90 91 bc 07 	lds	r25, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    285a:	20 91 b9 07 	lds	r18, 0x07B9	; 0x8007b9 <pxOverflowDelayedTaskList>
    285e:	30 91 ba 07 	lds	r19, 0x07BA	; 0x8007ba <pxOverflowDelayedTaskList+0x1>
    2862:	30 93 bc 07 	sts	0x07BC, r19	; 0x8007bc <pxDelayedTaskList+0x1>
    2866:	20 93 bb 07 	sts	0x07BB, r18	; 0x8007bb <pxDelayedTaskList>
    286a:	90 93 ba 07 	sts	0x07BA, r25	; 0x8007ba <pxOverflowDelayedTaskList+0x1>
    286e:	80 93 b9 07 	sts	0x07B9, r24	; 0x8007b9 <pxOverflowDelayedTaskList>
    2872:	80 91 95 07 	lds	r24, 0x0795	; 0x800795 <xNumOfOverflows>
    2876:	8f 5f       	subi	r24, 0xFF	; 255
    2878:	80 93 95 07 	sts	0x0795, r24	; 0x800795 <xNumOfOverflows>
    287c:	57 dd       	rcall	.-1362   	; 0x232c <prvResetNextTaskUnblockTime>
    287e:	80 91 92 07 	lds	r24, 0x0792	; 0x800792 <xNextTaskUnblockTime>
    2882:	90 91 93 07 	lds	r25, 0x0793	; 0x800793 <xNextTaskUnblockTime+0x1>
    2886:	e8 16       	cp	r14, r24
    2888:	f9 06       	cpc	r15, r25
    288a:	10 f4       	brcc	.+4      	; 0x2890 <xTaskIncrementTick+0x72>
    288c:	d1 2c       	mov	r13, r1
    288e:	51 c0       	rjmp	.+162    	; 0x2932 <xTaskIncrementTick+0x114>
    2890:	d1 2c       	mov	r13, r1
    2892:	cc 24       	eor	r12, r12
    2894:	c3 94       	inc	r12
    2896:	e0 91 bb 07 	lds	r30, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    289a:	f0 91 bc 07 	lds	r31, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    289e:	80 81       	ld	r24, Z
    28a0:	81 11       	cpse	r24, r1
    28a2:	07 c0       	rjmp	.+14     	; 0x28b2 <xTaskIncrementTick+0x94>
    28a4:	8f ef       	ldi	r24, 0xFF	; 255
    28a6:	9f ef       	ldi	r25, 0xFF	; 255
    28a8:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    28ac:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    28b0:	40 c0       	rjmp	.+128    	; 0x2932 <xTaskIncrementTick+0x114>
    28b2:	e0 91 bb 07 	lds	r30, 0x07BB	; 0x8007bb <pxDelayedTaskList>
    28b6:	f0 91 bc 07 	lds	r31, 0x07BC	; 0x8007bc <pxDelayedTaskList+0x1>
    28ba:	05 80       	ldd	r0, Z+5	; 0x05
    28bc:	f6 81       	ldd	r31, Z+6	; 0x06
    28be:	e0 2d       	mov	r30, r0
    28c0:	c6 81       	ldd	r28, Z+6	; 0x06
    28c2:	d7 81       	ldd	r29, Z+7	; 0x07
    28c4:	8a 81       	ldd	r24, Y+2	; 0x02
    28c6:	9b 81       	ldd	r25, Y+3	; 0x03
    28c8:	e8 16       	cp	r14, r24
    28ca:	f9 06       	cpc	r15, r25
    28cc:	28 f4       	brcc	.+10     	; 0x28d8 <xTaskIncrementTick+0xba>
    28ce:	90 93 93 07 	sts	0x0793, r25	; 0x800793 <xNextTaskUnblockTime+0x1>
    28d2:	80 93 92 07 	sts	0x0792, r24	; 0x800792 <xNextTaskUnblockTime>
    28d6:	2d c0       	rjmp	.+90     	; 0x2932 <xTaskIncrementTick+0x114>
    28d8:	8e 01       	movw	r16, r28
    28da:	0e 5f       	subi	r16, 0xFE	; 254
    28dc:	1f 4f       	sbci	r17, 0xFF	; 255
    28de:	c8 01       	movw	r24, r16
    28e0:	2f d8       	rcall	.-4002   	; 0x1940 <uxListRemove>
    28e2:	8c 89       	ldd	r24, Y+20	; 0x14
    28e4:	9d 89       	ldd	r25, Y+21	; 0x15
    28e6:	89 2b       	or	r24, r25
    28e8:	19 f0       	breq	.+6      	; 0x28f0 <xTaskIncrementTick+0xd2>
    28ea:	ce 01       	movw	r24, r28
    28ec:	0c 96       	adiw	r24, 0x0c	; 12
    28ee:	28 d8       	rcall	.-4016   	; 0x1940 <uxListRemove>
    28f0:	8e 89       	ldd	r24, Y+22	; 0x16
    28f2:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    28f6:	98 17       	cp	r25, r24
    28f8:	10 f4       	brcc	.+4      	; 0x28fe <xTaskIncrementTick+0xe0>
    28fa:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    28fe:	90 e0       	ldi	r25, 0x00	; 0
    2900:	9c 01       	movw	r18, r24
    2902:	22 0f       	add	r18, r18
    2904:	33 1f       	adc	r19, r19
    2906:	22 0f       	add	r18, r18
    2908:	33 1f       	adc	r19, r19
    290a:	22 0f       	add	r18, r18
    290c:	33 1f       	adc	r19, r19
    290e:	82 0f       	add	r24, r18
    2910:	93 1f       	adc	r25, r19
    2912:	b8 01       	movw	r22, r16
    2914:	81 53       	subi	r24, 0x31	; 49
    2916:	98 4f       	sbci	r25, 0xF8	; 248
    2918:	0e 94 4e 0c 	call	0x189c	; 0x189c <vListInsertEnd>
    291c:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2920:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2924:	9e 89       	ldd	r25, Y+22	; 0x16
    2926:	86 89       	ldd	r24, Z+22	; 0x16
    2928:	98 17       	cp	r25, r24
    292a:	08 f4       	brcc	.+2      	; 0x292e <xTaskIncrementTick+0x110>
    292c:	b4 cf       	rjmp	.-152    	; 0x2896 <xTaskIncrementTick+0x78>
    292e:	dc 2c       	mov	r13, r12
    2930:	b2 cf       	rjmp	.-156    	; 0x2896 <xTaskIncrementTick+0x78>
    2932:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2936:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    293a:	86 89       	ldd	r24, Z+22	; 0x16
    293c:	90 e0       	ldi	r25, 0x00	; 0
    293e:	fc 01       	movw	r30, r24
    2940:	ee 0f       	add	r30, r30
    2942:	ff 1f       	adc	r31, r31
    2944:	ee 0f       	add	r30, r30
    2946:	ff 1f       	adc	r31, r31
    2948:	ee 0f       	add	r30, r30
    294a:	ff 1f       	adc	r31, r31
    294c:	8e 0f       	add	r24, r30
    294e:	9f 1f       	adc	r25, r31
    2950:	fc 01       	movw	r30, r24
    2952:	e1 53       	subi	r30, 0x31	; 49
    2954:	f8 4f       	sbci	r31, 0xF8	; 248
    2956:	80 81       	ld	r24, Z
    2958:	82 30       	cpi	r24, 0x02	; 2
    295a:	48 f0       	brcs	.+18     	; 0x296e <xTaskIncrementTick+0x150>
    295c:	dd 24       	eor	r13, r13
    295e:	d3 94       	inc	r13
    2960:	06 c0       	rjmp	.+12     	; 0x296e <xTaskIncrementTick+0x150>
    2962:	80 91 97 07 	lds	r24, 0x0797	; 0x800797 <uxPendedTicks>
    2966:	8f 5f       	subi	r24, 0xFF	; 255
    2968:	80 93 97 07 	sts	0x0797, r24	; 0x800797 <uxPendedTicks>
    296c:	d1 2c       	mov	r13, r1
    296e:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xYieldPending>
    2972:	88 23       	and	r24, r24
    2974:	11 f0       	breq	.+4      	; 0x297a <xTaskIncrementTick+0x15c>
    2976:	dd 24       	eor	r13, r13
    2978:	d3 94       	inc	r13
    297a:	8d 2d       	mov	r24, r13
    297c:	df 91       	pop	r29
    297e:	cf 91       	pop	r28
    2980:	1f 91       	pop	r17
    2982:	0f 91       	pop	r16
    2984:	ff 90       	pop	r15
    2986:	ef 90       	pop	r14
    2988:	df 90       	pop	r13
    298a:	cf 90       	pop	r12
    298c:	08 95       	ret

0000298e <xTaskResumeAll>:
    298e:	df 92       	push	r13
    2990:	ef 92       	push	r14
    2992:	ff 92       	push	r15
    2994:	0f 93       	push	r16
    2996:	1f 93       	push	r17
    2998:	cf 93       	push	r28
    299a:	df 93       	push	r29
    299c:	0f b6       	in	r0, 0x3f	; 63
    299e:	f8 94       	cli
    29a0:	0f 92       	push	r0
    29a2:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    29a6:	81 50       	subi	r24, 0x01	; 1
    29a8:	80 93 8f 07 	sts	0x078F, r24	; 0x80078f <uxSchedulerSuspended>
    29ac:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    29b0:	81 11       	cpse	r24, r1
    29b2:	5c c0       	rjmp	.+184    	; 0x2a6c <xTaskResumeAll+0xde>
    29b4:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    29b8:	81 11       	cpse	r24, r1
    29ba:	33 c0       	rjmp	.+102    	; 0x2a22 <xTaskResumeAll+0x94>
    29bc:	5a c0       	rjmp	.+180    	; 0x2a72 <xTaskResumeAll+0xe4>
    29be:	d7 01       	movw	r26, r14
    29c0:	15 96       	adiw	r26, 0x05	; 5
    29c2:	ed 91       	ld	r30, X+
    29c4:	fc 91       	ld	r31, X
    29c6:	16 97       	sbiw	r26, 0x06	; 6
    29c8:	c6 81       	ldd	r28, Z+6	; 0x06
    29ca:	d7 81       	ldd	r29, Z+7	; 0x07
    29cc:	ce 01       	movw	r24, r28
    29ce:	0c 96       	adiw	r24, 0x0c	; 12
    29d0:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
    29d4:	8e 01       	movw	r16, r28
    29d6:	0e 5f       	subi	r16, 0xFE	; 254
    29d8:	1f 4f       	sbci	r17, 0xFF	; 255
    29da:	c8 01       	movw	r24, r16
    29dc:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
    29e0:	8e 89       	ldd	r24, Y+22	; 0x16
    29e2:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    29e6:	98 17       	cp	r25, r24
    29e8:	10 f4       	brcc	.+4      	; 0x29ee <xTaskResumeAll+0x60>
    29ea:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    29ee:	90 e0       	ldi	r25, 0x00	; 0
    29f0:	9c 01       	movw	r18, r24
    29f2:	22 0f       	add	r18, r18
    29f4:	33 1f       	adc	r19, r19
    29f6:	22 0f       	add	r18, r18
    29f8:	33 1f       	adc	r19, r19
    29fa:	22 0f       	add	r18, r18
    29fc:	33 1f       	adc	r19, r19
    29fe:	82 0f       	add	r24, r18
    2a00:	93 1f       	adc	r25, r19
    2a02:	b8 01       	movw	r22, r16
    2a04:	81 53       	subi	r24, 0x31	; 49
    2a06:	98 4f       	sbci	r25, 0xF8	; 248
    2a08:	0e 94 4e 0c 	call	0x189c	; 0x189c <vListInsertEnd>
    2a0c:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2a10:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2a14:	9e 89       	ldd	r25, Y+22	; 0x16
    2a16:	86 89       	ldd	r24, Z+22	; 0x16
    2a18:	98 17       	cp	r25, r24
    2a1a:	68 f0       	brcs	.+26     	; 0x2a36 <xTaskResumeAll+0xa8>
    2a1c:	d0 92 96 07 	sts	0x0796, r13	; 0x800796 <xYieldPending>
    2a20:	0a c0       	rjmp	.+20     	; 0x2a36 <xTaskResumeAll+0xa8>
    2a22:	c0 e0       	ldi	r28, 0x00	; 0
    2a24:	d0 e0       	ldi	r29, 0x00	; 0
    2a26:	0f 2e       	mov	r0, r31
    2a28:	f0 eb       	ldi	r31, 0xB0	; 176
    2a2a:	ef 2e       	mov	r14, r31
    2a2c:	f7 e0       	ldi	r31, 0x07	; 7
    2a2e:	ff 2e       	mov	r15, r31
    2a30:	f0 2d       	mov	r31, r0
    2a32:	dd 24       	eor	r13, r13
    2a34:	d3 94       	inc	r13
    2a36:	f7 01       	movw	r30, r14
    2a38:	80 81       	ld	r24, Z
    2a3a:	81 11       	cpse	r24, r1
    2a3c:	c0 cf       	rjmp	.-128    	; 0x29be <xTaskResumeAll+0x30>
    2a3e:	cd 2b       	or	r28, r29
    2a40:	09 f0       	breq	.+2      	; 0x2a44 <xTaskResumeAll+0xb6>
    2a42:	74 dc       	rcall	.-1816   	; 0x232c <prvResetNextTaskUnblockTime>
    2a44:	c0 91 97 07 	lds	r28, 0x0797	; 0x800797 <uxPendedTicks>
    2a48:	cc 23       	and	r28, r28
    2a4a:	49 f0       	breq	.+18     	; 0x2a5e <xTaskResumeAll+0xd0>
    2a4c:	d1 e0       	ldi	r29, 0x01	; 1
    2a4e:	e7 de       	rcall	.-562    	; 0x281e <xTaskIncrementTick>
    2a50:	81 11       	cpse	r24, r1
    2a52:	d0 93 96 07 	sts	0x0796, r29	; 0x800796 <xYieldPending>
    2a56:	c1 50       	subi	r28, 0x01	; 1
    2a58:	d1 f7       	brne	.-12     	; 0x2a4e <xTaskResumeAll+0xc0>
    2a5a:	10 92 97 07 	sts	0x0797, r1	; 0x800797 <uxPendedTicks>
    2a5e:	80 91 96 07 	lds	r24, 0x0796	; 0x800796 <xYieldPending>
    2a62:	88 23       	and	r24, r24
    2a64:	29 f0       	breq	.+10     	; 0x2a70 <xTaskResumeAll+0xe2>
    2a66:	34 d8       	rcall	.-3992   	; 0x1ad0 <vPortYield>
    2a68:	81 e0       	ldi	r24, 0x01	; 1
    2a6a:	03 c0       	rjmp	.+6      	; 0x2a72 <xTaskResumeAll+0xe4>
    2a6c:	80 e0       	ldi	r24, 0x00	; 0
    2a6e:	01 c0       	rjmp	.+2      	; 0x2a72 <xTaskResumeAll+0xe4>
    2a70:	80 e0       	ldi	r24, 0x00	; 0
    2a72:	0f 90       	pop	r0
    2a74:	0f be       	out	0x3f, r0	; 63
    2a76:	df 91       	pop	r29
    2a78:	cf 91       	pop	r28
    2a7a:	1f 91       	pop	r17
    2a7c:	0f 91       	pop	r16
    2a7e:	ff 90       	pop	r15
    2a80:	ef 90       	pop	r14
    2a82:	df 90       	pop	r13
    2a84:	08 95       	ret

00002a86 <vTaskDelay>:
    2a86:	cf 93       	push	r28
    2a88:	df 93       	push	r29
    2a8a:	ec 01       	movw	r28, r24
    2a8c:	89 2b       	or	r24, r25
    2a8e:	39 f0       	breq	.+14     	; 0x2a9e <vTaskDelay+0x18>
    2a90:	b6 de       	rcall	.-660    	; 0x27fe <vTaskSuspendAll>
    2a92:	60 e0       	ldi	r22, 0x00	; 0
    2a94:	ce 01       	movw	r24, r28
    2a96:	92 dc       	rcall	.-1756   	; 0x23bc <prvAddCurrentTaskToDelayedList>
    2a98:	7a df       	rcall	.-268    	; 0x298e <xTaskResumeAll>
    2a9a:	81 11       	cpse	r24, r1
    2a9c:	01 c0       	rjmp	.+2      	; 0x2aa0 <vTaskDelay+0x1a>
    2a9e:	18 d8       	rcall	.-4048   	; 0x1ad0 <vPortYield>
    2aa0:	df 91       	pop	r29
    2aa2:	cf 91       	pop	r28
    2aa4:	08 95       	ret

00002aa6 <vTaskSwitchContext>:
    2aa6:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    2aaa:	88 23       	and	r24, r24
    2aac:	21 f0       	breq	.+8      	; 0x2ab6 <vTaskSwitchContext+0x10>
    2aae:	81 e0       	ldi	r24, 0x01	; 1
    2ab0:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <xYieldPending>
    2ab4:	08 95       	ret
    2ab6:	10 92 96 07 	sts	0x0796, r1	; 0x800796 <xYieldPending>
    2aba:	20 91 99 07 	lds	r18, 0x0799	; 0x800799 <uxTopReadyPriority>
    2abe:	82 2f       	mov	r24, r18
    2ac0:	90 e0       	ldi	r25, 0x00	; 0
    2ac2:	fc 01       	movw	r30, r24
    2ac4:	ee 0f       	add	r30, r30
    2ac6:	ff 1f       	adc	r31, r31
    2ac8:	ee 0f       	add	r30, r30
    2aca:	ff 1f       	adc	r31, r31
    2acc:	ee 0f       	add	r30, r30
    2ace:	ff 1f       	adc	r31, r31
    2ad0:	e8 0f       	add	r30, r24
    2ad2:	f9 1f       	adc	r31, r25
    2ad4:	e1 53       	subi	r30, 0x31	; 49
    2ad6:	f8 4f       	sbci	r31, 0xF8	; 248
    2ad8:	30 81       	ld	r19, Z
    2ada:	31 11       	cpse	r19, r1
    2adc:	11 c0       	rjmp	.+34     	; 0x2b00 <vTaskSwitchContext+0x5a>
    2ade:	21 50       	subi	r18, 0x01	; 1
    2ae0:	82 2f       	mov	r24, r18
    2ae2:	90 e0       	ldi	r25, 0x00	; 0
    2ae4:	fc 01       	movw	r30, r24
    2ae6:	ee 0f       	add	r30, r30
    2ae8:	ff 1f       	adc	r31, r31
    2aea:	ee 0f       	add	r30, r30
    2aec:	ff 1f       	adc	r31, r31
    2aee:	ee 0f       	add	r30, r30
    2af0:	ff 1f       	adc	r31, r31
    2af2:	e8 0f       	add	r30, r24
    2af4:	f9 1f       	adc	r31, r25
    2af6:	e1 53       	subi	r30, 0x31	; 49
    2af8:	f8 4f       	sbci	r31, 0xF8	; 248
    2afa:	30 81       	ld	r19, Z
    2afc:	33 23       	and	r19, r19
    2afe:	79 f3       	breq	.-34     	; 0x2ade <vTaskSwitchContext+0x38>
    2b00:	ac 01       	movw	r20, r24
    2b02:	44 0f       	add	r20, r20
    2b04:	55 1f       	adc	r21, r21
    2b06:	44 0f       	add	r20, r20
    2b08:	55 1f       	adc	r21, r21
    2b0a:	44 0f       	add	r20, r20
    2b0c:	55 1f       	adc	r21, r21
    2b0e:	48 0f       	add	r20, r24
    2b10:	59 1f       	adc	r21, r25
    2b12:	da 01       	movw	r26, r20
    2b14:	a1 53       	subi	r26, 0x31	; 49
    2b16:	b8 4f       	sbci	r27, 0xF8	; 248
    2b18:	11 96       	adiw	r26, 0x01	; 1
    2b1a:	ed 91       	ld	r30, X+
    2b1c:	fc 91       	ld	r31, X
    2b1e:	12 97       	sbiw	r26, 0x02	; 2
    2b20:	02 80       	ldd	r0, Z+2	; 0x02
    2b22:	f3 81       	ldd	r31, Z+3	; 0x03
    2b24:	e0 2d       	mov	r30, r0
    2b26:	12 96       	adiw	r26, 0x02	; 2
    2b28:	fc 93       	st	X, r31
    2b2a:	ee 93       	st	-X, r30
    2b2c:	11 97       	sbiw	r26, 0x01	; 1
    2b2e:	4e 52       	subi	r20, 0x2E	; 46
    2b30:	58 4f       	sbci	r21, 0xF8	; 248
    2b32:	e4 17       	cp	r30, r20
    2b34:	f5 07       	cpc	r31, r21
    2b36:	29 f4       	brne	.+10     	; 0x2b42 <vTaskSwitchContext+0x9c>
    2b38:	42 81       	ldd	r20, Z+2	; 0x02
    2b3a:	53 81       	ldd	r21, Z+3	; 0x03
    2b3c:	fd 01       	movw	r30, r26
    2b3e:	52 83       	std	Z+2, r21	; 0x02
    2b40:	41 83       	std	Z+1, r20	; 0x01
    2b42:	fc 01       	movw	r30, r24
    2b44:	ee 0f       	add	r30, r30
    2b46:	ff 1f       	adc	r31, r31
    2b48:	ee 0f       	add	r30, r30
    2b4a:	ff 1f       	adc	r31, r31
    2b4c:	ee 0f       	add	r30, r30
    2b4e:	ff 1f       	adc	r31, r31
    2b50:	8e 0f       	add	r24, r30
    2b52:	9f 1f       	adc	r25, r31
    2b54:	fc 01       	movw	r30, r24
    2b56:	e1 53       	subi	r30, 0x31	; 49
    2b58:	f8 4f       	sbci	r31, 0xF8	; 248
    2b5a:	01 80       	ldd	r0, Z+1	; 0x01
    2b5c:	f2 81       	ldd	r31, Z+2	; 0x02
    2b5e:	e0 2d       	mov	r30, r0
    2b60:	86 81       	ldd	r24, Z+6	; 0x06
    2b62:	97 81       	ldd	r25, Z+7	; 0x07
    2b64:	90 93 fd 07 	sts	0x07FD, r25	; 0x8007fd <pxCurrentTCB+0x1>
    2b68:	80 93 fc 07 	sts	0x07FC, r24	; 0x8007fc <pxCurrentTCB>
    2b6c:	20 93 99 07 	sts	0x0799, r18	; 0x800799 <uxTopReadyPriority>
    2b70:	08 95       	ret

00002b72 <vTaskSuspend>:
    2b72:	0f 93       	push	r16
    2b74:	1f 93       	push	r17
    2b76:	cf 93       	push	r28
    2b78:	df 93       	push	r29
    2b7a:	ec 01       	movw	r28, r24
    2b7c:	0f b6       	in	r0, 0x3f	; 63
    2b7e:	f8 94       	cli
    2b80:	0f 92       	push	r0
    2b82:	89 2b       	or	r24, r25
    2b84:	21 f4       	brne	.+8      	; 0x2b8e <vTaskSuspend+0x1c>
    2b86:	c0 91 fc 07 	lds	r28, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2b8a:	d0 91 fd 07 	lds	r29, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2b8e:	8e 01       	movw	r16, r28
    2b90:	0e 5f       	subi	r16, 0xFE	; 254
    2b92:	1f 4f       	sbci	r17, 0xFF	; 255
    2b94:	c8 01       	movw	r24, r16
    2b96:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
    2b9a:	8c 89       	ldd	r24, Y+20	; 0x14
    2b9c:	9d 89       	ldd	r25, Y+21	; 0x15
    2b9e:	89 2b       	or	r24, r25
    2ba0:	21 f0       	breq	.+8      	; 0x2baa <vTaskSuspend+0x38>
    2ba2:	ce 01       	movw	r24, r28
    2ba4:	0c 96       	adiw	r24, 0x0c	; 12
    2ba6:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
    2baa:	b8 01       	movw	r22, r16
    2bac:	8d e9       	ldi	r24, 0x9D	; 157
    2bae:	97 e0       	ldi	r25, 0x07	; 7
    2bb0:	0e 94 4e 0c 	call	0x189c	; 0x189c <vListInsertEnd>
    2bb4:	8f a1       	ldd	r24, Y+39	; 0x27
    2bb6:	81 30       	cpi	r24, 0x01	; 1
    2bb8:	09 f4       	brne	.+2      	; 0x2bbc <vTaskSuspend+0x4a>
    2bba:	1f a2       	std	Y+39, r1	; 0x27
    2bbc:	0f 90       	pop	r0
    2bbe:	0f be       	out	0x3f, r0	; 63
    2bc0:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xSchedulerRunning>
    2bc4:	88 23       	and	r24, r24
    2bc6:	31 f0       	breq	.+12     	; 0x2bd4 <vTaskSuspend+0x62>
    2bc8:	0f b6       	in	r0, 0x3f	; 63
    2bca:	f8 94       	cli
    2bcc:	0f 92       	push	r0
    2bce:	ae db       	rcall	.-2212   	; 0x232c <prvResetNextTaskUnblockTime>
    2bd0:	0f 90       	pop	r0
    2bd2:	0f be       	out	0x3f, r0	; 63
    2bd4:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2bd8:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2bdc:	c8 17       	cp	r28, r24
    2bde:	d9 07       	cpc	r29, r25
    2be0:	99 f4       	brne	.+38     	; 0x2c08 <vTaskSuspend+0x96>
    2be2:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xSchedulerRunning>
    2be6:	88 23       	and	r24, r24
    2be8:	19 f0       	breq	.+6      	; 0x2bf0 <vTaskSuspend+0x7e>
    2bea:	0e 94 68 0d 	call	0x1ad0	; 0x1ad0 <vPortYield>
    2bee:	0c c0       	rjmp	.+24     	; 0x2c08 <vTaskSuspend+0x96>
    2bf0:	90 91 9d 07 	lds	r25, 0x079D	; 0x80079d <xSuspendedTaskList>
    2bf4:	80 91 9c 07 	lds	r24, 0x079C	; 0x80079c <uxCurrentNumberOfTasks>
    2bf8:	98 13       	cpse	r25, r24
    2bfa:	05 c0       	rjmp	.+10     	; 0x2c06 <vTaskSuspend+0x94>
    2bfc:	10 92 fd 07 	sts	0x07FD, r1	; 0x8007fd <pxCurrentTCB+0x1>
    2c00:	10 92 fc 07 	sts	0x07FC, r1	; 0x8007fc <pxCurrentTCB>
    2c04:	01 c0       	rjmp	.+2      	; 0x2c08 <vTaskSuspend+0x96>
    2c06:	4f df       	rcall	.-354    	; 0x2aa6 <vTaskSwitchContext>
    2c08:	df 91       	pop	r29
    2c0a:	cf 91       	pop	r28
    2c0c:	1f 91       	pop	r17
    2c0e:	0f 91       	pop	r16
    2c10:	08 95       	ret

00002c12 <vTaskPlaceOnEventList>:
    2c12:	cf 93       	push	r28
    2c14:	df 93       	push	r29
    2c16:	eb 01       	movw	r28, r22
    2c18:	60 91 fc 07 	lds	r22, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2c1c:	70 91 fd 07 	lds	r23, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2c20:	64 5f       	subi	r22, 0xF4	; 244
    2c22:	7f 4f       	sbci	r23, 0xFF	; 255
    2c24:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInsert>
    2c28:	61 e0       	ldi	r22, 0x01	; 1
    2c2a:	ce 01       	movw	r24, r28
    2c2c:	c7 db       	rcall	.-2162   	; 0x23bc <prvAddCurrentTaskToDelayedList>
    2c2e:	df 91       	pop	r29
    2c30:	cf 91       	pop	r28
    2c32:	08 95       	ret

00002c34 <vTaskPlaceOnEventListRestricted>:
    2c34:	0f 93       	push	r16
    2c36:	1f 93       	push	r17
    2c38:	cf 93       	push	r28
    2c3a:	8b 01       	movw	r16, r22
    2c3c:	c4 2f       	mov	r28, r20
    2c3e:	60 91 fc 07 	lds	r22, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2c42:	70 91 fd 07 	lds	r23, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2c46:	64 5f       	subi	r22, 0xF4	; 244
    2c48:	7f 4f       	sbci	r23, 0xFF	; 255
    2c4a:	0e 94 4e 0c 	call	0x189c	; 0x189c <vListInsertEnd>
    2c4e:	cc 23       	and	r28, r28
    2c50:	11 f0       	breq	.+4      	; 0x2c56 <vTaskPlaceOnEventListRestricted+0x22>
    2c52:	0f ef       	ldi	r16, 0xFF	; 255
    2c54:	1f ef       	ldi	r17, 0xFF	; 255
    2c56:	6c 2f       	mov	r22, r28
    2c58:	c8 01       	movw	r24, r16
    2c5a:	b0 db       	rcall	.-2208   	; 0x23bc <prvAddCurrentTaskToDelayedList>
    2c5c:	cf 91       	pop	r28
    2c5e:	1f 91       	pop	r17
    2c60:	0f 91       	pop	r16
    2c62:	08 95       	ret

00002c64 <xTaskRemoveFromEventList>:
    2c64:	0f 93       	push	r16
    2c66:	1f 93       	push	r17
    2c68:	cf 93       	push	r28
    2c6a:	df 93       	push	r29
    2c6c:	dc 01       	movw	r26, r24
    2c6e:	15 96       	adiw	r26, 0x05	; 5
    2c70:	ed 91       	ld	r30, X+
    2c72:	fc 91       	ld	r31, X
    2c74:	16 97       	sbiw	r26, 0x06	; 6
    2c76:	c6 81       	ldd	r28, Z+6	; 0x06
    2c78:	d7 81       	ldd	r29, Z+7	; 0x07
    2c7a:	8e 01       	movw	r16, r28
    2c7c:	04 5f       	subi	r16, 0xF4	; 244
    2c7e:	1f 4f       	sbci	r17, 0xFF	; 255
    2c80:	c8 01       	movw	r24, r16
    2c82:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
    2c86:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    2c8a:	81 11       	cpse	r24, r1
    2c8c:	1c c0       	rjmp	.+56     	; 0x2cc6 <xTaskRemoveFromEventList+0x62>
    2c8e:	0a 50       	subi	r16, 0x0A	; 10
    2c90:	11 09       	sbc	r17, r1
    2c92:	c8 01       	movw	r24, r16
    2c94:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
    2c98:	8e 89       	ldd	r24, Y+22	; 0x16
    2c9a:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    2c9e:	98 17       	cp	r25, r24
    2ca0:	10 f4       	brcc	.+4      	; 0x2ca6 <xTaskRemoveFromEventList+0x42>
    2ca2:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    2ca6:	90 e0       	ldi	r25, 0x00	; 0
    2ca8:	9c 01       	movw	r18, r24
    2caa:	22 0f       	add	r18, r18
    2cac:	33 1f       	adc	r19, r19
    2cae:	22 0f       	add	r18, r18
    2cb0:	33 1f       	adc	r19, r19
    2cb2:	22 0f       	add	r18, r18
    2cb4:	33 1f       	adc	r19, r19
    2cb6:	82 0f       	add	r24, r18
    2cb8:	93 1f       	adc	r25, r19
    2cba:	b8 01       	movw	r22, r16
    2cbc:	81 53       	subi	r24, 0x31	; 49
    2cbe:	98 4f       	sbci	r25, 0xF8	; 248
    2cc0:	0e 94 4e 0c 	call	0x189c	; 0x189c <vListInsertEnd>
    2cc4:	05 c0       	rjmp	.+10     	; 0x2cd0 <xTaskRemoveFromEventList+0x6c>
    2cc6:	b8 01       	movw	r22, r16
    2cc8:	80 eb       	ldi	r24, 0xB0	; 176
    2cca:	97 e0       	ldi	r25, 0x07	; 7
    2ccc:	0e 94 4e 0c 	call	0x189c	; 0x189c <vListInsertEnd>
    2cd0:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2cd4:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2cd8:	9e 89       	ldd	r25, Y+22	; 0x16
    2cda:	86 89       	ldd	r24, Z+22	; 0x16
    2cdc:	89 17       	cp	r24, r25
    2cde:	20 f4       	brcc	.+8      	; 0x2ce8 <xTaskRemoveFromEventList+0x84>
    2ce0:	81 e0       	ldi	r24, 0x01	; 1
    2ce2:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <xYieldPending>
    2ce6:	01 c0       	rjmp	.+2      	; 0x2cea <xTaskRemoveFromEventList+0x86>
    2ce8:	80 e0       	ldi	r24, 0x00	; 0
    2cea:	df 91       	pop	r29
    2cec:	cf 91       	pop	r28
    2cee:	1f 91       	pop	r17
    2cf0:	0f 91       	pop	r16
    2cf2:	08 95       	ret

00002cf4 <vTaskInternalSetTimeOutState>:
    2cf4:	20 91 95 07 	lds	r18, 0x0795	; 0x800795 <xNumOfOverflows>
    2cf8:	fc 01       	movw	r30, r24
    2cfa:	20 83       	st	Z, r18
    2cfc:	20 91 9a 07 	lds	r18, 0x079A	; 0x80079a <xTickCount>
    2d00:	30 91 9b 07 	lds	r19, 0x079B	; 0x80079b <xTickCount+0x1>
    2d04:	32 83       	std	Z+2, r19	; 0x02
    2d06:	21 83       	std	Z+1, r18	; 0x01
    2d08:	08 95       	ret

00002d0a <xTaskCheckForTimeOut>:
    2d0a:	cf 93       	push	r28
    2d0c:	df 93       	push	r29
    2d0e:	0f b6       	in	r0, 0x3f	; 63
    2d10:	f8 94       	cli
    2d12:	0f 92       	push	r0
    2d14:	20 91 9a 07 	lds	r18, 0x079A	; 0x80079a <xTickCount>
    2d18:	30 91 9b 07 	lds	r19, 0x079B	; 0x80079b <xTickCount+0x1>
    2d1c:	db 01       	movw	r26, r22
    2d1e:	4d 91       	ld	r20, X+
    2d20:	5c 91       	ld	r21, X
    2d22:	4f 3f       	cpi	r20, 0xFF	; 255
    2d24:	bf ef       	ldi	r27, 0xFF	; 255
    2d26:	5b 07       	cpc	r21, r27
    2d28:	e9 f0       	breq	.+58     	; 0x2d64 <xTaskCheckForTimeOut+0x5a>
    2d2a:	ec 01       	movw	r28, r24
    2d2c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d2e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d30:	a0 91 95 07 	lds	r26, 0x0795	; 0x800795 <xNumOfOverflows>
    2d34:	b8 81       	ld	r27, Y
    2d36:	ba 17       	cp	r27, r26
    2d38:	19 f0       	breq	.+6      	; 0x2d40 <xTaskCheckForTimeOut+0x36>
    2d3a:	2e 17       	cp	r18, r30
    2d3c:	3f 07       	cpc	r19, r31
    2d3e:	a0 f4       	brcc	.+40     	; 0x2d68 <xTaskCheckForTimeOut+0x5e>
    2d40:	2e 1b       	sub	r18, r30
    2d42:	3f 0b       	sbc	r19, r31
    2d44:	24 17       	cp	r18, r20
    2d46:	35 07       	cpc	r19, r21
    2d48:	40 f4       	brcc	.+16     	; 0x2d5a <xTaskCheckForTimeOut+0x50>
    2d4a:	fb 01       	movw	r30, r22
    2d4c:	42 1b       	sub	r20, r18
    2d4e:	53 0b       	sbc	r21, r19
    2d50:	51 83       	std	Z+1, r21	; 0x01
    2d52:	40 83       	st	Z, r20
    2d54:	cf df       	rcall	.-98     	; 0x2cf4 <vTaskInternalSetTimeOutState>
    2d56:	80 e0       	ldi	r24, 0x00	; 0
    2d58:	08 c0       	rjmp	.+16     	; 0x2d6a <xTaskCheckForTimeOut+0x60>
    2d5a:	fb 01       	movw	r30, r22
    2d5c:	11 82       	std	Z+1, r1	; 0x01
    2d5e:	10 82       	st	Z, r1
    2d60:	81 e0       	ldi	r24, 0x01	; 1
    2d62:	03 c0       	rjmp	.+6      	; 0x2d6a <xTaskCheckForTimeOut+0x60>
    2d64:	80 e0       	ldi	r24, 0x00	; 0
    2d66:	01 c0       	rjmp	.+2      	; 0x2d6a <xTaskCheckForTimeOut+0x60>
    2d68:	81 e0       	ldi	r24, 0x01	; 1
    2d6a:	0f 90       	pop	r0
    2d6c:	0f be       	out	0x3f, r0	; 63
    2d6e:	df 91       	pop	r29
    2d70:	cf 91       	pop	r28
    2d72:	08 95       	ret

00002d74 <vTaskMissedYield>:
    2d74:	81 e0       	ldi	r24, 0x01	; 1
    2d76:	80 93 96 07 	sts	0x0796, r24	; 0x800796 <xYieldPending>
    2d7a:	08 95       	ret

00002d7c <xTaskGetSchedulerState>:
    2d7c:	80 91 98 07 	lds	r24, 0x0798	; 0x800798 <xSchedulerRunning>
    2d80:	88 23       	and	r24, r24
    2d82:	31 f0       	breq	.+12     	; 0x2d90 <xTaskGetSchedulerState+0x14>
    2d84:	80 91 8f 07 	lds	r24, 0x078F	; 0x80078f <uxSchedulerSuspended>
    2d88:	88 23       	and	r24, r24
    2d8a:	21 f0       	breq	.+8      	; 0x2d94 <xTaskGetSchedulerState+0x18>
    2d8c:	80 e0       	ldi	r24, 0x00	; 0
    2d8e:	08 95       	ret
    2d90:	81 e0       	ldi	r24, 0x01	; 1
    2d92:	08 95       	ret
    2d94:	82 e0       	ldi	r24, 0x02	; 2
    2d96:	08 95       	ret

00002d98 <xTaskPriorityInherit>:
    2d98:	0f 93       	push	r16
    2d9a:	1f 93       	push	r17
    2d9c:	cf 93       	push	r28
    2d9e:	df 93       	push	r29
    2da0:	fc 01       	movw	r30, r24
    2da2:	89 2b       	or	r24, r25
    2da4:	09 f4       	brne	.+2      	; 0x2da8 <xTaskPriorityInherit+0x10>
    2da6:	64 c0       	rjmp	.+200    	; 0x2e70 <xTaskPriorityInherit+0xd8>
    2da8:	26 89       	ldd	r18, Z+22	; 0x16
    2daa:	a0 91 fc 07 	lds	r26, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2dae:	b0 91 fd 07 	lds	r27, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2db2:	56 96       	adiw	r26, 0x16	; 22
    2db4:	8c 91       	ld	r24, X
    2db6:	28 17       	cp	r18, r24
    2db8:	08 f0       	brcs	.+2      	; 0x2dbc <xTaskPriorityInherit+0x24>
    2dba:	4e c0       	rjmp	.+156    	; 0x2e58 <xTaskPriorityInherit+0xc0>
    2dbc:	84 85       	ldd	r24, Z+12	; 0x0c
    2dbe:	95 85       	ldd	r25, Z+13	; 0x0d
    2dc0:	99 23       	and	r25, r25
    2dc2:	64 f0       	brlt	.+24     	; 0x2ddc <xTaskPriorityInherit+0x44>
    2dc4:	a0 91 fc 07 	lds	r26, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2dc8:	b0 91 fd 07 	lds	r27, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2dcc:	56 96       	adiw	r26, 0x16	; 22
    2dce:	3c 91       	ld	r19, X
    2dd0:	85 e0       	ldi	r24, 0x05	; 5
    2dd2:	90 e0       	ldi	r25, 0x00	; 0
    2dd4:	83 1b       	sub	r24, r19
    2dd6:	91 09       	sbc	r25, r1
    2dd8:	95 87       	std	Z+13, r25	; 0x0d
    2dda:	84 87       	std	Z+12, r24	; 0x0c
    2ddc:	30 e0       	ldi	r19, 0x00	; 0
    2dde:	c9 01       	movw	r24, r18
    2de0:	88 0f       	add	r24, r24
    2de2:	99 1f       	adc	r25, r25
    2de4:	88 0f       	add	r24, r24
    2de6:	99 1f       	adc	r25, r25
    2de8:	88 0f       	add	r24, r24
    2dea:	99 1f       	adc	r25, r25
    2dec:	28 0f       	add	r18, r24
    2dee:	39 1f       	adc	r19, r25
    2df0:	21 53       	subi	r18, 0x31	; 49
    2df2:	38 4f       	sbci	r19, 0xF8	; 248
    2df4:	82 85       	ldd	r24, Z+10	; 0x0a
    2df6:	93 85       	ldd	r25, Z+11	; 0x0b
    2df8:	82 17       	cp	r24, r18
    2dfa:	93 07       	cpc	r25, r19
    2dfc:	21 f5       	brne	.+72     	; 0x2e46 <xTaskPriorityInherit+0xae>
    2dfe:	8f 01       	movw	r16, r30
    2e00:	ef 01       	movw	r28, r30
    2e02:	22 96       	adiw	r28, 0x02	; 2
    2e04:	ce 01       	movw	r24, r28
    2e06:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
    2e0a:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2e0e:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2e12:	86 89       	ldd	r24, Z+22	; 0x16
    2e14:	f8 01       	movw	r30, r16
    2e16:	86 8b       	std	Z+22, r24	; 0x16
    2e18:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    2e1c:	98 17       	cp	r25, r24
    2e1e:	10 f4       	brcc	.+4      	; 0x2e24 <xTaskPriorityInherit+0x8c>
    2e20:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    2e24:	90 e0       	ldi	r25, 0x00	; 0
    2e26:	9c 01       	movw	r18, r24
    2e28:	22 0f       	add	r18, r18
    2e2a:	33 1f       	adc	r19, r19
    2e2c:	22 0f       	add	r18, r18
    2e2e:	33 1f       	adc	r19, r19
    2e30:	22 0f       	add	r18, r18
    2e32:	33 1f       	adc	r19, r19
    2e34:	82 0f       	add	r24, r18
    2e36:	93 1f       	adc	r25, r19
    2e38:	be 01       	movw	r22, r28
    2e3a:	81 53       	subi	r24, 0x31	; 49
    2e3c:	98 4f       	sbci	r25, 0xF8	; 248
    2e3e:	0e 94 4e 0c 	call	0x189c	; 0x189c <vListInsertEnd>
    2e42:	81 e0       	ldi	r24, 0x01	; 1
    2e44:	16 c0       	rjmp	.+44     	; 0x2e72 <xTaskPriorityInherit+0xda>
    2e46:	a0 91 fc 07 	lds	r26, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2e4a:	b0 91 fd 07 	lds	r27, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2e4e:	56 96       	adiw	r26, 0x16	; 22
    2e50:	8c 91       	ld	r24, X
    2e52:	86 8b       	std	Z+22, r24	; 0x16
    2e54:	81 e0       	ldi	r24, 0x01	; 1
    2e56:	0d c0       	rjmp	.+26     	; 0x2e72 <xTaskPriorityInherit+0xda>
    2e58:	a0 91 fc 07 	lds	r26, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2e5c:	b0 91 fd 07 	lds	r27, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2e60:	81 e0       	ldi	r24, 0x01	; 1
    2e62:	21 a1       	ldd	r18, Z+33	; 0x21
    2e64:	56 96       	adiw	r26, 0x16	; 22
    2e66:	9c 91       	ld	r25, X
    2e68:	29 17       	cp	r18, r25
    2e6a:	18 f0       	brcs	.+6      	; 0x2e72 <xTaskPriorityInherit+0xda>
    2e6c:	80 e0       	ldi	r24, 0x00	; 0
    2e6e:	01 c0       	rjmp	.+2      	; 0x2e72 <xTaskPriorityInherit+0xda>
    2e70:	80 e0       	ldi	r24, 0x00	; 0
    2e72:	df 91       	pop	r29
    2e74:	cf 91       	pop	r28
    2e76:	1f 91       	pop	r17
    2e78:	0f 91       	pop	r16
    2e7a:	08 95       	ret

00002e7c <xTaskPriorityDisinherit>:
    2e7c:	0f 93       	push	r16
    2e7e:	1f 93       	push	r17
    2e80:	cf 93       	push	r28
    2e82:	df 93       	push	r29
    2e84:	fc 01       	movw	r30, r24
    2e86:	89 2b       	or	r24, r25
    2e88:	79 f1       	breq	.+94     	; 0x2ee8 <xTaskPriorityDisinherit+0x6c>
    2e8a:	82 a1       	ldd	r24, Z+34	; 0x22
    2e8c:	81 50       	subi	r24, 0x01	; 1
    2e8e:	82 a3       	std	Z+34, r24	; 0x22
    2e90:	26 89       	ldd	r18, Z+22	; 0x16
    2e92:	91 a1       	ldd	r25, Z+33	; 0x21
    2e94:	29 17       	cp	r18, r25
    2e96:	51 f1       	breq	.+84     	; 0x2eec <xTaskPriorityDisinherit+0x70>
    2e98:	81 11       	cpse	r24, r1
    2e9a:	2a c0       	rjmp	.+84     	; 0x2ef0 <xTaskPriorityDisinherit+0x74>
    2e9c:	ef 01       	movw	r28, r30
    2e9e:	8f 01       	movw	r16, r30
    2ea0:	0e 5f       	subi	r16, 0xFE	; 254
    2ea2:	1f 4f       	sbci	r17, 0xFF	; 255
    2ea4:	c8 01       	movw	r24, r16
    2ea6:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
    2eaa:	89 a1       	ldd	r24, Y+33	; 0x21
    2eac:	8e 8b       	std	Y+22, r24	; 0x16
    2eae:	25 e0       	ldi	r18, 0x05	; 5
    2eb0:	30 e0       	ldi	r19, 0x00	; 0
    2eb2:	28 1b       	sub	r18, r24
    2eb4:	31 09       	sbc	r19, r1
    2eb6:	3d 87       	std	Y+13, r19	; 0x0d
    2eb8:	2c 87       	std	Y+12, r18	; 0x0c
    2eba:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    2ebe:	98 17       	cp	r25, r24
    2ec0:	10 f4       	brcc	.+4      	; 0x2ec6 <xTaskPriorityDisinherit+0x4a>
    2ec2:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    2ec6:	90 e0       	ldi	r25, 0x00	; 0
    2ec8:	9c 01       	movw	r18, r24
    2eca:	22 0f       	add	r18, r18
    2ecc:	33 1f       	adc	r19, r19
    2ece:	22 0f       	add	r18, r18
    2ed0:	33 1f       	adc	r19, r19
    2ed2:	22 0f       	add	r18, r18
    2ed4:	33 1f       	adc	r19, r19
    2ed6:	82 0f       	add	r24, r18
    2ed8:	93 1f       	adc	r25, r19
    2eda:	b8 01       	movw	r22, r16
    2edc:	81 53       	subi	r24, 0x31	; 49
    2ede:	98 4f       	sbci	r25, 0xF8	; 248
    2ee0:	0e 94 4e 0c 	call	0x189c	; 0x189c <vListInsertEnd>
    2ee4:	81 e0       	ldi	r24, 0x01	; 1
    2ee6:	05 c0       	rjmp	.+10     	; 0x2ef2 <xTaskPriorityDisinherit+0x76>
    2ee8:	80 e0       	ldi	r24, 0x00	; 0
    2eea:	03 c0       	rjmp	.+6      	; 0x2ef2 <xTaskPriorityDisinherit+0x76>
    2eec:	80 e0       	ldi	r24, 0x00	; 0
    2eee:	01 c0       	rjmp	.+2      	; 0x2ef2 <xTaskPriorityDisinherit+0x76>
    2ef0:	80 e0       	ldi	r24, 0x00	; 0
    2ef2:	df 91       	pop	r29
    2ef4:	cf 91       	pop	r28
    2ef6:	1f 91       	pop	r17
    2ef8:	0f 91       	pop	r16
    2efa:	08 95       	ret

00002efc <vTaskPriorityDisinheritAfterTimeout>:
    2efc:	0f 93       	push	r16
    2efe:	1f 93       	push	r17
    2f00:	cf 93       	push	r28
    2f02:	df 93       	push	r29
    2f04:	fc 01       	movw	r30, r24
    2f06:	89 2b       	or	r24, r25
    2f08:	09 f4       	brne	.+2      	; 0x2f0c <vTaskPriorityDisinheritAfterTimeout+0x10>
    2f0a:	43 c0       	rjmp	.+134    	; 0x2f92 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2f0c:	91 a1       	ldd	r25, Z+33	; 0x21
    2f0e:	96 17       	cp	r25, r22
    2f10:	08 f4       	brcc	.+2      	; 0x2f14 <vTaskPriorityDisinheritAfterTimeout+0x18>
    2f12:	96 2f       	mov	r25, r22
    2f14:	86 89       	ldd	r24, Z+22	; 0x16
    2f16:	89 17       	cp	r24, r25
    2f18:	e1 f1       	breq	.+120    	; 0x2f92 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2f1a:	22 a1       	ldd	r18, Z+34	; 0x22
    2f1c:	21 30       	cpi	r18, 0x01	; 1
    2f1e:	c9 f5       	brne	.+114    	; 0x2f92 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2f20:	96 8b       	std	Z+22, r25	; 0x16
    2f22:	24 85       	ldd	r18, Z+12	; 0x0c
    2f24:	35 85       	ldd	r19, Z+13	; 0x0d
    2f26:	33 23       	and	r19, r19
    2f28:	34 f0       	brlt	.+12     	; 0x2f36 <vTaskPriorityDisinheritAfterTimeout+0x3a>
    2f2a:	25 e0       	ldi	r18, 0x05	; 5
    2f2c:	30 e0       	ldi	r19, 0x00	; 0
    2f2e:	29 1b       	sub	r18, r25
    2f30:	31 09       	sbc	r19, r1
    2f32:	35 87       	std	Z+13, r19	; 0x0d
    2f34:	24 87       	std	Z+12, r18	; 0x0c
    2f36:	90 e0       	ldi	r25, 0x00	; 0
    2f38:	9c 01       	movw	r18, r24
    2f3a:	22 0f       	add	r18, r18
    2f3c:	33 1f       	adc	r19, r19
    2f3e:	22 0f       	add	r18, r18
    2f40:	33 1f       	adc	r19, r19
    2f42:	22 0f       	add	r18, r18
    2f44:	33 1f       	adc	r19, r19
    2f46:	82 0f       	add	r24, r18
    2f48:	93 1f       	adc	r25, r19
    2f4a:	81 53       	subi	r24, 0x31	; 49
    2f4c:	98 4f       	sbci	r25, 0xF8	; 248
    2f4e:	22 85       	ldd	r18, Z+10	; 0x0a
    2f50:	33 85       	ldd	r19, Z+11	; 0x0b
    2f52:	28 17       	cp	r18, r24
    2f54:	39 07       	cpc	r19, r25
    2f56:	e9 f4       	brne	.+58     	; 0x2f92 <vTaskPriorityDisinheritAfterTimeout+0x96>
    2f58:	ef 01       	movw	r28, r30
    2f5a:	8f 01       	movw	r16, r30
    2f5c:	0e 5f       	subi	r16, 0xFE	; 254
    2f5e:	1f 4f       	sbci	r17, 0xFF	; 255
    2f60:	c8 01       	movw	r24, r16
    2f62:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
    2f66:	8e 89       	ldd	r24, Y+22	; 0x16
    2f68:	90 91 99 07 	lds	r25, 0x0799	; 0x800799 <uxTopReadyPriority>
    2f6c:	98 17       	cp	r25, r24
    2f6e:	10 f4       	brcc	.+4      	; 0x2f74 <vTaskPriorityDisinheritAfterTimeout+0x78>
    2f70:	80 93 99 07 	sts	0x0799, r24	; 0x800799 <uxTopReadyPriority>
    2f74:	90 e0       	ldi	r25, 0x00	; 0
    2f76:	9c 01       	movw	r18, r24
    2f78:	22 0f       	add	r18, r18
    2f7a:	33 1f       	adc	r19, r19
    2f7c:	22 0f       	add	r18, r18
    2f7e:	33 1f       	adc	r19, r19
    2f80:	22 0f       	add	r18, r18
    2f82:	33 1f       	adc	r19, r19
    2f84:	82 0f       	add	r24, r18
    2f86:	93 1f       	adc	r25, r19
    2f88:	b8 01       	movw	r22, r16
    2f8a:	81 53       	subi	r24, 0x31	; 49
    2f8c:	98 4f       	sbci	r25, 0xF8	; 248
    2f8e:	0e 94 4e 0c 	call	0x189c	; 0x189c <vListInsertEnd>
    2f92:	df 91       	pop	r29
    2f94:	cf 91       	pop	r28
    2f96:	1f 91       	pop	r17
    2f98:	0f 91       	pop	r16
    2f9a:	08 95       	ret

00002f9c <pvTaskIncrementMutexHeldCount>:

	TaskHandle_t pvTaskIncrementMutexHeldCount( void )
	{
		/* If xSemaphoreCreateMutex() is called before any tasks have been created
		then pxCurrentTCB will be NULL. */
		if( pxCurrentTCB != NULL )
    2f9c:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2fa0:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2fa4:	89 2b       	or	r24, r25
    2fa6:	39 f0       	breq	.+14     	; 0x2fb6 <pvTaskIncrementMutexHeldCount+0x1a>
		{
			( pxCurrentTCB->uxMutexesHeld )++;
    2fa8:	e0 91 fc 07 	lds	r30, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2fac:	f0 91 fd 07 	lds	r31, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
    2fb0:	82 a1       	ldd	r24, Z+34	; 0x22
    2fb2:	8f 5f       	subi	r24, 0xFF	; 255
    2fb4:	82 a3       	std	Z+34, r24	; 0x22
		}

		return pxCurrentTCB;
    2fb6:	80 91 fc 07 	lds	r24, 0x07FC	; 0x8007fc <pxCurrentTCB>
    2fba:	90 91 fd 07 	lds	r25, 0x07FD	; 0x8007fd <pxCurrentTCB+0x1>
	}
    2fbe:	08 95       	ret

00002fc0 <prvInsertTimerInActiveList>:
	return xTimeNow;
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
    2fc0:	fc 01       	movw	r30, r24
BaseType_t xProcessTimerNow = pdFALSE;

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    2fc2:	73 83       	std	Z+3, r23	; 0x03
    2fc4:	62 83       	std	Z+2, r22	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    2fc6:	91 87       	std	Z+9, r25	; 0x09
    2fc8:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    2fca:	46 17       	cp	r20, r22
    2fcc:	57 07       	cpc	r21, r23
    2fce:	90 f0       	brcs	.+36     	; 0x2ff4 <prvInsertTimerInActiveList+0x34>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
    2fd0:	42 1b       	sub	r20, r18
    2fd2:	53 0b       	sbc	r21, r19
    2fd4:	84 85       	ldd	r24, Z+12	; 0x0c
    2fd6:	95 85       	ldd	r25, Z+13	; 0x0d
    2fd8:	48 17       	cp	r20, r24
    2fda:	59 07       	cpc	r21, r25
    2fdc:	e0 f4       	brcc	.+56     	; 0x3016 <prvInsertTimerInActiveList+0x56>
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    2fde:	bf 01       	movw	r22, r30
    2fe0:	6e 5f       	subi	r22, 0xFE	; 254
    2fe2:	7f 4f       	sbci	r23, 0xFF	; 255
    2fe4:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <pxOverflowTimerList>
    2fe8:	90 91 05 08 	lds	r25, 0x0805	; 0x800805 <pxOverflowTimerList+0x1>
    2fec:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    2ff0:	80 e0       	ldi	r24, 0x00	; 0
    2ff2:	08 95       	ret
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    2ff4:	42 17       	cp	r20, r18
    2ff6:	53 07       	cpc	r21, r19
    2ff8:	18 f4       	brcc	.+6      	; 0x3000 <prvInsertTimerInActiveList+0x40>
    2ffa:	62 17       	cp	r22, r18
    2ffc:	73 07       	cpc	r23, r19
    2ffe:	68 f4       	brcc	.+26     	; 0x301a <prvInsertTimerInActiveList+0x5a>
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3000:	bf 01       	movw	r22, r30
    3002:	6e 5f       	subi	r22, 0xFE	; 254
    3004:	7f 4f       	sbci	r23, 0xFF	; 255
    3006:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <pxCurrentTimerList>
    300a:	90 91 07 08 	lds	r25, 0x0807	; 0x800807 <pxCurrentTimerList+0x1>
    300e:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInsert>
}
/*-----------------------------------------------------------*/

static BaseType_t prvInsertTimerInActiveList( Timer_t * const pxTimer, const TickType_t xNextExpiryTime, const TickType_t xTimeNow, const TickType_t xCommandTime )
{
BaseType_t xProcessTimerNow = pdFALSE;
    3012:	80 e0       	ldi	r24, 0x00	; 0
    3014:	08 95       	ret
		timer was issued, and the time the command was processed? */
		if( ( ( TickType_t ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks ) /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    3016:	81 e0       	ldi	r24, 0x01	; 1
    3018:	08 95       	ret
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    301a:	81 e0       	ldi	r24, 0x01	; 1
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
		}
	}

	return xProcessTimerNow;
}
    301c:	08 95       	ret

0000301e <prvCheckForValidListAndQueue>:
static void prvCheckForValidListAndQueue( void )
{
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    301e:	0f b6       	in	r0, 0x3f	; 63
    3020:	f8 94       	cli
    3022:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    3024:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xTimerQueue>
    3028:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <xTimerQueue+0x1>
    302c:	89 2b       	or	r24, r25
    302e:	e9 f4       	brne	.+58     	; 0x306a <prvCheckForValidListAndQueue+0x4c>
		{
			vListInitialise( &xActiveTimerList1 );
    3030:	81 e1       	ldi	r24, 0x11	; 17
    3032:	98 e0       	ldi	r25, 0x08	; 8
    3034:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    3038:	88 e0       	ldi	r24, 0x08	; 8
    303a:	98 e0       	ldi	r25, 0x08	; 8
    303c:	0e 94 3c 0c 	call	0x1878	; 0x1878 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    3040:	81 e1       	ldi	r24, 0x11	; 17
    3042:	98 e0       	ldi	r25, 0x08	; 8
    3044:	90 93 07 08 	sts	0x0807, r25	; 0x800807 <pxCurrentTimerList+0x1>
    3048:	80 93 06 08 	sts	0x0806, r24	; 0x800806 <pxCurrentTimerList>
			pxOverflowTimerList = &xActiveTimerList2;
    304c:	88 e0       	ldi	r24, 0x08	; 8
    304e:	98 e0       	ldi	r25, 0x08	; 8
    3050:	90 93 05 08 	sts	0x0805, r25	; 0x800805 <pxOverflowTimerList+0x1>
    3054:	80 93 04 08 	sts	0x0804, r24	; 0x800804 <pxOverflowTimerList>

				xTimerQueue = xQueueCreateStatic( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, ( UBaseType_t ) sizeof( DaemonTaskMessage_t ), &( ucStaticTimerQueueStorage[ 0 ] ), &xStaticTimerQueue );
			}
			#else
			{
				xTimerQueue = xQueueCreate( ( UBaseType_t ) configTIMER_QUEUE_LENGTH, sizeof( DaemonTaskMessage_t ) );
    3058:	40 e0       	ldi	r20, 0x00	; 0
    305a:	65 e0       	ldi	r22, 0x05	; 5
    305c:	8f e0       	ldi	r24, 0x0F	; 15
    305e:	0e 94 2b 0f 	call	0x1e56	; 0x1e56 <xQueueGenericCreate>
    3062:	90 93 03 08 	sts	0x0803, r25	; 0x800803 <xTimerQueue+0x1>
    3066:	80 93 02 08 	sts	0x0802, r24	; 0x800802 <xTimerQueue>
		else
		{
			mtCOVERAGE_TEST_MARKER();
		}
	}
	taskEXIT_CRITICAL();
    306a:	0f 90       	pop	r0
    306c:	0f be       	out	0x3f, r0	; 63
    306e:	08 95       	ret

00003070 <xTimerCreateTimerTask>:
									TimerCallbackFunction_t pxCallbackFunction,
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
    3070:	ef 92       	push	r14
    3072:	ff 92       	push	r15
    3074:	0f 93       	push	r16

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    3076:	d3 df       	rcall	.-90     	; 0x301e <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    3078:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xTimerQueue>
    307c:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <xTimerQueue+0x1>
    3080:	89 2b       	or	r24, r25
    3082:	89 f0       	breq	.+34     	; 0x30a6 <xTimerCreateTimerTask+0x36>
				xReturn = pdPASS;
			}
		}
		#else
		{
			xReturn = xTaskCreate(	prvTimerTask,
    3084:	0f 2e       	mov	r0, r31
    3086:	f0 e0       	ldi	r31, 0x00	; 0
    3088:	ef 2e       	mov	r14, r31
    308a:	f8 e0       	ldi	r31, 0x08	; 8
    308c:	ff 2e       	mov	r15, r31
    308e:	f0 2d       	mov	r31, r0
    3090:	04 e0       	ldi	r16, 0x04	; 4
    3092:	20 e0       	ldi	r18, 0x00	; 0
    3094:	30 e0       	ldi	r19, 0x00	; 0
    3096:	44 e6       	ldi	r20, 0x64	; 100
    3098:	50 e0       	ldi	r21, 0x00	; 0
    309a:	6f e3       	ldi	r22, 0x3F	; 63
    309c:	71 e0       	ldi	r23, 0x01	; 1
    309e:	83 e4       	ldi	r24, 0x43	; 67
    30a0:	99 e1       	ldi	r25, 0x19	; 25
    30a2:	e0 d9       	rcall	.-3136   	; 0x2464 <xTaskCreate>
    30a4:	01 c0       	rjmp	.+2      	; 0x30a8 <xTimerCreateTimerTask+0x38>
									Timer_t *pxNewTimer ) PRIVILEGED_FUNCTION;
/*-----------------------------------------------------------*/

BaseType_t xTimerCreateTimerTask( void )
{
BaseType_t xReturn = pdFAIL;
    30a6:	80 e0       	ldi	r24, 0x00	; 0
		mtCOVERAGE_TEST_MARKER();
	}

	configASSERT( xReturn );
	return xReturn;
}
    30a8:	0f 91       	pop	r16
    30aa:	ff 90       	pop	r15
    30ac:	ef 90       	pop	r14
    30ae:	08 95       	ret

000030b0 <xTimerCreate>:
	TimerHandle_t xTimerCreate(	const char * const pcTimerName,			/*lint !e971 Unqualified char types are allowed for strings and single characters only. */
								const TickType_t xTimerPeriodInTicks,
								const UBaseType_t uxAutoReload,
								void * const pvTimerID,
								TimerCallbackFunction_t pxCallbackFunction )
	{
    30b0:	8f 92       	push	r8
    30b2:	9f 92       	push	r9
    30b4:	af 92       	push	r10
    30b6:	bf 92       	push	r11
    30b8:	cf 92       	push	r12
    30ba:	df 92       	push	r13
    30bc:	ff 92       	push	r15
    30be:	0f 93       	push	r16
    30c0:	1f 93       	push	r17
    30c2:	cf 93       	push	r28
    30c4:	df 93       	push	r29
    30c6:	4c 01       	movw	r8, r24
    30c8:	5b 01       	movw	r10, r22
    30ca:	f4 2e       	mov	r15, r20
    30cc:	69 01       	movw	r12, r18
	Timer_t *pxNewTimer;

		pxNewTimer = ( Timer_t * ) pvPortMalloc( sizeof( Timer_t ) ); /*lint !e9087 !e9079 All values returned by pvPortMalloc() have at least the alignment required by the MCU's stack, and the first member of Timer_t is always a pointer to the timer's mame. */
    30ce:	83 e1       	ldi	r24, 0x13	; 19
    30d0:	90 e0       	ldi	r25, 0x00	; 0
    30d2:	0e 94 51 0b 	call	0x16a2	; 0x16a2 <pvPortMalloc>
    30d6:	ec 01       	movw	r28, r24

		if( pxNewTimer != NULL )
    30d8:	89 2b       	or	r24, r25
    30da:	99 f0       	breq	.+38     	; 0x3102 <xTimerCreate+0x52>
		{
			/* Status is thus far zero as the timer is not created statically
			and has not been started.  The autoreload bit may get set in
			prvInitialiseNewTimer. */
			pxNewTimer->ucStatus = 0x00;
    30dc:	1a 8a       	std	Y+18, r1	; 0x12

	if( pxNewTimer != NULL )
	{
		/* Ensure the infrastructure used by the timer service task has been
		created/initialised. */
		prvCheckForValidListAndQueue();
    30de:	9f df       	rcall	.-194    	; 0x301e <prvCheckForValidListAndQueue>

		/* Initialise the timer structure members using the function
		parameters. */
		pxNewTimer->pcTimerName = pcTimerName;
    30e0:	99 82       	std	Y+1, r9	; 0x01
    30e2:	88 82       	st	Y, r8
		pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    30e4:	bd 86       	std	Y+13, r11	; 0x0d
    30e6:	ac 86       	std	Y+12, r10	; 0x0c
		pxNewTimer->pvTimerID = pvTimerID;
    30e8:	df 86       	std	Y+15, r13	; 0x0f
    30ea:	ce 86       	std	Y+14, r12	; 0x0e
		pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    30ec:	19 8b       	std	Y+17, r17	; 0x11
    30ee:	08 8b       	std	Y+16, r16	; 0x10
		vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    30f0:	ce 01       	movw	r24, r28
    30f2:	02 96       	adiw	r24, 0x02	; 2
    30f4:	0e 94 4a 0c 	call	0x1894	; 0x1894 <vListInitialiseItem>
		if( uxAutoReload != pdFALSE )
    30f8:	ff 20       	and	r15, r15
    30fa:	19 f0       	breq	.+6      	; 0x3102 <xTimerCreate+0x52>
		{
			pxNewTimer->ucStatus |= tmrSTATUS_IS_AUTORELOAD;
    30fc:	8a 89       	ldd	r24, Y+18	; 0x12
    30fe:	84 60       	ori	r24, 0x04	; 4
    3100:	8a 8b       	std	Y+18, r24	; 0x12
			pxNewTimer->ucStatus = 0x00;
			prvInitialiseNewTimer( pcTimerName, xTimerPeriodInTicks, uxAutoReload, pvTimerID, pxCallbackFunction, pxNewTimer );
		}

		return pxNewTimer;
	}
    3102:	ce 01       	movw	r24, r28
    3104:	df 91       	pop	r29
    3106:	cf 91       	pop	r28
    3108:	1f 91       	pop	r17
    310a:	0f 91       	pop	r16
    310c:	ff 90       	pop	r15
    310e:	df 90       	pop	r13
    3110:	cf 90       	pop	r12
    3112:	bf 90       	pop	r11
    3114:	af 90       	pop	r10
    3116:	9f 90       	pop	r9
    3118:	8f 90       	pop	r8
    311a:	08 95       	ret

0000311c <xTimerGenericCommand>:
	}
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
    311c:	0f 93       	push	r16
    311e:	1f 93       	push	r17
    3120:	cf 93       	push	r28
    3122:	df 93       	push	r29
    3124:	00 d0       	rcall	.+0      	; 0x3126 <xTimerGenericCommand+0xa>
    3126:	00 d0       	rcall	.+0      	; 0x3128 <xTimerGenericCommand+0xc>
    3128:	1f 92       	push	r1
    312a:	cd b7       	in	r28, 0x3d	; 61
    312c:	de b7       	in	r29, 0x3e	; 62

	configASSERT( xTimer );

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    312e:	e0 91 02 08 	lds	r30, 0x0802	; 0x800802 <xTimerQueue>
    3132:	f0 91 03 08 	lds	r31, 0x0803	; 0x800803 <xTimerQueue+0x1>
    3136:	30 97       	sbiw	r30, 0x00	; 0
    3138:	69 f1       	breq	.+90     	; 0x3194 <xTimerGenericCommand+0x78>
    313a:	d9 01       	movw	r26, r18
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    313c:	69 83       	std	Y+1, r22	; 0x01
		xMessage.u.xTimerParameters.xMessageValue = xOptionalValue;
    313e:	5b 83       	std	Y+3, r21	; 0x03
    3140:	4a 83       	std	Y+2, r20	; 0x02
		xMessage.u.xTimerParameters.pxTimer = xTimer;
    3142:	9d 83       	std	Y+5, r25	; 0x05
    3144:	8c 83       	std	Y+4, r24	; 0x04

		if( xCommandID < tmrFIRST_FROM_ISR_COMMAND )
    3146:	66 30       	cpi	r22, 0x06	; 6
    3148:	e4 f4       	brge	.+56     	; 0x3182 <xTimerGenericCommand+0x66>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    314a:	18 de       	rcall	.-976    	; 0x2d7c <xTaskGetSchedulerState>
    314c:	82 30       	cpi	r24, 0x02	; 2
    314e:	61 f4       	brne	.+24     	; 0x3168 <xTimerGenericCommand+0x4c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xTicksToWait );
    3150:	20 e0       	ldi	r18, 0x00	; 0
    3152:	a8 01       	movw	r20, r16
    3154:	be 01       	movw	r22, r28
    3156:	6f 5f       	subi	r22, 0xFF	; 255
    3158:	7f 4f       	sbci	r23, 0xFF	; 255
    315a:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xTimerQueue>
    315e:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <xTimerQueue+0x1>
    3162:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
    3166:	17 c0       	rjmp	.+46     	; 0x3196 <xTimerGenericCommand+0x7a>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3168:	20 e0       	ldi	r18, 0x00	; 0
    316a:	40 e0       	ldi	r20, 0x00	; 0
    316c:	50 e0       	ldi	r21, 0x00	; 0
    316e:	be 01       	movw	r22, r28
    3170:	6f 5f       	subi	r22, 0xFF	; 255
    3172:	7f 4f       	sbci	r23, 0xFF	; 255
    3174:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xTimerQueue>
    3178:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <xTimerQueue+0x1>
    317c:	0e 94 55 0f 	call	0x1eaa	; 0x1eaa <xQueueGenericSend>
    3180:	0a c0       	rjmp	.+20     	; 0x3196 <xTimerGenericCommand+0x7a>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    3182:	20 e0       	ldi	r18, 0x00	; 0
    3184:	ad 01       	movw	r20, r26
    3186:	be 01       	movw	r22, r28
    3188:	6f 5f       	subi	r22, 0xFF	; 255
    318a:	7f 4f       	sbci	r23, 0xFF	; 255
    318c:	cf 01       	movw	r24, r30
    318e:	0e 94 ff 0f 	call	0x1ffe	; 0x1ffe <xQueueGenericSendFromISR>
    3192:	01 c0       	rjmp	.+2      	; 0x3196 <xTimerGenericCommand+0x7a>
}
/*-----------------------------------------------------------*/

BaseType_t xTimerGenericCommand( TimerHandle_t xTimer, const BaseType_t xCommandID, const TickType_t xOptionalValue, BaseType_t * const pxHigherPriorityTaskWoken, const TickType_t xTicksToWait )
{
BaseType_t xReturn = pdFAIL;
    3194:	80 e0       	ldi	r24, 0x00	; 0
	{
		mtCOVERAGE_TEST_MARKER();
	}

	return xReturn;
}
    3196:	0f 90       	pop	r0
    3198:	0f 90       	pop	r0
    319a:	0f 90       	pop	r0
    319c:	0f 90       	pop	r0
    319e:	0f 90       	pop	r0
    31a0:	df 91       	pop	r29
    31a2:	cf 91       	pop	r28
    31a4:	1f 91       	pop	r17
    31a6:	0f 91       	pop	r16
    31a8:	08 95       	ret

000031aa <prvSampleTimeNow>:
	return xNextExpireTime;
}
/*-----------------------------------------------------------*/

static TickType_t prvSampleTimeNow( BaseType_t * const pxTimerListsWereSwitched )
{
    31aa:	af 92       	push	r10
    31ac:	bf 92       	push	r11
    31ae:	cf 92       	push	r12
    31b0:	df 92       	push	r13
    31b2:	ef 92       	push	r14
    31b4:	ff 92       	push	r15
    31b6:	0f 93       	push	r16
    31b8:	1f 93       	push	r17
    31ba:	cf 93       	push	r28
    31bc:	df 93       	push	r29
    31be:	6c 01       	movw	r12, r24
TickType_t xTimeNow;
PRIVILEGED_DATA static TickType_t xLastTime = ( TickType_t ) 0U; /*lint !e956 Variable is only accessible to one task. */

	xTimeNow = xTaskGetTickCount();
    31c0:	24 db       	rcall	.-2488   	; 0x280a <xTaskGetTickCount>
    31c2:	7c 01       	movw	r14, r24

	if( xTimeNow < xLastTime )
    31c4:	80 91 fe 07 	lds	r24, 0x07FE	; 0x8007fe <xLastTime.2378>
    31c8:	90 91 ff 07 	lds	r25, 0x07FF	; 0x8007ff <xLastTime.2378+0x1>
    31cc:	e8 16       	cp	r14, r24
    31ce:	f9 06       	cpc	r15, r25
    31d0:	08 f0       	brcs	.+2      	; 0x31d4 <prvSampleTimeNow+0x2a>
    31d2:	47 c0       	rjmp	.+142    	; 0x3262 <prvSampleTimeNow+0xb8>
    31d4:	2f c0       	rjmp	.+94     	; 0x3234 <prvSampleTimeNow+0x8a>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    31d6:	05 80       	ldd	r0, Z+5	; 0x05
    31d8:	f6 81       	ldd	r31, Z+6	; 0x06
    31da:	e0 2d       	mov	r30, r0
    31dc:	a0 80       	ld	r10, Z
    31de:	b1 80       	ldd	r11, Z+1	; 0x01

		/* Remove the timer from the list. */
		pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    31e0:	c6 81       	ldd	r28, Z+6	; 0x06
    31e2:	d7 81       	ldd	r29, Z+7	; 0x07
		( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    31e4:	8e 01       	movw	r16, r28
    31e6:	0e 5f       	subi	r16, 0xFE	; 254
    31e8:	1f 4f       	sbci	r17, 0xFF	; 255
    31ea:	c8 01       	movw	r24, r16
    31ec:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
		traceTIMER_EXPIRED( pxTimer );

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    31f0:	e8 89       	ldd	r30, Y+16	; 0x10
    31f2:	f9 89       	ldd	r31, Y+17	; 0x11
    31f4:	ce 01       	movw	r24, r28
    31f6:	09 95       	icall

		if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    31f8:	8a 89       	ldd	r24, Y+18	; 0x12
    31fa:	82 ff       	sbrs	r24, 2
    31fc:	1b c0       	rjmp	.+54     	; 0x3234 <prvSampleTimeNow+0x8a>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    31fe:	8c 85       	ldd	r24, Y+12	; 0x0c
    3200:	9d 85       	ldd	r25, Y+13	; 0x0d
    3202:	8a 0d       	add	r24, r10
    3204:	9b 1d       	adc	r25, r11
			if( xReloadTime > xNextExpireTime )
    3206:	a8 16       	cp	r10, r24
    3208:	b9 06       	cpc	r11, r25
    320a:	60 f4       	brcc	.+24     	; 0x3224 <prvSampleTimeNow+0x7a>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    320c:	9b 83       	std	Y+3, r25	; 0x03
    320e:	8a 83       	std	Y+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3210:	d9 87       	std	Y+9, r29	; 0x09
    3212:	c8 87       	std	Y+8, r28	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3214:	b8 01       	movw	r22, r16
    3216:	80 91 06 08 	lds	r24, 0x0806	; 0x800806 <pxCurrentTimerList>
    321a:	90 91 07 08 	lds	r25, 0x0807	; 0x800807 <pxCurrentTimerList+0x1>
    321e:	0e 94 6f 0c 	call	0x18de	; 0x18de <vListInsert>
    3222:	08 c0       	rjmp	.+16     	; 0x3234 <prvSampleTimeNow+0x8a>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3224:	00 e0       	ldi	r16, 0x00	; 0
    3226:	10 e0       	ldi	r17, 0x00	; 0
    3228:	20 e0       	ldi	r18, 0x00	; 0
    322a:	30 e0       	ldi	r19, 0x00	; 0
    322c:	a5 01       	movw	r20, r10
    322e:	60 e0       	ldi	r22, 0x00	; 0
    3230:	ce 01       	movw	r24, r28
    3232:	74 df       	rcall	.-280    	; 0x311c <xTimerGenericCommand>

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3234:	e0 91 06 08 	lds	r30, 0x0806	; 0x800806 <pxCurrentTimerList>
    3238:	f0 91 07 08 	lds	r31, 0x0807	; 0x800807 <pxCurrentTimerList+0x1>
    323c:	80 81       	ld	r24, Z
    323e:	81 11       	cpse	r24, r1
    3240:	ca cf       	rjmp	.-108    	; 0x31d6 <prvSampleTimeNow+0x2c>
			mtCOVERAGE_TEST_MARKER();
		}
	}

	pxTemp = pxCurrentTimerList;
	pxCurrentTimerList = pxOverflowTimerList;
    3242:	80 91 04 08 	lds	r24, 0x0804	; 0x800804 <pxOverflowTimerList>
    3246:	90 91 05 08 	lds	r25, 0x0805	; 0x800805 <pxOverflowTimerList+0x1>
    324a:	90 93 07 08 	sts	0x0807, r25	; 0x800807 <pxCurrentTimerList+0x1>
    324e:	80 93 06 08 	sts	0x0806, r24	; 0x800806 <pxCurrentTimerList>
	pxOverflowTimerList = pxTemp;
    3252:	f0 93 05 08 	sts	0x0805, r31	; 0x800805 <pxOverflowTimerList+0x1>
    3256:	e0 93 04 08 	sts	0x0804, r30	; 0x800804 <pxOverflowTimerList>
	xTimeNow = xTaskGetTickCount();

	if( xTimeNow < xLastTime )
	{
		prvSwitchTimerLists();
		*pxTimerListsWereSwitched = pdTRUE;
    325a:	81 e0       	ldi	r24, 0x01	; 1
    325c:	f6 01       	movw	r30, r12
    325e:	80 83       	st	Z, r24
    3260:	02 c0       	rjmp	.+4      	; 0x3266 <prvSampleTimeNow+0xbc>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3262:	f6 01       	movw	r30, r12
    3264:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    3266:	f0 92 ff 07 	sts	0x07FF, r15	; 0x8007ff <xLastTime.2378+0x1>
    326a:	e0 92 fe 07 	sts	0x07FE, r14	; 0x8007fe <xLastTime.2378>

	return xTimeNow;
}
    326e:	c7 01       	movw	r24, r14
    3270:	df 91       	pop	r29
    3272:	cf 91       	pop	r28
    3274:	1f 91       	pop	r17
    3276:	0f 91       	pop	r16
    3278:	ff 90       	pop	r15
    327a:	ef 90       	pop	r14
    327c:	df 90       	pop	r13
    327e:	cf 90       	pop	r12
    3280:	bf 90       	pop	r11
    3282:	af 90       	pop	r10
    3284:	08 95       	ret

00003286 <prvTimerTask>:
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( prvTimerTask, pvParameters )
{
    3286:	cf 93       	push	r28
    3288:	df 93       	push	r29
    328a:	00 d0       	rcall	.+0      	; 0x328c <prvTimerTask+0x6>
    328c:	00 d0       	rcall	.+0      	; 0x328e <prvTimerTask+0x8>
    328e:	00 d0       	rcall	.+0      	; 0x3290 <prvTimerTask+0xa>
    3290:	cd b7       	in	r28, 0x3d	; 61
    3292:	de b7       	in	r29, 0x3e	; 62
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3294:	ce 01       	movw	r24, r28
    3296:	01 96       	adiw	r24, 0x01	; 1
    3298:	4c 01       	movw	r8, r24
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    329a:	44 24       	eor	r4, r4
    329c:	43 94       	inc	r4
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    329e:	e1 2c       	mov	r14, r1
    32a0:	f1 2c       	mov	r15, r1
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    32a2:	51 2c       	mov	r5, r1
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    32a4:	c8 2e       	mov	r12, r24
    32a6:	d9 2c       	mov	r13, r9
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    32a8:	e0 91 06 08 	lds	r30, 0x0806	; 0x800806 <pxCurrentTimerList>
    32ac:	f0 91 07 08 	lds	r31, 0x0807	; 0x800807 <pxCurrentTimerList+0x1>
    32b0:	80 81       	ld	r24, Z
	if( *pxListWasEmpty == pdFALSE )
    32b2:	88 23       	and	r24, r24
    32b4:	09 f4       	brne	.+2      	; 0x32b8 <prvTimerTask+0x32>
    32b6:	d0 c0       	rjmp	.+416    	; 0x3458 <prvTimerTask+0x1d2>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    32b8:	05 80       	ldd	r0, Z+5	; 0x05
    32ba:	f6 81       	ldd	r31, Z+6	; 0x06
    32bc:	e0 2d       	mov	r30, r0
    32be:	a0 80       	ld	r10, Z
    32c0:	b1 80       	ldd	r11, Z+1	; 0x01
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    32c2:	9d da       	rcall	.-2758   	; 0x27fe <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    32c4:	c4 01       	movw	r24, r8
    32c6:	71 df       	rcall	.-286    	; 0x31aa <prvSampleTimeNow>
    32c8:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    32ca:	89 81       	ldd	r24, Y+1	; 0x01
    32cc:	81 11       	cpse	r24, r1
    32ce:	47 c0       	rjmp	.+142    	; 0x335e <prvTimerTask+0xd8>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    32d0:	0a 15       	cp	r16, r10
    32d2:	1b 05       	cpc	r17, r11
			{
				( void ) xTaskResumeAll();
    32d4:	a0 f1       	brcs	.+104    	; 0x333e <prvTimerTask+0xb8>
    32d6:	5b db       	rcall	.-2378   	; 0x298e <xTaskResumeAll>
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( const TickType_t xNextExpireTime, const TickType_t xTimeNow )
{
BaseType_t xResult;
Timer_t * const pxTimer = ( Timer_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList ); /*lint !e9087 !e9079 void * is used as this macro is used with tasks and co-routines too.  Alignment is known to be fine as the type of the pointer stored and retrieved is the same. */
    32d8:	e0 91 06 08 	lds	r30, 0x0806	; 0x800806 <pxCurrentTimerList>
    32dc:	f0 91 07 08 	lds	r31, 0x0807	; 0x800807 <pxCurrentTimerList+0x1>
    32e0:	05 80       	ldd	r0, Z+5	; 0x05
    32e2:	f6 81       	ldd	r31, Z+6	; 0x06
    32e4:	e0 2d       	mov	r30, r0
    32e6:	66 80       	ldd	r6, Z+6	; 0x06
    32e8:	77 80       	ldd	r7, Z+7	; 0x07

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    32ea:	c3 01       	movw	r24, r6
    32ec:	02 96       	adiw	r24, 0x02	; 2
    32ee:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    32f2:	d3 01       	movw	r26, r6
    32f4:	52 96       	adiw	r26, 0x12	; 18
    32f6:	8c 91       	ld	r24, X
    32f8:	52 97       	sbiw	r26, 0x12	; 18
    32fa:	82 ff       	sbrs	r24, 2
    32fc:	15 c0       	rjmp	.+42     	; 0x3328 <prvTimerTask+0xa2>
	{
		/* The timer is inserted into a list using a time relative to anything
		other than the current time.  It will therefore be inserted into the
		correct list relative to the time this task thinks it is now. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) != pdFALSE )
    32fe:	1c 96       	adiw	r26, 0x0c	; 12
    3300:	6d 91       	ld	r22, X+
    3302:	7c 91       	ld	r23, X
    3304:	1d 97       	sbiw	r26, 0x0d	; 13
    3306:	6a 0d       	add	r22, r10
    3308:	7b 1d       	adc	r23, r11
    330a:	95 01       	movw	r18, r10
    330c:	a8 01       	movw	r20, r16
    330e:	c3 01       	movw	r24, r6
    3310:	57 de       	rcall	.-850    	; 0x2fc0 <prvInsertTimerInActiveList>
    3312:	88 23       	and	r24, r24
    3314:	61 f0       	breq	.+24     	; 0x332e <prvTimerTask+0xa8>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xNextExpireTime, NULL, tmrNO_DELAY );
    3316:	0e 2d       	mov	r16, r14
    3318:	1f 2d       	mov	r17, r15
    331a:	2e 2d       	mov	r18, r14
    331c:	3f 2d       	mov	r19, r15
    331e:	a5 01       	movw	r20, r10
    3320:	65 2d       	mov	r22, r5
    3322:	c3 01       	movw	r24, r6
    3324:	fb de       	rcall	.-522    	; 0x311c <xTimerGenericCommand>
    3326:	03 c0       	rjmp	.+6      	; 0x332e <prvTimerTask+0xa8>
			mtCOVERAGE_TEST_MARKER();
		}
	}
	else
	{
		pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3328:	8e 7f       	andi	r24, 0xFE	; 254
    332a:	f3 01       	movw	r30, r6
    332c:	82 8b       	std	Z+18, r24	; 0x12
		mtCOVERAGE_TEST_MARKER();
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    332e:	d3 01       	movw	r26, r6
    3330:	50 96       	adiw	r26, 0x10	; 16
    3332:	ed 91       	ld	r30, X+
    3334:	fc 91       	ld	r31, X
    3336:	51 97       	sbiw	r26, 0x11	; 17
    3338:	c3 01       	movw	r24, r6
    333a:	09 95       	icall
    333c:	80 c0       	rjmp	.+256    	; 0x343e <prvTimerTask+0x1b8>
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
		if( xTimerListsWereSwitched == pdFALSE )
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    333e:	45 2d       	mov	r20, r5
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
				}

				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ), xListWasEmpty );
    3340:	b5 01       	movw	r22, r10
    3342:	60 1b       	sub	r22, r16
    3344:	71 0b       	sbc	r23, r17
    3346:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xTimerQueue>
    334a:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <xTimerQueue+0x1>
    334e:	0e 94 7b 11 	call	0x22f6	; 0x22f6 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    3352:	1d db       	rcall	.-2502   	; 0x298e <xTaskResumeAll>
    3354:	81 11       	cpse	r24, r1
				{
					/* Yield to wait for either a command to arrive, or the
					block time to expire.  If a command arrived between the
					critical section being exited and this yield then the yield
					will not cause the task to block. */
					portYIELD_WITHIN_API();
    3356:	73 c0       	rjmp	.+230    	; 0x343e <prvTimerTask+0x1b8>
    3358:	0e 94 68 0d 	call	0x1ad0	; 0x1ad0 <vPortYield>
				}
			}
		}
		else
		{
			( void ) xTaskResumeAll();
    335c:	70 c0       	rjmp	.+224    	; 0x343e <prvTimerTask+0x1b8>
    335e:	17 db       	rcall	.-2514   	; 0x298e <xTaskResumeAll>
    3360:	6e c0       	rjmp	.+220    	; 0x343e <prvTimerTask+0x1b8>
		}
		#endif /* INCLUDE_xTimerPendFunctionCall */

		/* Commands that are positive are timer commands rather than pended
		function calls. */
		if( xMessage.xMessageID >= ( BaseType_t ) 0 )
    3362:	89 81       	ldd	r24, Y+1	; 0x01
    3364:	88 23       	and	r24, r24
    3366:	0c f4       	brge	.+2      	; 0x336a <prvTimerTask+0xe4>
    3368:	6a c0       	rjmp	.+212    	; 0x343e <prvTimerTask+0x1b8>
		{
			/* The messages uses the xTimerParameters member to work on a
			software timer. */
			pxTimer = xMessage.u.xTimerParameters.pxTimer;
    336a:	ac 80       	ldd	r10, Y+4	; 0x04
    336c:	bd 80       	ldd	r11, Y+5	; 0x05

			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE ) /*lint !e961. The cast is only redundant when NULL is passed into the macro. */
    336e:	f5 01       	movw	r30, r10
    3370:	82 85       	ldd	r24, Z+10	; 0x0a
    3372:	93 85       	ldd	r25, Z+11	; 0x0b
    3374:	89 2b       	or	r24, r25
			{
				/* The timer is in a list, remove it. */
				( void ) uxListRemove( &( pxTimer->xTimerListItem ) );
    3376:	21 f0       	breq	.+8      	; 0x3380 <prvTimerTask+0xfa>
    3378:	c5 01       	movw	r24, r10
    337a:	02 96       	adiw	r24, 0x02	; 2
    337c:	0e 94 a0 0c 	call	0x1940	; 0x1940 <uxListRemove>
			it must be present in the function call.  prvSampleTimeNow() must be
			called after the message is received from xTimerQueue so there is no
			possibility of a higher priority task adding a message to the message
			queue with a time that is ahead of the timer daemon task (because it
			pre-empted the timer daemon task after the xTimeNow value was set). */
			xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3380:	ce 01       	movw	r24, r28
    3382:	06 96       	adiw	r24, 0x06	; 6
    3384:	12 df       	rcall	.-476    	; 0x31aa <prvSampleTimeNow>

			switch( xMessage.xMessageID )
    3386:	e9 81       	ldd	r30, Y+1	; 0x01
    3388:	0e 2e       	mov	r0, r30
    338a:	00 0c       	add	r0, r0
    338c:	ff 0b       	sbc	r31, r31
    338e:	ea 30       	cpi	r30, 0x0A	; 10
    3390:	f1 05       	cpc	r31, r1
    3392:	08 f0       	brcs	.+2      	; 0x3396 <prvTimerTask+0x110>
    3394:	54 c0       	rjmp	.+168    	; 0x343e <prvTimerTask+0x1b8>
    3396:	eb 5c       	subi	r30, 0xCB	; 203
    3398:	ff 4f       	sbci	r31, 0xFF	; 255
    339a:	70 c0       	rjmp	.+224    	; 0x347c <__tablejump2__>
				case tmrCOMMAND_START_FROM_ISR :
				case tmrCOMMAND_RESET :
				case tmrCOMMAND_RESET_FROM_ISR :
				case tmrCOMMAND_START_DONT_TRACE :
					/* Start or restart a timer. */
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    339c:	d5 01       	movw	r26, r10
    339e:	52 96       	adiw	r26, 0x12	; 18
    33a0:	2c 91       	ld	r18, X
    33a2:	52 97       	sbiw	r26, 0x12	; 18
    33a4:	21 60       	ori	r18, 0x01	; 1
    33a6:	52 96       	adiw	r26, 0x12	; 18
    33a8:	2c 93       	st	X, r18
    33aa:	52 97       	sbiw	r26, 0x12	; 18
					if( prvInsertTimerInActiveList( pxTimer,  xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.u.xTimerParameters.xMessageValue ) != pdFALSE )
    33ac:	2a 81       	ldd	r18, Y+2	; 0x02
    33ae:	3b 81       	ldd	r19, Y+3	; 0x03
    33b0:	1c 96       	adiw	r26, 0x0c	; 12
    33b2:	6d 91       	ld	r22, X+
    33b4:	7c 91       	ld	r23, X
    33b6:	1d 97       	sbiw	r26, 0x0d	; 13
    33b8:	62 0f       	add	r22, r18
    33ba:	73 1f       	adc	r23, r19
    33bc:	ac 01       	movw	r20, r24
    33be:	c5 01       	movw	r24, r10
    33c0:	ff dd       	rcall	.-1026   	; 0x2fc0 <prvInsertTimerInActiveList>
    33c2:	88 23       	and	r24, r24
    33c4:	e1 f1       	breq	.+120    	; 0x343e <prvTimerTask+0x1b8>
					{
						/* The timer expired before it was added to the active
						timer list.  Process it now. */
						pxTimer->pxCallbackFunction( ( TimerHandle_t ) pxTimer );
    33c6:	d5 01       	movw	r26, r10
    33c8:	50 96       	adiw	r26, 0x10	; 16
    33ca:	ed 91       	ld	r30, X+
    33cc:	fc 91       	ld	r31, X
    33ce:	51 97       	sbiw	r26, 0x11	; 17
    33d0:	c5 01       	movw	r24, r10
    33d2:	09 95       	icall
						traceTIMER_EXPIRED( pxTimer );

						if( ( pxTimer->ucStatus & tmrSTATUS_IS_AUTORELOAD ) != 0 )
    33d4:	f5 01       	movw	r30, r10
    33d6:	82 89       	ldd	r24, Z+18	; 0x12
    33d8:	82 ff       	sbrs	r24, 2
    33da:	31 c0       	rjmp	.+98     	; 0x343e <prvTimerTask+0x1b8>
						{
							xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START_DONT_TRACE, xMessage.u.xTimerParameters.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    33dc:	4a 81       	ldd	r20, Y+2	; 0x02
    33de:	5b 81       	ldd	r21, Y+3	; 0x03
    33e0:	84 85       	ldd	r24, Z+12	; 0x0c
    33e2:	95 85       	ldd	r25, Z+13	; 0x0d
    33e4:	48 0f       	add	r20, r24
    33e6:	59 1f       	adc	r21, r25
    33e8:	0e 2d       	mov	r16, r14
    33ea:	1f 2d       	mov	r17, r15
    33ec:	2e 2d       	mov	r18, r14
    33ee:	3f 2d       	mov	r19, r15
    33f0:	65 2d       	mov	r22, r5
    33f2:	c5 01       	movw	r24, r10
    33f4:	93 de       	rcall	.-730    	; 0x311c <xTimerGenericCommand>
    33f6:	23 c0       	rjmp	.+70     	; 0x343e <prvTimerTask+0x1b8>
					break;

				case tmrCOMMAND_STOP :
				case tmrCOMMAND_STOP_FROM_ISR :
					/* The timer has already been removed from the active list. */
					pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    33f8:	d5 01       	movw	r26, r10
    33fa:	52 96       	adiw	r26, 0x12	; 18
    33fc:	8c 91       	ld	r24, X
    33fe:	52 97       	sbiw	r26, 0x12	; 18
    3400:	8e 7f       	andi	r24, 0xFE	; 254
    3402:	52 96       	adiw	r26, 0x12	; 18
    3404:	8c 93       	st	X, r24
    3406:	1b c0       	rjmp	.+54     	; 0x343e <prvTimerTask+0x1b8>
					break;

				case tmrCOMMAND_CHANGE_PERIOD :
				case tmrCOMMAND_CHANGE_PERIOD_FROM_ISR :
					pxTimer->ucStatus |= tmrSTATUS_IS_ACTIVE;
    3408:	f5 01       	movw	r30, r10
    340a:	22 89       	ldd	r18, Z+18	; 0x12
    340c:	21 60       	ori	r18, 0x01	; 1
					pxTimer->xTimerPeriodInTicks = xMessage.u.xTimerParameters.xMessageValue;
    340e:	22 8b       	std	Z+18, r18	; 0x12
    3410:	6a 81       	ldd	r22, Y+2	; 0x02
    3412:	7b 81       	ldd	r23, Y+3	; 0x03
    3414:	75 87       	std	Z+13, r23	; 0x0d
					be longer or shorter than the old one.  The command time is
					therefore set to the current time, and as the period cannot
					be zero the next expiry time can only be in the future,
					meaning (unlike for the xTimerStart() case above) there is
					no fail case that needs to be handled here. */
					( void ) prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3416:	64 87       	std	Z+12, r22	; 0x0c
    3418:	68 0f       	add	r22, r24
    341a:	79 1f       	adc	r23, r25
    341c:	9c 01       	movw	r18, r24
    341e:	ac 01       	movw	r20, r24
    3420:	c5 01       	movw	r24, r10
    3422:	ce dd       	rcall	.-1124   	; 0x2fc0 <prvInsertTimerInActiveList>
    3424:	0c c0       	rjmp	.+24     	; 0x343e <prvTimerTask+0x1b8>
					#if ( configSUPPORT_DYNAMIC_ALLOCATION == 1 )
					{
						/* The timer has already been removed from the active list,
						just free up the memory if the memory was dynamically
						allocated. */
						if( ( pxTimer->ucStatus & tmrSTATUS_IS_STATICALLY_ALLOCATED ) == ( uint8_t ) 0 )
    3426:	d5 01       	movw	r26, r10
    3428:	52 96       	adiw	r26, 0x12	; 18
    342a:	8c 91       	ld	r24, X
    342c:	81 fd       	sbrc	r24, 1
    342e:	04 c0       	rjmp	.+8      	; 0x3438 <prvTimerTask+0x1b2>
						{
							vPortFree( pxTimer );
    3430:	c5 01       	movw	r24, r10
    3432:	0e 94 0c 0c 	call	0x1818	; 0x1818 <vPortFree>
    3436:	03 c0       	rjmp	.+6      	; 0x343e <prvTimerTask+0x1b8>
						}
						else
						{
							pxTimer->ucStatus &= ~tmrSTATUS_IS_ACTIVE;
    3438:	8e 7f       	andi	r24, 0xFE	; 254
    343a:	f5 01       	movw	r30, r10
    343c:	82 8b       	std	Z+18, r24	; 0x12
DaemonTaskMessage_t xMessage;
Timer_t *pxTimer;
BaseType_t xTimerListsWereSwitched, xResult;
TickType_t xTimeNow;

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL ) /*lint !e603 xMessage does not have to be initialised as it is passed out, not in, and it is not used unless xQueueReceive() returns pdTRUE. */
    343e:	4e 2d       	mov	r20, r14
    3440:	5f 2d       	mov	r21, r15
    3442:	6c 2d       	mov	r22, r12
    3444:	7d 2d       	mov	r23, r13
    3446:	80 91 02 08 	lds	r24, 0x0802	; 0x800802 <xTimerQueue>
    344a:	90 91 03 08 	lds	r25, 0x0803	; 0x800803 <xTimerQueue+0x1>
    344e:	0e 94 37 10 	call	0x206e	; 0x206e <xQueueReceive>
    3452:	81 11       	cpse	r24, r1
static void prvProcessTimerOrBlockTask( const TickType_t xNextExpireTime, BaseType_t xListWasEmpty )
{
TickType_t xTimeNow;
BaseType_t xTimerListsWereSwitched;

	vTaskSuspendAll();
    3454:	86 cf       	rjmp	.-244    	; 0x3362 <prvTimerTask+0xdc>
    3456:	28 cf       	rjmp	.-432    	; 0x32a8 <prvTimerTask+0x22>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampleTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3458:	d2 d9       	rcall	.-3164   	; 0x27fe <vTaskSuspendAll>
    345a:	c4 01       	movw	r24, r8
    345c:	a6 de       	rcall	.-692    	; 0x31aa <prvSampleTimeNow>
    345e:	8c 01       	movw	r16, r24
		if( xTimerListsWereSwitched == pdFALSE )
    3460:	89 81       	ldd	r24, Y+1	; 0x01
    3462:	81 11       	cpse	r24, r1
    3464:	7c cf       	rjmp	.-264    	; 0x335e <prvTimerTask+0xd8>
				case when the current timer list is empty. */
				if( xListWasEmpty != pdFALSE )
				{
					/* The current timer list is empty - is the overflow list
					also empty? */
					xListWasEmpty = listLIST_IS_EMPTY( pxOverflowTimerList );
    3466:	e0 91 04 08 	lds	r30, 0x0804	; 0x800804 <pxOverflowTimerList>
    346a:	f0 91 05 08 	lds	r31, 0x0805	; 0x800805 <pxOverflowTimerList+0x1>
    346e:	80 81       	ld	r24, Z
    3470:	44 2d       	mov	r20, r4
    3472:	81 11       	cpse	r24, r1
    3474:	45 2d       	mov	r20, r5
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( TickType_t ) 0U;
    3476:	ae 2c       	mov	r10, r14
    3478:	bf 2c       	mov	r11, r15
    347a:	62 cf       	rjmp	.-316    	; 0x3340 <prvTimerTask+0xba>

0000347c <__tablejump2__>:
    347c:	ee 0f       	add	r30, r30
    347e:	ff 1f       	adc	r31, r31
    3480:	05 90       	lpm	r0, Z+
    3482:	f4 91       	lpm	r31, Z
    3484:	e0 2d       	mov	r30, r0
    3486:	09 94       	ijmp

00003488 <memcpy>:
    3488:	fb 01       	movw	r30, r22
    348a:	dc 01       	movw	r26, r24
    348c:	02 c0       	rjmp	.+4      	; 0x3492 <memcpy+0xa>
    348e:	01 90       	ld	r0, Z+
    3490:	0d 92       	st	X+, r0
    3492:	41 50       	subi	r20, 0x01	; 1
    3494:	50 40       	sbci	r21, 0x00	; 0
    3496:	d8 f7       	brcc	.-10     	; 0x348e <memcpy+0x6>
    3498:	08 95       	ret

0000349a <strcat>:
    349a:	fb 01       	movw	r30, r22
    349c:	dc 01       	movw	r26, r24
    349e:	0d 90       	ld	r0, X+
    34a0:	00 20       	and	r0, r0
    34a2:	e9 f7       	brne	.-6      	; 0x349e <strcat+0x4>
    34a4:	11 97       	sbiw	r26, 0x01	; 1
    34a6:	01 90       	ld	r0, Z+
    34a8:	0d 92       	st	X+, r0
    34aa:	00 20       	and	r0, r0
    34ac:	e1 f7       	brne	.-8      	; 0x34a6 <strcat+0xc>
    34ae:	08 95       	ret

000034b0 <_exit>:
    34b0:	f8 94       	cli

000034b2 <__stop_program>:
    34b2:	ff cf       	rjmp	.-2      	; 0x34b2 <__stop_program>
